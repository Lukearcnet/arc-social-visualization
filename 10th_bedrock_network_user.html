
    <!--
================================================================================
DYNAMIC DATA BEDROCK - Fully Dynamic Data Loading
================================================================================

This file is the new bedrock version with dynamic data loading:
- AI chatbot interface with draggable chatbox
- Minimize/expand functionality
- Proper network zoom and layout
- Dynamic data loading from API
- All degree filtering and search features
- Timeline slider functionality
- LOCALHOST URL OPTIMIZATIONS for localhost:3003 format
- Painstakingly optimized UI for localhost environment

CREATED: January 2025 (Based on dynamic data clean v5)
STATUS: âœ… DYNAMIC DATA BEDROCK - SACRED VERSION

KEY FEATURES:
- Draggable chatbox in both collapsed and expanded states
- Minimize button to collapse expanded chatbox
- Proper positioning in upper-right corner
- Correct network zoom level and physics
- Left control panel with proper 380px width
- LOCALHOST-SPECIFIC UI FIXES AND OPTIMIZATIONS
- All original functionality preserved

CRITICAL: This version is optimized for localhost:3003 URLs
DO NOT use file:// URLs with this version

================================================================================
-->

<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
        <title>ARC Social Network - AI Chatbot Bedrock Version</title>
        
        <!-- Vis.js Network -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        
        <!-- Bootstrap -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>
        
        <style>
            /* CSS Custom Properties - Normalized to match 8th bedrock */
            :root {
                /* Standard spacing (matching 8th bedrock) */
                --space-1: 8px;
                --space-2: 12px;
                --space-3: 16px;
                --space-4: 20px;
                
                /* Standard text sizes (matching 8th bedrock) */
                --text-sm: 0.8rem;
                --text-md: 0.9rem;
                --text-lg: 1rem;
                --text-xl: 1.25rem;
                --text-2xl: 1.5rem;
                
                /* Colors (same as 8th bedrock) */
                --fg: #ffffff;
                --fg-muted: #cccccc;
                --bg-1: #000000;
                --bg-2: #141414;
                --bg-3: #1c1c1c;
                --bg-4: #2a2a2a;
                --stroke: rgba(255, 255, 255, 0.1);
                --stroke-muted: rgba(255, 255, 255, 0.2);
                
                /* Standard border radius (matching 8th bedrock) */
                --radius-1: 6px;
                --radius-2: 8px;
                --radius-3: 10px;
            }
            
            /* Modern CSS Reset and Base Styles */
            * {
                box-sizing: border-box;
                -webkit-box-sizing: border-box;
                -moz-box-sizing: border-box;
            }
            
            body {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                margin: 0;
                padding: 0;
                background: #000000;
                min-height: 100vh;
                color: #ffffff;
                line-height: 1.6;
            }
            
            /* Modern Container Layout - Match 8th bedrock CSS Grid */
            .main-container {
                display: grid;
                grid-template-columns: 380px 1fr;
                grid-template-rows: 100%;
                height: 100vh;
                background: #000000;
                position: relative;
                overflow: hidden;
            }
            
            /* Sleek Sidebar Design */
            .sidebar {
                width: 380px;
                padding: 0 16px 16px 16px; /* Match 8th bedrock padding */
                background: rgba(20, 20, 20, 0.98);
                -webkit-backdrop-filter: blur(20px);
                backdrop-filter: blur(20px);
                border-right: 1px solid rgba(64, 64, 64, 0.8);
                overflow: auto;
                z-index: 1000;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }
            
            .controls-section {
                padding: calc(var(--space-4) / 2 * 0.6) 16px;
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
            }
            
            .graph-container {
                position: relative;
                background: rgba(0, 0, 0, 0.8);
                -webkit-backdrop-filter: blur(5px);
                backdrop-filter: blur(5px);
            }
            
            /* Floating Network Controls - Top Right */
            .network-controls-floating {
                position: absolute;
                top: 20px;
                right: 20px;
                z-index: 1000;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            /* Search Control - Separate Container */
            .search-control-floating {
                position: absolute;
                top: 120px; /* Move down further to create proper visual spacing */
                right: 20px;
                z-index: 1000;
                display: flex;
                flex-direction: column;
            }
            
            .network-controls-floating .control-btn {
                background: rgba(20, 20, 20, 0.9);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: var(--fg);
                padding: 8px 12px;
                border-radius: var(--radius-1);
                font-size: 0.8rem; /* Override scaled text to match 8th bedrock exactly */
                cursor: pointer;
                transition: all 0.2s ease;
                backdrop-filter: blur(10px);
                min-width: 100px;
            }
            
            .network-controls-floating .control-btn:hover {
                background: rgba(40, 40, 40, 0.9);
                border-color: rgba(255, 255, 255, 0.4);
            }
            
            /* Search Toggle Button */
            .search-toggle-btn {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 8px !important;
                min-width: auto !important;
                position: relative;
                transition: all 0.3s ease;
            }
            
            /* Search button in its own container */
            .search-control-floating .search-toggle-btn {
                background: rgba(20, 20, 20, 0.9);
                border: 1px solid rgba(255, 255, 255, 0.2);
                color: var(--fg);
                border-radius: var(--radius-1);
                cursor: pointer;
                backdrop-filter: blur(10px);
            }
            
            .search-control-floating .search-toggle-btn:hover {
                background: rgba(40, 40, 40, 0.9);
                border-color: rgba(255, 255, 255, 0.4);
            }
            
            .search-toggle-btn svg {
                width: 16px;
                height: 16px;
                transition: opacity 0.2s ease;
            }
            
            /* Search button expanded state */
            .search-toggle-btn.expanded {
                width: 300px;
                min-width: 300px !important;
                padding: 8px 12px !important;
                justify-content: flex-start;
                z-index: 1001;
            }
            
            .search-toggle-btn.expanded svg {
                opacity: 0;
            }
            
            /* Hidden input field that appears when expanded */
            .search-toggle-btn .search-input {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                padding: 8px 12px;
                border: none;
                background: transparent;
                color: var(--fg);
                font-size: var(--text-md);
                outline: none;
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.2s ease;
            }
            
            .search-toggle-btn.expanded .search-input {
                opacity: 1;
                pointer-events: auto;
            }
            
            .search-toggle-btn .search-input::placeholder {
                color: var(--fg-muted);
            }
            
            /* Search results dropdown */
            .search-results {
                position: absolute;
                top: 100%;
                left: 0;
                right: 0;
                background: rgba(20, 20, 20, 0.95);
                border: 1px solid rgba(255, 255, 255, 0.2);
                border-top: none;
                border-radius: 0 0 var(--radius-1) var(--radius-1);
                backdrop-filter: blur(10px);
                max-height: 200px;
                overflow-y: auto;
                z-index: 1003;
                display: none;
            }
            
            .search-results.show {
                display: block;
            }
            
            .search-result-item {
                padding: var(--space-1) var(--space-2); /* Match connection details */
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background-color 0.2s ease;
                color: #ffffff;
                font-size: 0.72rem; /* Match connection details font size */
                cursor: pointer;
            }
            
            .search-result-item:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }
            
            .search-result-item:last-child {
                border-bottom: none;
            }
            
            /* Timeline Slider Section (moved outside profile-section) */
            .animation-section {
                padding: calc(var(--space-4) / 2 * 0.6) 16px;
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
                background: transparent;
            }
            
            .animation-section > label {
                font-size: var(--text-md);
                font-weight: 500;
                margin-bottom: var(--space-1);
            }
            
            /* Global View Section (moved outside profile-section) */
            .global-view-section {
                padding: calc(var(--space-4) / 2 * 0.6) 16px var(--space-4) 16px;
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
                background: transparent;
            }
            
            .global-view-section > label {
                font-size: 15px !important;
                font-weight: 500 !important;
                margin-bottom: 16px !important;
            }
            
            /* Mode Button Styling - Match Activity Level Text */
            .mode-btn {
                padding: calc(var(--space-1) * 1.4) calc(var(--space-2) * 1.2);
                border: 1px solid var(--stroke-muted);
                background: var(--stroke);
                color: var(--fg-muted);
                border-radius: var(--radius-1);
                cursor: pointer;
                font-size: 0.8rem !important; /* Match Activity Level font size */
                font-weight: 500 !important; /* Match Activity Level font weight */
                letter-spacing: 0.05em;
                transition: all 0.2s ease;
                width: 100%;
                text-align: center;
            }
            
            .mode-btn.active {
                background: var(--fg);
                color: var(--bg-1);
            }
            
            #mynetwork {
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.8);
                border: none;
            }
            
            /* Modern Header Design */
            .header {
                background: var(--bg-1);
                color: var(--fg);
                padding: var(--space-4);
                text-align: center;
                box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
                border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Very thin grey line */
            }
            
            .header h1 {
                margin: 0;
                font-size: var(--text-2xl);
                font-weight: 600;
                letter-spacing: -0.025em;
            }
            
            .header p {
                margin: 8px 0 0 0;
                opacity: 0.9;
                font-size: var(--text-sm);
            }
            
            /* Make the header stats text 50% bigger than normal */
            #headerStats {
                font-size: 1.5em !important;
                font-weight: 500;
                opacity: 0.9;
            }
            
            /* Enhanced Search Section */
            .search-section {
                padding: calc(var(--space-4) / 2 * 0.6) 16px;
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
                background: transparent;
            }
            
            .search-input {
                width: 100%;
                padding: var(--space-1) var(--space-2);
                border: 1px solid var(--stroke-muted);
                border-radius: var(--radius-1);
                font-size: var(--text-md);
                font-weight: 500;
                transition: all 0.2s ease;
                background: rgba(255, 255, 255, 0.1);
                color: #ffffff;
            }
            
            .search-input:focus {
                outline: none;
                border-color: rgba(255, 255, 255, 0.4);
                box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.1);
                transform: translateY(-1px);
            }
            
            .search-results {
                margin-top: 12px;
                max-height: 150px;
                overflow-y: auto !important;
                overflow-x: hidden;
                scrollbar-width: thin;
                scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 6px;
                background: rgba(255, 255, 255, 0.1);
            }
            
            /* Only show height when there are results */
            .search-results:not(:empty) {
                min-height: 40px;
            }
            
            .search-results::-webkit-scrollbar {
                width: 6px;
            }
            
            .search-results::-webkit-scrollbar-track {
                background: transparent;
            }
            
            .search-results::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }
            
            .search-result-item {
                padding: var(--space-1) var(--space-2);
                background: var(--stroke);
                margin-bottom: var(--space-1);
                border-radius: var(--radius-1);
                cursor: pointer;
                font-size: var(--text-md);
                color: var(--fg);
                transition: background 0.2s ease;
            }
            
            .search-result-item:hover {
                background: rgba(255, 255, 255, 0.2);
            }
            
            .search-result-item.selected {
                background: rgba(255, 255, 255, 0.3);
                color: white;
            }
            
            /* Removed conflicting large font size rules - using CSS variables instead */
            
            
            /* Fix user profile section text */
            .user-profile h3 {
                font-size: 1.2rem !important;
                font-weight: 600 !important;
                margin-bottom: 8px !important;
            }
            
            .user-profile p {
                font-size: 0.9rem !important;
                margin: 4px 0 !important;
            }
            
            /* Fix stats cards text */
            .profile-stats .stat-card .stat-number {
                font-size: 1.5rem !important;
                font-weight: 700 !important;
            }
            
            .profile-stats .stat-card .stat-label {
                font-size: 0.8rem !important;
                font-weight: 500 !important;
            }
            
            /* Match activity level text styling to stat labels */
            .profile-header p,
            #profileActivity {
                font-size: 0.9rem !important;
                font-weight: 500 !important;
                margin: 4px 0 !important;
                color: var(--fg-muted) !important;
            }
            
            /* Removed conflicting large font size rule for connections section */
            
            /* Removed conflicting connections-list rule that was preventing scrolling */
            
            
            /* Force arc text to be large */
            .header h3 {
                font-size: 3rem !important;
                font-weight: 700 !important;
                text-align: center !important;
            }
            
            .sidebar input::placeholder {
                font-size: 0.9rem;
            }
            
            .sidebar small,
            .sidebar .text-muted {
                font-size: 0.8rem;
            }
            
            
            /* Search section labels */
            .search-section > label {
                font-size: var(--text-md);
                font-weight: 500;
                margin-bottom: var(--space-2);
            }
            
            /* Timeline info display */
            .timeline-info {
                font-size: var(--text-sm);
                font-weight: 500;
            }
            
            /* Bootstrap text classes */
            .text-center,
            .text-start,
            .text-end {
                font-size: inherit;
            }
            
            
            /* Form check labels */
            .form-check input[type="checkbox"] + label,
            .form-check input[type="radio"] + label {
                font-size: var(--text-sm);
                font-weight: 500;
            }
            
            /* Timeline Slider Section */
            .animation-section {
                padding: var(--space-4);
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
                background: transparent;
            }
            
            .timeline-controls {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            
            .timeline-slider-container {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .dual-slider-container {
                position: relative;
                width: 100%;
                height: 6px;
                background: rgba(255, 255, 255, 0.1);
                border-radius: 3px;
            }
            
            /* Range highlighting between handles */
            .dual-slider-container::before {
                content: '';
                position: absolute;
                top: 0;
                left: var(--range-left, 0%);
                width: var(--range-width, 100%);
                height: 6px;
                background: rgba(3, 218, 238, 0.3);
                border-radius: 3px;
                pointer-events: none;
                z-index: 1;
            }
            
            .timeline-slider {
                position: absolute;
                width: 100%;
                height: 6px;
                border-radius: 3px;
                background: transparent;
                outline: none;
                -webkit-appearance: none;
                appearance: none;
                cursor: pointer;
                margin: 0;
                pointer-events: none; /* Key: Input elements don't intercept events */
            }
            
            .timeline-slider-left {
                z-index: 2; /* Left slider behind right slider */
            }
            
            .timeline-slider-right {
                z-index: 3; /* Right slider on top */
            }
            
            .timeline-slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #ffffff;
                cursor: pointer;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                pointer-events: auto; /* Key: Thumbs are interactive */
            }
            
            .timeline-slider::-moz-range-thumb {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #ffffff;
                cursor: pointer;
                border: none;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
                pointer-events: auto; /* Key: Thumbs are interactive */
            }
            
            .timeline-labels {
                display: flex;
                justify-content: space-between;
                font-size: var(--text-sm);
                color: #cccccc;
                font-weight: 500;
            }
            
            .timeline-info {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 0.8px; /* Additional 2x reduction from 5.6px */
                font-size: 12px;
                color: rgba(255, 255, 255, 0.8);
            }
            
            .timeline-date-left,
            .timeline-date-right {
                flex: 1;
                text-align: center;
            }
            
            .timeline-center {
                flex: 1;
                text-align: center;
                font-weight: 500;
                white-space: pre-line; /* Allow newlines to display */
            }
            
            .timeline-info {
                display: flex;
                justify-content: space-between;
                margin-top: 0.4px; /* Additional 2x reduction from 2.8px */
                color: var(--fg-muted);
                font-size: var(--text-sm);
            }
            
            /* Modern Controls Section */
            .controls-section {
                padding: calc(var(--space-4) / 2 * 0.6) 16px;
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
                background: transparent;
            }
            
            .control-group {
                margin-bottom: var(--space-4);
                padding: calc(var(--space-4) / 2 * 0.6) 16px;
                border-bottom: 1px solid rgba(64, 64, 64, 0.3);
                background: transparent;
            }
            
            .timeline-control-group {
                margin-bottom: var(--space-4);
            }
            
            .timeline-control-group > label {
                font-size: 15px !important;
                font-weight: 500 !important;
                margin-bottom: 16px !important;
            }
            
            .timeline-container {
                margin-bottom: 0;
            }
            
            
            .control-group label {
                display: block;
                margin-bottom: var(--space-1);
                color: var(--fg);
                font-weight: 500;
                font-size: var(--text-md);
            }
            
            
            .label-degrees,
            .label-connection-details {
                display: block;
                margin-bottom: var(--space-1);
                color: var(--fg);
                font-weight: 500;
                font-size: var(--text-md);
            }
            
            .label-connection-details {
                margin-bottom: var(--space-2);
            }
            
            .degree-controls {
                display: flex;
                gap: var(--space-2);
                flex-wrap: wrap;
            }
            
            .degree-filters {
                display: flex;
                flex-direction: column;
                gap: var(--space-1);
            }
            
            .degree-checkbox {
                display: flex;
                align-items: center;
                cursor: pointer;
                font-size: var(--text-md);
                color: var(--fg);
                position: relative;
                padding-left: 30px;
            }
            
            .degree-checkbox input[type="checkbox"] {
                position: absolute;
                opacity: 0;
                cursor: pointer;
                height: 0;
                width: 0;
            }
            
            .checkmark {
                position: absolute;
                left: 0;
                top: 50%;
                transform: translateY(-50%);
                height: 16px;
                width: 16px;
                background-color: rgba(255, 255, 255, 0.1);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 2px;
                transition: all 0.2s ease;
            }
            
            .degree-checkbox:hover .checkmark {
                background-color: rgba(255, 255, 255, 0.2);
            }
            
            .degree-checkbox input:checked ~ .checkmark {
                background-color: #ffffff;
                border-color: #ffffff;
            }
            
            .checkmark:after {
                content: "";
                position: absolute;
                display: none;
                left: 5px;
                top: 2px;
                width: 4px;
                height: 8px;
                border: solid #000000;
                border-width: 0 2px 2px 0;
                transform: rotate(45deg);
            }
            
            .degree-checkbox input:checked ~ .checkmark:after {
                display: block;
            }
            
            /* Smooth transitions for network visualization */
            .vis-network {
                transition: opacity 0.3s ease;
            }
            
            .vis-network canvas {
                transition: all 0.2s ease;
            }
            
            /* Smooth node transitions */
            .vis-node {
                transition: all 0.3s ease;
            }
            
            /* Smooth edge transitions */
            .vis-edge {
                transition: all 0.3s ease;
            }
            
        /* Edge highlighting on hover and selection - more specific selectors */
        .vis-network .vis-edge:hover {
            stroke: #03DAEE !important;
            stroke-width: 3px !important;
        }
        
        .vis-network .vis-edge.vis-selected {
            stroke: #03DAEE !important;
            stroke-width: 3px !important;
        }
        
        /* Target SVG line elements directly */
        .vis-network svg .vis-edge:hover {
            stroke: #03DAEE !important;
            stroke-width: 3px !important;
        }
        
        .vis-network svg .vis-edge.vis-selected {
            stroke: #03DAEE !important;
            stroke-width: 3px !important;
        }

        /* Node popup card styles (from 8th bedrock) */
        .custom-popup {
            background: rgba(0, 0, 0, 0.95);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 9px;
            color: #ffffff;
            padding: 15px;
            font-size: 13.5px;
            max-width: 300px;
            min-width: 225px;
            line-height: 1.4;
            box-shadow: 0 3px 9px rgba(0, 0, 0, 0.3);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .popup-title {
            font-weight: 600;
            margin-bottom: 7.5px;
            color: #ffffff;
            font-size: 15px;
            line-height: 1.3;
            white-space: nowrap;
        }
        
        .popup-info {
            color: #cccccc;
            font-size: 12px;
            margin-bottom: 3.75px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
            
            
            /* Removed duplicate vis-network text color rules - handled by JavaScript */
            
            /* Enhanced Button Design */
            .btn {
                padding: var(--space-1) var(--space-2);
                border: 1px solid var(--stroke-muted);
                border-radius: var(--radius-1);
                cursor: pointer;
                font-size: var(--text-md);
                font-weight: 500;
                transition: all 0.2s ease;
                margin: 2px;
                text-transform: none;
                letter-spacing: 0.025em;
                background: var(--stroke);
                color: var(--fg);
            }
            
            .btn-primary {
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .btn-primary:hover {
                background: var(--stroke-muted);
                border-color: rgba(255, 255, 255, 0.4);
            }
            
            .btn-secondary {
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .btn-secondary:hover {
                background: var(--stroke-muted);
                border-color: rgba(255, 255, 255, 0.4);
            }
            
            .btn-success {
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .btn-success:hover {
                background: rgba(255, 255, 255, 0.2);
                border-color: rgba(255, 255, 255, 0.3);
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
            }
            
            .btn-warning {
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .btn-warning:hover {
                background: var(--stroke-muted);
                border-color: rgba(255, 255, 255, 0.4);
            }
            
            /* Button row for side-by-side buttons */
            .button-row {
                display: flex;
                gap: var(--space-1);
                align-items: center;
            }
            
            /* Modern Profile Section */
            .profile-section {
                padding: calc(var(--space-4) / 2 * 0.6) var(--space-2);
                margin: 0 calc(-1 * var(--space-4)) 0 calc(-1 * var(--space-4));
                display: none;
                background: transparent;
                overflow-y: auto !important;
                overflow-x: hidden;
                scrollbar-width: thin;
                scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
            }
            
            .profile-header {
                background: rgba(255, 255, 255, 0.05);
                color: white;
                padding: 12px;
                border-radius: 6px;
                margin-bottom: 16px;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .profile-name {
                font-size: 1.95rem !important;
                font-weight: 700;
                margin-bottom: 10px;
                letter-spacing: -0.025em;
            }
            
            /* Override conflicting h4 rule for profile name */
            #profileName {
                font-size: 1.95rem !important;
                font-weight: 700 !important;
                margin-bottom: 10px;
                letter-spacing: -0.025em;
            }
            
            /* Removed unused .profile-username rule - class not used in HTML */
            
            .profile-stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
                margin-bottom: 10px;
            }
            
            .stat-card {
                background: rgba(255, 255, 255, 0.05);
                padding: 12px;
                border-radius: 6px;
                text-align: center;
                border: 1px solid rgba(255, 255, 255, 0.2);
                transition: all 0.2s ease;
            }
            
            .stat-card:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
                background: rgba(255, 255, 255, 0.1);
            }
            
            .stat-number {
                font-size: 1.5rem !important;
                font-weight: 700 !important;
                color: #ffffff;
                margin-bottom: 5px;
            }
            
            .stat-label {
                font-size: 0.8rem !important;
                font-weight: 500 !important;
                color: var(--fg-muted);
                text-transform: uppercase !important;
                letter-spacing: 0.05em;
            }
            
            .connections-list {
                max-height: 150px;
                overflow-y: auto !important;
                overflow-x: hidden;
                scrollbar-width: thin;
                scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
                border: 1px solid rgba(255, 255, 255, 0.1);
                border-radius: 16px;
                background: rgba(255, 255, 255, 0.05);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
                /* Ensure text is readable */
                font-size: 8px;
            }
            
            .connections-list::-webkit-scrollbar {
                width: 6px;
            }
            
            .connections-list::-webkit-scrollbar-track {
                background: transparent;
            }
            
            .connections-list::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }
            
            .connection-item {
                padding: var(--space-1) var(--space-2); /* Match 8th bedrock search results */
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
                display: flex;
                justify-content: space-between;
                align-items: center;
                transition: background-color 0.2s ease;
                color: #ffffff;
                font-size: 0.72rem; /* Reduced by 40% from 1.2rem (1.2 * 0.6 = 0.72) */
            }
            
            .connection-item:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }
            
            .connection-item:last-child {
                border-bottom: none;
            }
            
            

            
            /* Enhanced Loading Screen */
            .loading-container {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(255, 255, 255, 0.98);
                padding: 40px;
                border-radius: 20px;
                box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
                z-index: 1000;
                text-align: center;
                -webkit-backdrop-filter: blur(20px);
                backdrop-filter: blur(20px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            
            .loading-spinner {
                border: 4px solid #f1f5f9;
                border-top: 4px solid #667eea;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                animation: spin 1s linear infinite;
                margin: 0 auto 20px;
            }
            
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
            
            /* Activity Color Coding */
            .activity-high { color: #e53e3e; }
            .activity-medium { color: #dd6b20; }
            .activity-low { color: #3182ce; }
            
            /* Responsive Design */
            @media (max-width: 768px) {
                .main-container {
                    flex-direction: column;
                }
                
                .sidebar {
                    width: 100%;
                    height: auto;
                    max-height: 50vh;
                }
                
                .header h1 {
                    font-size: 1.25rem;
                }
                
                .profile-stats {
                    grid-template-columns: 1fr;
                }
            }
            
            /* AI Chatbot Input Bar Styles - DORMANT */
            .chat-input-bar {
                display: none !important; /* Hide chatbox while keeping code intact */
                position: fixed;
                top: 26px;
                right: 26px;
                width: 315px;
                height: 71px;
                background: rgba(255, 255, 255, 0.072);
                background: rgba(255, 255, 255, 0.072);
                background: color(display-p3 1.000 1.000 1.000 / 0.072);
                border: 1px solid rgba(255, 255, 255, 0.108);
                overflow: hidden;
                z-index: 1000;
                box-shadow: 0px 5px 5px rgba(0, 0, 0, 0.25);
                border-radius: 16px;
                display: flex;
                flex-direction: column;
                transition: width 0.3s ease, height 0.3s ease;
                cursor: move;
                user-select: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                resize: both;
                -webkit-resize: both;
                -webkit-backdrop-filter: blur(10px);
                backdrop-filter: blur(10px);
            }
            
            .chat-input-bar.expanded {
                width: 395px;
                height: 355px;
                background: rgba(255, 255, 255, 0.072);
                background: rgba(255, 255, 255, 0.072);
                background: color(display-p3 1.000 1.000 1.000 / 0.072);
                border: 1px solid rgba(255, 255, 255, 0.108);
                min-height: 1170px;
                max-height: 80vh;
                -webkit-backdrop-filter: blur(10px);
                backdrop-filter: blur(10px);
            }
            
            /* Minimize button - positioned relative to chat box */
            .minimize-button {
                position: absolute;
                top: 17px;
                left: 17px;
                width: 11px;
                height: 11px;
                background: rgba(255, 255, 255, 0.15);
                border: 1px solid rgba(255, 255, 255, 0.3);
                border-radius: 7px;
                cursor: pointer;
                display: none;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                transition: all 0.2s ease;
                pointer-events: auto;
                min-width: 11px;
                min-height: 11px;
            }
            
            .chat-input-bar.expanded .minimize-button {
                display: flex;
            }
            
            .minimize-button:hover {
                background: rgba(255, 255, 255, 0.4);
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
            }
            
            .minimize-button svg {
                width: 5px;
                height: 5px;
                stroke: rgba(255, 255, 255, 0.9);
                stroke-width: 2;
                fill: none;
            }
            
            /* Resize handles - temporarily disabled for debugging */
            .resize-handle-top {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 5px;
                cursor: ns-resize;
                z-index: 1;
                background: transparent;
                transition: background-color 0.2s ease;
                pointer-events: none;
            }
            
            .resize-handle-bottom {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                height: 5px;
                cursor: ns-resize;
                z-index: 1;
                background: transparent;
                transition: background-color 0.2s ease;
                pointer-events: none;
            }
            
            .resize-handle-left {
                position: absolute;
                top: 0;
                left: 0;
                width: 3px;
                height: 100%;
                cursor: ew-resize;
                z-index: 1;
                background: transparent;
                transition: background-color 0.2s ease;
                pointer-events: none;
            }
            
            .resize-handle-right {
                position: absolute;
                top: 0;
                right: 0;
                width: 3px;
                height: 100%;
                cursor: ew-resize;
                z-index: 1;
                background: transparent;
                transition: background-color 0.2s ease;
                pointer-events: none;
            }
            
            /* Hover effects for resize handles */
            .resize-handle-top:hover,
            .resize-handle-bottom:hover,
            .resize-handle-left:hover,
            .resize-handle-right:hover {
                background: rgba(255, 255, 255, 0.1);
            }
            
            .input-container {
                padding: 52px 21px;
                display: flex;
                align-items: center;
                gap: 20px;
                background: rgba(255, 255, 255, 0.072);
                background: color(display-p3 1.000 1.000 1.000 / 0.072);
                border-bottom: 1px solid rgba(255, 255, 255, 0.108);
                flex: 0 0 auto;
                position: relative;
                z-index: 9998 !important;
                pointer-events: auto !important;
                min-height: 156px;
            }
            

            
            .chat-container {
                flex: 1;
                display: flex;
                flex-direction: column;
                padding: 26px;
                overflow: visible;
                min-height: 390px;
            }
            
            .chat-messages {
                flex: 1;
                overflow-y: auto;
                overflow-x: hidden;
                margin-bottom: 26px;
                padding-right: 13px;
                min-height: 260px;
                scrollbar-width: thin;
                scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            }
            
            .chat-messages::-webkit-scrollbar {
                width: 6px;
            }
            
            .chat-messages::-webkit-scrollbar-track {
                background: transparent;
            }
            
            .chat-messages::-webkit-scrollbar-thumb {
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
            }
            
            .chat-messages::-webkit-scrollbar-thumb:hover {
                background: rgba(255, 255, 255, 0.5);
            }
            
            .message {
                margin-bottom: 21px;
                display: flex;
                flex-direction: column;
            }
            
            .ai-message {
                align-items: flex-start;
            }
            
            .user-message {
                align-items: flex-end;
            }
            
            .message-content {
                max-width: 95%;
                padding: 5px 6px;
                border-radius: 16px;
                background: rgba(255, 255, 255, 0.072);
                background: rgba(255, 255, 255, 0.072);
                background: color(display-p3 1.000 1.000 1.000 / 0.072);
                border: 1px solid rgba(255, 255, 255, 0.108);
                word-wrap: break-word;
                white-space: pre-wrap;
                line-height: 1.5;
                overflow-wrap: break-word;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            }
            
            .ai-message .message-content {
                background: rgba(255, 255, 255, 0.072);
                background: rgba(255, 255, 255, 0.072);
                background: color(display-p3 1.000 1.000 1.000 / 0.072);
                border: 1px solid rgba(255, 255, 255, 0.108);
            }
            
            .user-message .message-content {
                background: rgba(59, 130, 246, 0.3);
                border: 1px solid rgba(59, 130, 246, 0.4);
            }
            
            .message-content p {
                margin: 0;
                color: #ffffff;
                font-size: 42px;
                line-height: 1.5;
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            }
            
            /* Ensure all text in chat messages has consistent font */
            .chat-messages *,
            .message-content * {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif !important;
            }
            

            
            .chat-input {
                flex: 1;
                padding: 47px 57px;
                border: none;
                border-radius: 10px;
                background: transparent;
                color: #ffffff;
                font-size: 47px;
                transition: all 0.2s ease;
                outline: none;
                text-align: center;
                position: relative;
                z-index: 9999 !important;
                pointer-events: auto !important;
                cursor: text !important;
                user-select: text !important;
            }
            
            .chat-input:focus {
                background: rgba(255, 255, 255, 0.05);
                box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
            }
            
            .chat-input::placeholder {
                color: rgba(255, 255, 255, 0.5);
                font-weight: 400;
                text-align: center;
            }
            
            /* Send Button Styles */
            .send-button {
                background: #000000;
                border: none;
                border-radius: 50%;
                width: 27px;
                height: 27px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s ease;
                flex-shrink: 0;
            }
            
            .send-button:hover {
                background: #333333;
            }
            
            .send-button:active {
                background: #444444;
            }
            
            .send-arrow {
                width: 6px;
                height: 6px;
                stroke: #ffffff;
                stroke-width: 2;
            }
            

            
            /* Responsive adjustments for chat input bar */
            @media (max-width: 1200px) {
                .chat-input-bar {
                    width: 97px;
                }
            }
            
            @media (max-width: 768px) {
                .chat-input-bar {
                    width: 100%;
                    height: auto;
                    max-height: 40vh;
                }
            }
            
            /* Iframe context adjustments for mobile controls */
            @media (max-width: 900px) {
                body.iframe-context .mobile-hamburger {
                    top: 10px !important;
                    z-index: 10000 !important;
                }
                
                body.iframe-context .network-controls-floating {
                    top: 10px !important;
                    z-index: 10000 !important;
                }
            }

            /* ========================================
               MOBILE RESPONSIVE DESIGN
               ======================================== */
            
            /* Hamburger Button */
            .mobile-hamburger {
                position: fixed;
                top: 27px;
                left: 20px;
                z-index: 1000;
                background: rgba(42, 42, 42, 0.9);
                border: 1px solid #333;
                border-radius: 8px;
                width: 44px;
                height: 44px;
                display: none;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 3px;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            .mobile-hamburger:hover {
                background: rgba(42, 42, 42, 1);
                border-color: #007bff;
            }

            .mobile-hamburger .line {
                width: 18px;
                height: 2px;
                background: white;
                border-radius: 1px;
                transition: all 0.3s ease;
            }

            .mobile-hamburger.active .line:nth-child(1) {
                transform: rotate(45deg) translate(5px, 5px);
            }

            .mobile-hamburger.active .line:nth-child(2) {
                opacity: 0;
            }

            .mobile-hamburger.active .line:nth-child(3) {
                transform: rotate(-45deg) translate(5px, -5px);
            }

            /* Mobile Responsive Styles */
            @media (max-width: 900px) {
                .main-container {
                    flex-direction: column;
                }
                
                .sidebar {
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    width: 100%;
                    height: 100%;
                    z-index: 999;
                    transform: translateX(-100%);
                    transition: transform 0.3s ease;
                    padding: 60px 20px 20px 20px;
                    border-bottom-left-radius: 20px;
                    border-bottom-right-radius: 20px;
                    /* Remove max-height constraint for mobile resize */
                    max-height: none;
                }
                
                /* Resize Handle - Mobile Only */
                .resize-handle {
                    position: fixed;
                    left: 0;
                    right: 0;
                    height: 40px;
                    background: rgba(42, 42, 42, 0.9);
                    border-top: 2px solid rgba(255, 255, 255, 0.3);
                    border-bottom-left-radius: 20px;
                    border-bottom-right-radius: 20px;
                    cursor: ns-resize;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 1001;
                    touch-action: none;
                    /* Only show when sidebar is open */
                    transform: translateX(-100%);
                    transition: transform 0.3s ease;
                    /* Position will be set dynamically by JavaScript */
                }
                
                /* Show resize handle when sidebar is open */
                .sidebar.show ~ .resize-handle {
                    transform: translateX(0);
                }
                
                /* Hide resize handle on desktop */
                @media (min-width: 901px) {
                    .resize-handle {
                        display: none;
                    }
                }
                
                .resize-handle::before {
                    content: '';
                    width: 40px;
                    height: 4px;
                    background: rgba(255, 255, 255, 0.4);
                    border-radius: 2px;
                }
                
                
                /* Hide resize handle when sidebar is hidden */
                .sidebar:not(.show) .resize-handle {
                    display: none;
                }
                
                .sidebar.show {
                    transform: translateX(0);
                }
                
                .network-container {
                    width: 100%;
                    height: 100vh;
                }
                
                .mobile-hamburger {
                    display: flex;
                }
                
                /* Align network controls with hamburger button */
                .network-controls-floating {
                    top: 27px;
                }
            }

            @media (min-width: 901px) {
                .mobile-hamburger {
                    display: none;
                }
                
                /* Hide resize handle completely on desktop */
                .resize-handle {
                    display: none !important;
                }
                
                /* Reset network controls position for desktop */
                .network-controls-floating {
                    top: 20px;
                }
                
                /* Ensure desktop sidebar has proper height constraint */
                .sidebar {
                    max-height: 100vh;
                }
                
                /* Ensure desktop graph container has proper height */
                .graph-container {
                    height: 100vh;
                }
            }
            
            /* Intermediate screen sizes - override CSS Grid layout */
            @media (min-width: 380px) and (max-width: 900px) {
                .main-container {
                    display: flex !important;
                    flex-direction: row !important;
                }
                
                .sidebar:not(.show) {
                    width: clamp(200px, 30vw, 300px) !important;
                    min-width: 200px !important;
                    overflow: auto !important;
                }
                
                .sidebar.show {
                    width: 100% !important;
                    min-width: 100% !important;
                }
                
                .graph-container {
                    flex: 1 !important;
                    width: 100% !important;
                }
            }
        </style>
    </head>
    <body>
        <!-- Mobile Hamburger Button -->
        <button class="mobile-hamburger" id="mobileHamburger" onclick="toggleMobileSidebar()">
            <span class="line"></span>
            <span class="line"></span>
            <span class="line"></span>
        </button>

        <div class="main-container">
            <!-- Sidebar -->
            <div class="sidebar">
                
                <!-- Controls Section -->
                <div class="controls-section">
                    <!-- Search Section (hidden in user-centric view) -->
                    <div class="search-section" style="display: none;">
                        <label for="searchInput">Search Users</label>
                        <input type="text" id="searchInput" class="search-input" placeholder="Type name or username...">
                        <div id="searchResults" class="search-results" style="display: none;"></div>
                    </div>
                    
                    <!-- Profile Section (Name and tap boxes) -->
                    <div id="profileSection" class="profile-section">
                    <div class="profile-header">
                        <h4 id="profileName">User Profile</h4>
                        <p id="profileActivity">Activity Level</p>
                    </div>
                    
                    <div class="profile-stats">
                        <div class="stat-card">
                            <div class="stat-number" id="profileTaps">0</div>
                            <div class="stat-label">Taps</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="profileConnections">0</div>
                            <div class="stat-label">Connections</div>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline Slider -->
                <div class="timeline-control-group">
                    <label>Timeline</label>
                    <div class="timeline-container">
                        <div class="dual-slider-container">
                            <input type="range" class="timeline-slider timeline-slider-left" id="timelineSliderLeft" min="0" max="100" value="0">
                            <input type="range" class="timeline-slider timeline-slider-right" id="timelineSliderRight" min="0" max="100" value="100">
                        </div>
                        <div class="timeline-info">
                            <div class="timeline-date-left">
                                <span id="startDate">Start Date</span>
                            </div>
                            <div class="timeline-center">
                            <span id="connectionCount">246 total users</span>
                            </div>
                            <div class="timeline-date-right">
                                <span id="endDate">End Date</span>
                            </div>
                        </div>
                    </div>
                </div>
                </div> <!-- End controls-section -->
                
                <!-- Global View Section -->
                <div class="global-view-section">
                    <label>View Options</label>
                    <div class="mode-toggle">
                        <button class="mode-btn" id="globalViewBtn" onclick="activateGlobalView()">See full Arc Network</button>
                    </div>
                </div>
                
                <!-- Degrees Section (moved outside profile-section) -->
                <div class="control-group" id="degreeFilterSection" style="display: none;">
                    <label class="label-degrees">Degree Connections</label>
                    <div class="degree-filters">
                        <label class="degree-checkbox">
                            <input type="checkbox" id="degree1" checked>
                            <span class="checkmark"></span>
                            1st Degree
                        </label>
                        <label class="degree-checkbox">
                            <input type="checkbox" id="degree2">
                            <span class="checkmark"></span>
                            2nd Degree
                        </label>
                        <label class="degree-checkbox">
                            <input type="checkbox" id="degree3">
                            <span class="checkmark"></span>
                            3rd Degree
                        </label>
                    </div>
                </div>
                
                <!-- Connection Details Section (moved outside profile-section) -->
                <div class="control-group" id="connectionDetailsSection">
                    <label class="label-connection-details">Connection Details</label>
                    <div id="connectionsList" class="connections-list">
                        <div style="padding: 20px; text-align: center; color: #718096;">
                            Select a user to see their connections
                        </div>
                    </div>
                </div>
                
                <!-- Controls Section removed - controls moved to floating controls -->
            </div>
            
            <!-- Mobile Resize Handle - Outside sidebar for proper positioning -->
            <div class="resize-handle" id="resizeHandle"></div>
            
            <!-- Graph Container -->
            <div class="graph-container">
                <div id="mynetwork"></div>
                
                <!-- Floating Network Controls - Top Right -->
                <div class="network-controls-floating">
                    <button class="control-btn" onclick="stabilize()">Stabilize</button>
                    <button class="control-btn" onclick="hideConnections()">Hide Connections</button>
                </div>
                
                <!-- Search Button - Separate Container -->
                <div class="search-control-floating">
                    <button class="control-btn search-toggle-btn" id="searchToggleBtn" onclick="toggleSearch()" title="Search Users">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="m21 21-4.35-4.35"></path>
                        </svg>
                        <input type="text" id="expandableSearchInput" class="search-input" placeholder="Type name or username..." autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off">
                        <div id="expandableSearchResults" class="search-results"></div>
                    </button>
                </div>
            </div>
            
            <!-- AI Chatbot Input Bar -->
            <div class="chat-input-bar" id="chatInputBar">
                <div class="resize-handle-top"></div>
                <div class="resize-handle-bottom"></div>
                <div class="resize-handle-left"></div>
                <div class="resize-handle-right"></div>
                
                <!-- Minimize button - positioned inside chat box -->
                <button class="minimize-button" id="minimizeButton" title="Minimize">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M5 12H19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
                
                <div class="input-container">
                    <input type="text" id="chatInput" class="chat-input" placeholder="Ask me about your network" autocomplete="off" />
                    <button id="sendButton" class="send-button" onclick="sendMessage()">
                        <svg class="send-arrow" width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M22 2L11 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                            <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
                
                <div class="chat-container" id="chatContainer" style="display: none;">
                    <div class="chat-messages" id="chatMessages">
                                        <div class="message ai-message">
                    <div class="message-content">
                        <p>ðŸ¤– Hello! I'm your AI assistant powered by OpenAI. I can analyze your social network data and provide insights about:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>ðŸ‘¥ User connections and activity patterns</li>
                            <li>ðŸ¢ Professional networks and LinkedIn data</li>
                            <li>ðŸ“ Geographic patterns and venue preferences</li>
                            <li>ðŸ“Š Network statistics and metrics</li>
                            <li>ðŸ” Finding users with specific characteristics</li>
                        </ul>
                        <p>Try asking me questions like:</p>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li>"Who are the most connected people?"</li>
                            <li>"Show me people who work in tech"</li>
                            <li>"What are the most popular venues?"</li>
                            <li>"Find users with high activity levels"</li>
                        </ul>
                    </div>
                </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Loading Screen -->
        <div id="loadingContainer" class="loading-container">
            <div class="loading-spinner"></div>
            <h4>Loading Enhanced Network</h4>
            <p id="loadingStats">Initializing users and connections...</p>
        </div>
        

        
        <script>
            // Global variables
            let network;
            let nodes;
            let edges;
            let allNodes;
            let allEdges;
            let totalEdgesInDataset = 0; // Store total edges for consistent reference
            let globalViewEnabled = false; // Track Global View toggle state
            let searchIndex = []; // Will be populated dynamically
            
            // Mobile resize variables
            let isMobileResizing = false;
            let mobileStartY = 0;
            let mobileStartHeight = 0;
            let mobileCurrentHeight = 0;
            
            // Safety helper for string operations
            const lower = v => (v ?? '').toString().toLowerCase();
            
            // Dynamic data loading functions
            async function loadData() {
                try {
                    // If we're in an iframe, wait a bit for parent to load data first
                    if (window !== window.top) {
                        console.log('ðŸ”„ Iframe context detected - waiting for parent to load data first...');
                        await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms for parent
                    }
                    
                    console.log('ðŸ”„ Loading dynamic data from API...');
                    const response = await fetch('/api/data?t=' + Date.now());
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const api = await response.json();
                    
                    // ---- Back-compat + null-safety shim (do not edit) ----
                    const taps =
                      Array.isArray(api.taps) ? api.taps :
                      Array.isArray(api.tap_data) ? api.tap_data : [];

                    const users =
                      Array.isArray(api.users) ? api.users :
                      Array.isArray(api.user_profiles) ? api.user_profiles : [];

                    // normalize both shapes so downstream code can use either
                    const data = {
                      ...api,
                      taps,
                      tap_data: taps,
                      users,
                      user_profiles: users,
                    };

                    // common short names; always safe
                    const TAPS  = data.taps;          // []
                    const USERS = data.users;         // []
                    // -------------------------------------------------------
                    
                    // Data loaded successfully
                    
                    // Create all data structures
                    createSearchIndex(TAPS, USERS);
                    createTimelineData(TAPS);
                    createNetworkData(TAPS, USERS);
                    
                    return data;
                } catch (error) {
                    console.error('âŒ Error loading data:', error);
                    throw error;
                }
            }
            
            function createSearchIndex(taps, users) {
                // Safety guard for undefined users
                const safeUsers = Array.isArray(users) ? users : [];
                searchIndex = safeUsers.map(user => ({
                    id: user.user_id,
                    name: `${user.basic_info.first_name} ${user.basic_info.last_name}`,
                    username: user.basic_info.username,
                    taps: user.profile_stats.tap_count,
                    connections: user.profile_stats.connections_count,
                    activity_level: user.profile_stats.tap_count > 50 ? 'high' : user.profile_stats.tap_count > 20 ? 'medium' : 'low'
                }));
            }
            
            function createTimelineData(taps) {
                // Use taps for timeline events
                timeSequence = Array.isArray(taps) ? taps : [];
                
                // Sort timeSequence by time to ensure chronological order
                timeSequence.sort((a, b) => new Date(a.time) - new Date(b.time));
                
                // Create user first taps from taps - find earliest timestamp for each user
                userFirstTaps = {};
                if (Array.isArray(taps)) {
                    taps.forEach(tap => {
                        // Check user1
                        if (!userFirstTaps[tap.user1_id] || tap.time < userFirstTaps[tap.user1_id]) {
                            userFirstTaps[tap.user1_id] = tap.time;
                        }
                        // Check user2
                        if (!userFirstTaps[tap.user2_id] || tap.time < userFirstTaps[tap.user2_id]) {
                            userFirstTaps[tap.user2_id] = tap.time;
                        }
                    });
                }
            }
            
            function createDegreeConnections(tapData) {
                const degreeConnections = {};
                
                // Safety guard for undefined tapData
                const safeTapData = Array.isArray(tapData) ? tapData : [];
                
                // Create adjacency map from tap data
                const adjacencyMap = {};
                safeTapData.forEach(tap => {
                    if (!adjacencyMap[tap.user1_id]) adjacencyMap[tap.user1_id] = new Set();
                    if (!adjacencyMap[tap.user2_id]) adjacencyMap[tap.user2_id] = new Set();
                    adjacencyMap[tap.user1_id].add(tap.user2_id);
                    adjacencyMap[tap.user2_id].add(tap.user1_id);
                });
                
                // Calculate degree connections for each user
                Object.keys(adjacencyMap).forEach(userId => {
                    const degree1 = Array.from(adjacencyMap[userId] || []);
                    const degree2 = new Set();
                    const degree3 = new Set();
                    
                    // Calculate degree 2 connections
                    degree1.forEach(conn1 => {
                        if (adjacencyMap[conn1]) {
                            adjacencyMap[conn1].forEach(conn2 => {
                                if (conn2 !== userId && !degree1.includes(conn2)) {
                                    degree2.add(conn2);
                                }
                            });
                        }
                    });
                    
                    // Calculate degree 3 connections
                    degree2.forEach(conn2 => {
                        if (adjacencyMap[conn2]) {
                            adjacencyMap[conn2].forEach(conn3 => {
                                if (conn3 !== userId && !degree1.includes(conn3) && !degree2.has(conn3)) {
                                    degree3.add(conn3);
                                }
                            });
                        }
                    });
                    
                    degreeConnections[userId] = {
                        degree_1_connections: degree1,
                        degree_2_connections: Array.from(degree2),
                        degree_3_connections: Array.from(degree3)
                    };
                });
                
                return degreeConnections;
            }
            
            function createNetworkData(taps, users) {
                
                // Create degree connections data for each user
                const degreeConnections = createDegreeConnections(taps);
                
                // Create nodes from users
                const safeUsers = Array.isArray(users) ? users : [];
                const nodeData = safeUsers.map(user => {
                    const name = `${user.basic_info.first_name} ${user.basic_info.last_name}`;
                    const taps = user.profile_stats.tap_count;
                    const connections = user.profile_stats.connections_count;
                    
                    // Use same sizing formula as timeline: 10px base + 0.167px per tap, max 60px
                    let size = 10; // Base size
                    if (taps > 0) {
                        // Same formula as timeline sizing: 300 taps = 60px max size
                        size = Math.max(10, Math.min(60, 10 + (taps * 0.167)));
                    }
                    
                    return {
                        id: user.user_id,
                        label: name,
                        title: `${name} - ${taps} taps, ${connections} connections`,
                        size: size,
                        color: getActivityColor(taps),
                        mass: 1.0,
                        physics: true,
                        shape: "dot",
                        font: { color: "#000000" },
                        taps: taps,
                        connections: connections,
                        activity_level: taps > 50 ? 'high' : taps > 20 ? 'medium' : 'low',
                        profile_data: degreeConnections[user.user_id] || {
                            degree_1_connections: [],
                            degree_2_connections: [],
                            degree_3_connections: []
                        },
                        // Add enriched data fields from GCP
                        home_location: user.home_location?.geographic_context || user.home_location?.home_location || 'No location specified',
                        bio: user.bio_analysis?.bio_text || user.bio_analysis?.bio_summary || 'No bio provided',
                        linkedin: user.social_urls?.linkedin || null,
                        username: user.basic_info.username || ''
                    };
                });
                
                // Create edges from taps - count actual taps between each pair
                const safeTaps = Array.isArray(taps) ? taps : [];
                
                // Count taps between each pair of users
                const tapCounts = {};
                safeTaps.forEach(tap => {
                    // Create a consistent key for each pair (smaller ID first)
                    const pairKey = tap.user1_id < tap.user2_id 
                        ? `${tap.user1_id}-${tap.user2_id}` 
                        : `${tap.user2_id}-${tap.user1_id}`;
                    
                    if (!tapCounts[pairKey]) {
                        tapCounts[pairKey] = {
                            user1: tap.user1_id < tap.user2_id ? tap.user1_id : tap.user2_id,
                            user2: tap.user1_id < tap.user2_id ? tap.user2_id : tap.user1_id,
                            count: 0
                        };
                    }
                    tapCounts[pairKey].count++;
                });
                
                // Create one edge per pair with correct tap count
                const edgeData = Object.values(tapCounts).map((pair, index) => {
                    const tapCount = pair.count;
                    
                    // 5-segment system for thickness and color
                    let thickness, color;
                    
                    if (tapCount === 1) {
                        thickness = 0.5;
                        color = "#E0E0E0"; // Light grey
                    } else if (tapCount >= 2 && tapCount <= 3) {
                        thickness = 1.5;
                        color = "#D0D0D0"; // Medium-light grey
                    } else if (tapCount >= 4 && tapCount <= 5) {
                        thickness = 2.5;
                        color = "#C0C0C0"; // Medium grey
                    } else if (tapCount >= 6 && tapCount <= 8) {
                        thickness = 3.5;
                        color = "#F0F0F0"; // Light white
                    } else if (tapCount >= 9) {
                        thickness = 5.0;
                        color = "#FFFFFF"; // White
                    } else {
                        // Fallback for edge cases
                        thickness = 0.5;
                        color = "#E0E0E0";
                    }
                    
                    return {
                    id: index,
                    from: pair.user1,
                    to: pair.user2,
                        color: color,
                        width: thickness,
                    title: `${pair.count} tap${pair.count === 1 ? '' : 's'}`, // Correct pluralization
                    tap_count: pair.count,
                    physics: true,
                    smooth: false
                    };
                });
                
                // Update the datasets
                nodes = new vis.DataSet(nodeData);
                edges = new vis.DataSet(edgeData);
                
                // Store references
                allNodes = nodes.get({ returnType: "Object" });
                allEdges = edges.get({ returnType: "Object" });
                totalEdgesInDataset = edgeData.length;
                
            }
            
            function getActivityColor(taps) {
                // Match bedrock's grey-to-white gradient based on tap count
                if (taps >= 25) {
                    return '#FFFFFF'; // White for very high activity
                } else if (taps >= 20) {
                    return '#F5F5F5'; // Very light grey for high activity
                } else if (taps >= 15) {
                    return '#E0E0E0'; // Light grey for medium-high activity
                } else if (taps >= 10) {
                    return '#C0C0C0'; // Silver for medium activity
                } else if (taps >= 5) {
                    return '#A9A9A9'; // Dark grey for low-medium activity
                } else if (taps >= 1) {
                    return '#808080'; // Grey for low activity
                } else {
                    return '#D3D3D3'; // Default light grey
                }
            }
            
            // Chat functionality variables
            let chatHistory = [];
            let isChatSidebarCollapsed = false;
            let isDragging = false;
            let dragOffset = { x: 0, y: 0 };
            let isResizing = false;
            let resizeDirection = '';
            let startSize = { width: 0, height: 0 };
            
            let selectedNode = null;
            let currentDegreeFilter = {1: true, 2: true, 3: true};
            let savedDegreeFilterState = {1: true, 2: true, 3: true}; // Store degree filter state when timeline < 100%
            
            // Animation variables
            let timeSequence = []; // Will be populated dynamically
            let userFirstTaps = {}; // Will be populated dynamically
            let animationInterval = null;
            let currentAnimationIndex = 0;
            let animationSpeed = 1000; // milliseconds between events
            let isAnimating = false;
            let visibleNodes = new Set();
            let visibleEdges = new Set();
            let animationMode = 'global'; // 'global' or 'user-centric'
            let selectedUserForAnimation = null;
            // timelineSlider variable removed - now using dual slider system
            let isSliderDragging = false;
            
            // Chat functionality functions
            function startDrag(e) {
                console.log('ðŸ”„ startDrag called, target:', e.target.tagName, e.target.className, e.target.id);
                
                // Don't drag if clicking on interactive elements, resize handles, or chat messages area
                if (e.target.closest('.chat-input') ||
                    e.target.closest('.send-button') ||
                    e.target.closest('.minimize-button') ||
                    e.target.closest('#minimizeButton') ||
                    e.target.closest('button') ||
                    e.target.closest('.chat-messages') ||
                    e.target.closest('.chat-container') ||
                    e.target.classList.contains('resize-handle-top') ||
                    e.target.classList.contains('resize-handle-bottom') ||
                    e.target.classList.contains('resize-handle-left') ||
                    e.target.classList.contains('resize-handle-right')) {
                    console.log('ðŸš« Drag prevented - interactive element or chat messages area detected');
                    return;
                }
                
                
                isDragging = true;
                const chatInputBar = document.getElementById('chatInputBar');
                const rect = chatInputBar.getBoundingClientRect();
                
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                chatInputBar.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                // Use requestAnimationFrame for smooth dragging
                if (drag.rafId) {
                    cancelAnimationFrame(drag.rafId);
                }
                
                drag.rafId = requestAnimationFrame(() => {
                    const chatInputBar = document.getElementById('chatInputBar');
                    const x = e.clientX - dragOffset.x;
                    const y = e.clientY - dragOffset.y;
                    
                    // Keep within viewport bounds
                    const maxX = window.innerWidth - chatInputBar.offsetWidth;
                    const maxY = window.innerHeight - chatInputBar.offsetHeight;
                    
                    const clampedX = Math.max(0, Math.min(x, maxX));
                    const clampedY = Math.max(0, Math.min(y, maxY));
                    
                    chatInputBar.style.left = clampedX + 'px';
                    chatInputBar.style.top = clampedY + 'px';
                    chatInputBar.style.right = 'auto';
                    chatInputBar.style.transform = 'none';
                });
            }
            
            function stopDrag() {
                if (!isDragging) return;
                
                isDragging = false;
                const chatInputBar = document.getElementById('chatInputBar');
                chatInputBar.style.cursor = 'move';
                
                // Cancel any pending animation frame
                if (drag.rafId) {
                    cancelAnimationFrame(drag.rafId);
                    drag.rafId = null;
                }
            }
            
            function startResize(e) {
                const target = e.target;
                isResizing = true;
                
                if (target.classList.contains('resize-handle-left') || target.classList.contains('resize-handle-right')) {
                    resizeDirection = 'horizontal';
                } else if (target.classList.contains('resize-handle-top') || target.classList.contains('resize-handle-bottom')) {
                    resizeDirection = 'vertical';
                }
                
                const chatInputBar = document.getElementById('chatInputBar');
                startSize.width = chatInputBar.offsetWidth;
                startSize.height = chatInputBar.offsetHeight;
                
                // Store which handle was clicked
                chatInputBar.dataset.resizeHandle = target.className;
                
                e.preventDefault();
                e.stopPropagation();
            }
            
            function resize(e) {
                if (!isResizing) return;
                
                // Use requestAnimationFrame for smooth resizing
                if (resize.rafId) {
                    cancelAnimationFrame(resize.rafId);
                }
                
                resize.rafId = requestAnimationFrame(() => {
                    const chatInputBar = document.getElementById('chatInputBar');
                    const rect = chatInputBar.getBoundingClientRect();
                    const handle = chatInputBar.dataset.resizeHandle;
                    
                    if (resizeDirection === 'horizontal') {
                        if (handle.includes('resize-handle-right')) {
                            const newWidth = e.clientX - rect.left;
                            if (newWidth > 61) { // Minimum width
                                chatInputBar.style.width = newWidth + 'px';
                            }
                        } else if (handle.includes('resize-handle-left')) {
                            const newWidth = rect.right - e.clientX;
                            if (newWidth > 61) { // Minimum width
                                chatInputBar.style.width = newWidth + 'px';
                                chatInputBar.style.left = e.clientX + 'px';
                            }
                        }
                    } else if (resizeDirection === 'vertical') {
                        if (handle.includes('resize-handle-bottom')) {
                            const newHeight = e.clientY - rect.top;
                            if (newHeight > 100) { // Minimum height
                                chatInputBar.style.height = newHeight + 'px';
                            }
                        } else if (handle.includes('resize-handle-top')) {
                            const newHeight = rect.bottom - e.clientY;
                            if (newHeight > 100) { // Minimum height
                                chatInputBar.style.height = newHeight + 'px';
                                chatInputBar.style.top = e.clientY + 'px';
                            }
                        }
                    }
                });
            }
            
            function stopResize() {
                if (!isResizing) return;
                
                isResizing = false;
                resizeDirection = '';
                
                // Cancel any pending animation frame
                if (resize.rafId) {
                    cancelAnimationFrame(resize.rafId);
                    resize.rafId = null;
                }
            }
            
            function expandChatBar() {
                const chatInputBar = document.getElementById('chatInputBar');
                const chatContainer = document.getElementById('chatContainer');
                const minimizeButton = document.getElementById('minimizeButton');
                
                chatInputBar.classList.add('expanded');
                chatContainer.style.display = 'flex';
                
                // Show minimize button
                if (minimizeButton) {
                    minimizeButton.style.display = 'flex';
                    
                }
            }
            
            function collapseChatBar() {
                console.log('collapseChatBar function called!');
                
                const chatInputBar = document.getElementById('chatInputBar');
                const chatContainer = document.getElementById('chatContainer');
                const minimizeButton = document.getElementById('minimizeButton');
                
                console.log('chatInputBar found:', chatInputBar);
                console.log('chatContainer found:', chatContainer);
                
                // Remove expanded class
                chatInputBar.classList.remove('expanded');
                
                // Hide chat container
                chatContainer.style.display = 'none';
                
                // Hide minimize button
                if (minimizeButton) {
                    minimizeButton.style.display = 'none';
                }
                
                // Reset any custom height that might have been set
                chatInputBar.style.height = '';
                
                // Clear the input field
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.value = '';
                }
                
                console.log('Chat bar collapsed successfully');
            }
            
            async function sendMessage() {
                const chatInput = document.getElementById('chatInput');
                const message = chatInput.value.trim();
                
                if (message && !isAILoading) {
                    // Auto-expand the chat bar when sending a message
                    expandChatBar();
                    
                    addMessage('user', message);
                    chatInput.value = '';
                    
                    try {
                        // Get AI response
                        const response = await generateAIResponse(message);
                        addMessage('ai', response);
                        
                        // Ensure the chat box expands to accommodate the response
                        const chatInputBar = document.getElementById('chatInputBar');
                        const chatContainer = document.getElementById('chatContainer');
                        
                        // Calculate if we need to expand further based on content
                        const messagesHeight = chatContainer.scrollHeight;
                        const currentHeight = chatInputBar.offsetHeight;
                        
                        if (messagesHeight > currentHeight - 100) {
                            const newHeight = Math.min(messagesHeight + 100, window.innerHeight * 0.8);
                            chatInputBar.style.height = newHeight + 'px';
                        }
                    } catch (error) {
                        console.error('Error in sendMessage:', error);
                        addMessage('ai', 'Sorry, I encountered an error while processing your request. Please try again.');
                    }
                }
            }
            
            function addMessage(type, content) {
                const chatMessages = document.getElementById('chatMessages');
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}-message`;
                
                const messageContent = document.createElement('div');
                messageContent.className = 'message-content';
                
                const messageText = document.createElement('p');
                messageText.textContent = content;
                
                messageContent.appendChild(messageText);
                messageDiv.appendChild(messageContent);
                chatMessages.appendChild(messageDiv);
                
                // Smooth scroll to bottom
                setTimeout(() => {
                    chatMessages.scrollTo({
                        top: chatMessages.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 100);
                
                // Store in chat history
                chatHistory.push({ type, content, timestamp: new Date() });
            }
            
            // AI API Integration - File:// URL Compatible
            let isAILoading = false;
            
            async function generateAIResponse(message) {
                try {
                    // Show loading state
                    isAILoading = true;
                    updateLoadingState(true);
                    
                    // Prepare network context data
                    const networkContext = prepareNetworkContext();
                    
                    // Try local enriched data responses first, fallback to OpenAI API
                    console.log('Attempting local enriched data response...');
                    console.log('Network context prepared:', networkContext);
                    
                    // Force local response for testing enriched data
                    console.log('Using local enriched data response...');
                    return generateLocalResponse(message, networkContext);
                    
                    // OpenAI API fallback (commented out for testing)
                    /*
                    try {
                        const systemPrompt = createSystemPrompt(networkContext);
                            
                            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': 'Bearer YOUR_OPENAI_API_KEY_HERE'
                                },
                                body: JSON.stringify({
                                    model: 'gpt-4o-mini',
                                    messages: [
                                        { role: 'system', content: systemPrompt },
                                        { role: 'user', content: message }
                                    ],
                                    max_tokens: 1000,
                                    temperature: 0.7
                                })
                            });
                            
                            console.log('OpenAI response status:', response.status);
                            
                            if (!response.ok) {
                                const errorData = await response.json().catch(() => ({}));
                                console.log('OpenAI API error:', response.status, errorData);
                                throw new Error(`OpenAI API error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                            }
                            
                            const data = await response.json();
                            console.log('OpenAI API success!');
                            return data.choices[0].message.content;
                        } catch (apiError) {
                            console.log('API error details:', apiError);
                            throw apiError;
                        }
                        
                    } catch (apiError) {
                        console.log('API failed, using local analysis:', apiError.message);
                        // Fall back to local intelligent analysis
                        return generateLocalResponse(message, networkContext);
                    }
                    */
                    
                } catch (error) {
                    console.error('AI Response Error:', error);
                    return "I'm having trouble processing your request. Please try again or ask a different question.";
                } finally {
                    // Hide loading state
                    isAILoading = false;
                    updateLoadingState(false);
                }
            }
            
            function generateLocalResponse(message, networkContext) {
                const lowerMessage = message.toLowerCase();
                const users = networkContext.users || {};
                const connections = networkContext.connections || {};
                const networkStats = networkContext.network_stats || {};
                const enrichedData = window.enrichedData;
                
                // Find specific users
                if (lowerMessage.includes('grace brown') || lowerMessage.includes('grace')) {
                    const graceUser = Object.values(users).find(user => 
                        user.name.toLowerCase().includes('grace brown') || 
                        user.name.toLowerCase().includes('grace')
                    );
                    if (graceUser) {
                        const locationInfo = graceUser.location ? ` She is located in ${graceUser.location}.` : '';
                        
                        // Try to get enriched data for Grace
                        let enrichedInfo = '';
                        if (enrichedData && enrichedData.userProfiles) {
                            const enrichedGrace = enrichedData.userProfiles.find(profile => 
                                profile.basic_info?.first_name?.toLowerCase().includes('grace') ||
                                profile.basic_info?.username === graceUser.username
                            );
                            if (enrichedGrace) {
                                const home = enrichedGrace.home_location?.geographic_context;
                                const bio = enrichedGrace.bio_analysis?.bio_summary;
                                const linkedin = enrichedGrace.social_urls?.linkedin;
                                
                                if (home && home !== 'No home location specified') {
                                    enrichedInfo += ` She lives in ${home}.`;
                                }
                                if (bio && bio !== 'No bio provided') {
                                    enrichedInfo += ` ${bio}`;
                                }
                                if (linkedin) {
                                    enrichedInfo += ` She has a LinkedIn profile: ${linkedin}`;
                                }
                            }
                        }
                        
                        return `Grace Brown (@${graceUser.username}) is a user in the network with ${graceUser.taps} taps and ${graceUser.connections} connections. Her activity level is ${graceUser.activity_level}.${locationInfo}${enrichedInfo}`;
                    }
                }
                
                // Most connected users
                if (lowerMessage.includes('most connected') || lowerMessage.includes('connected')) {
                    const sortedUsers = Object.values(users).sort((a, b) => b.connections - a.connections);
                    const topUsers = sortedUsers.slice(0, 3);
                    return `The most connected users in the network are:\n${topUsers.map((user, i) => `${i+1}. ${user.name} (@${user.username}) - ${user.connections} connections, ${user.taps} taps`).join('\n')}`;
                }
                
                // Most active users
                if (lowerMessage.includes('most active') || lowerMessage.includes('active')) {
                    const sortedUsers = Object.values(users).sort((a, b) => b.taps - a.taps);
                    const topUsers = sortedUsers.slice(0, 3);
                    return `The most active users in the network are:\n${topUsers.map((user, i) => `${i+1}. ${user.name} (@${user.username}) - ${user.taps} taps, ${user.connections} connections`).join('\n')}`;
                }
                
                // Network statistics
                if (lowerMessage.includes('network') || lowerMessage.includes('statistics') || lowerMessage.includes('stats')) {
                    return `Network Statistics:\nâ€¢ Total Users: ${networkStats.total_users}\nâ€¢ Total Connections: ${networkStats.total_connections}\nâ€¢ Most Active User: ${networkStats.most_active_user}\nâ€¢ Most Connected User: ${networkStats.most_connected_user}`;
                }
                
                // Tech users
                if (lowerMessage.includes('tech') || lowerMessage.includes('technology')) {
                    const techUsers = Object.values(users).filter(user => 
                        user.linkedin_data?.job_title?.toLowerCase().includes('tech') ||
                        user.linkedin_data?.job_title?.toLowerCase().includes('software') ||
                        user.linkedin_data?.job_title?.toLowerCase().includes('engineer') ||
                        user.linkedin_data?.company?.toLowerCase().includes('tech')
                    );
                    if (techUsers.length > 0) {
                        return `Users working in tech:\n${techUsers.map(user => `â€¢ ${user.name} (@${user.username}) - ${user.linkedin_data.job_title} at ${user.linkedin_data.company}`).join('\n')}`;
                    }
                }
                
                // Location-based queries
                if (lowerMessage.includes('nashville') || lowerMessage.includes('location') || lowerMessage.includes('where')) {
                    const usersWithLocation = Object.values(users).filter(user => user.location);
                    if (usersWithLocation.length > 0) {
                        const locationCounts = {};
                        usersWithLocation.forEach(user => {
                            locationCounts[user.location] = (locationCounts[user.location] || 0) + 1;
                        });
                        
                        const topLocations = Object.entries(locationCounts)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 5)
                            .map(([location, count]) => `${location}: ${count} users`);
                        
                        return `Network Geographic Distribution:\n${topLocations.map(loc => `â€¢ ${loc}`).join('\n')}`;
                    }
                }
                
                // Users in specific cities
                if (lowerMessage.includes('users in') || lowerMessage.includes('people in')) {
                    const cityMatch = lowerMessage.match(/(?:users?|people) in (\w+)/i);
                    if (cityMatch) {
                        const cityName = cityMatch[1].toLowerCase();
                        const cityUsers = Object.values(users).filter(user => 
                            user.location && user.location.toLowerCase().includes(cityName)
                        );
                        
                        if (cityUsers.length > 0) {
                            return `Users in ${cityMatch[1]}:\n${cityUsers.map(user => `â€¢ ${user.name} (@${user.username}) - ${user.taps} taps, ${user.connections} connections`).join('\n')}`;
                        } else {
                            return `I don't have data for users specifically in ${cityMatch[1]}. The main locations in the network are: Nashville, Dallas, San Francisco, Chicago, and various cities in Wyoming.`;
                        }
                    }
                }
                
                // Venue queries using enriched data
                if (lowerMessage.includes('venue') || lowerMessage.includes('restaurant') || lowerMessage.includes('favorite place') || lowerMessage.includes('where do people hang out')) {
                    if (enrichedData && enrichedData.tap_data) {
                        const venues = enrichedData.tap_data
                            .map(tap => tap.venue_context?.venue_name)
                            .filter(venue => venue && venue !== 'Unknown Location' && !venue.includes('Location ('))
                            .slice(0, 20);
                        
                        const venueCounts = {};
                        venues.forEach(venue => {
                            venueCounts[venue] = (venueCounts[venue] || 0) + 1;
                        });
                        
                        const topVenues = Object.entries(venueCounts)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 5);
                        
                        if (topVenues.length > 0) {
                            return `Top venues in the network:\n${topVenues.map(([venue, count]) => `â€¢ ${venue} (${count} visits)`).join('\n')}`;
                        } else {
                            return 'Most locations in the network are showing as coordinates rather than specific venue names.';
                        }
                    }
                }
                
                // LinkedIn queries using enriched data
                if (lowerMessage.includes('linkedin') || lowerMessage.includes('job') || lowerMessage.includes('work') || lowerMessage.includes('profession')) {
                    if (enrichedData && enrichedData.user_profiles) {
                        const usersWithLinkedIn = enrichedData.user_profiles.filter(user => 
                            user.social_urls?.linkedin && user.social_urls.linkedin !== null
                        );
                        
                        if (usersWithLinkedIn.length > 0) {
                            const sampleUsers = usersWithLinkedIn.slice(0, 5);
                            const userList = sampleUsers.map(user => {
                                const name = user.basic_info?.first_name || 'Unknown';
                                const username = user.basic_info?.username || '';
                                const linkedin = user.social_urls.linkedin;
                                return `â€¢ ${name} (@${username}) - ${linkedin}`;
                            }).join('\n');
                            
                            return `Users with LinkedIn profiles:\n${userList}\n\nTotal: ${usersWithLinkedIn.length} users have LinkedIn profiles.`;
                        } else {
                            return 'No LinkedIn profiles found in the enriched data.';
                        }
                    }
                }
                
                // Venue queries using enriched data
                if (lowerMessage.includes('venue') || lowerMessage.includes('restaurant') || lowerMessage.includes('favorite place') || lowerMessage.includes('where do people hang out')) {
                    if (enrichedData && enrichedData.tapData) {
                        const venues = enrichedData.tapData
                            .map(tap => tap.venue_context?.venue_name)
                            .filter(venue => venue && !venue.startsWith('Location'))
                            .filter(Boolean);
                        
                        if (venues.length > 0) {
                            const venueCounts = {};
                            venues.forEach(venue => {
                                venueCounts[venue] = (venueCounts[venue] || 0) + 1;
                            });
                            
                            const topVenues = Object.entries(venueCounts)
                                .sort(([,a], [,b]) => b - a)
                                .slice(0, 5)
                                .map(([venue, count]) => `${venue} (${count} visits)`);
                            
                            return `Top venues in the network:\n${topVenues.map(venue => `â€¢ ${venue}`).join('\n')}`;
                        } else {
                            return 'I have venue data but most locations are showing as coordinates rather than venue names.';
                        }
                    }
                }
                
                // LinkedIn queries using enriched data
                if (lowerMessage.includes('linkedin') || lowerMessage.includes('work') || lowerMessage.includes('job') || lowerMessage.includes('profession')) {
                    if (enrichedData && enrichedData.userProfiles) {
                        const usersWithLinkedIn = enrichedData.userProfiles.filter(user => 
                            user.social_urls?.linkedin
                        );
                        
                        if (usersWithLinkedIn.length > 0) {
                            const userList = usersWithLinkedIn
                                .slice(0, 10)
                                .map(user => `â€¢ ${user.basic_info?.first_name || 'Unknown'} ${user.basic_info?.last_name || ''} (@${user.basic_info?.username || 'unknown'})`)
                                .join('\n');
                            
                            return `Users with LinkedIn profiles:\n${userList}\n\nTotal: ${usersWithLinkedIn.length} users have LinkedIn profiles.`;
                        } else {
                            return 'No LinkedIn profiles found in the enriched data.';
                        }
                    }
                }
                
                // Vanderbilt queries using enriched data
                if (lowerMessage.includes('vanderbilt')) {
                    if (enrichedData && enrichedData.comprehensive && enrichedData.comprehensive.tap_data) {
                        const vanderbiltUsers = enrichedData.comprehensive.tap_data
                            .filter(tap => 
                                tap.user1_bio?.includes('Vanderbilt') || 
                                tap.user2_bio?.includes('Vanderbilt')
                            )
                            .map(tap => [tap.user1_name, tap.user2_name])
                            .flat()
                            .filter((name, index, arr) => arr.indexOf(name) === index)
                            .filter(Boolean);
                        
                        if (vanderbiltUsers.length > 0) {
                            return `Vanderbilt alumni/affiliates in the network:\n${vanderbiltUsers.map(name => `â€¢ ${name}`).join('\n')}`;
                        } else {
                            return 'No Vanderbilt alumni found in the enriched data.';
                        }
                    }
                }
                
                // Default response
                return `I can help you explore the network! Try asking about:\nâ€¢ "Who are the most connected people?"\nâ€¢ "Show me the most active users"\nâ€¢ "Find users in tech"\nâ€¢ "Network statistics"\nâ€¢ "Show me users in Nashville" or other cities\nâ€¢ "What are the most popular locations?"\nâ€¢ "What are the top venues?"\nâ€¢ "Who has LinkedIn profiles?"\nâ€¢ "Who went to Vanderbilt?"\nâ€¢ Or ask about a specific person like "Who is Grace Brown?"`;
            }
            
            function createSystemPrompt(networkContext) {
                // Extract key information from network context
                const users = networkContext.users || {};
                const connections = networkContext.connections || {};
                const networkStats = networkContext.network_stats || {};
                const geographicStats = networkContext.geographic_stats || {};
                
                const userCount = Object.keys(users).length;
                const connectionCount = Object.keys(connections).length;
                
                // Create user summaries with location data (limit to first 20 for performance)
                const userSummaries = [];
                Object.entries(users).slice(0, 20).forEach(([userId, userData]) => {
                    const name = userData.name || 'Unknown';
                    const username = userData.username || '';
                    const taps = userData.taps || 0;
                    const connections = userData.connections || 0;
                    const activity = userData.activity_level || 'unknown';
                    const location = userData.location || 'Unknown location';
                    
                    // Add LinkedIn data if available
                    let linkedinInfo = "";
                    if (userData.linkedin_data) {
                        const linkedin = userData.linkedin_data;
                        if (linkedin.job_title || linkedin.company) {
                            linkedinInfo = ` (LinkedIn: ${linkedin.job_title || ''} at ${linkedin.company || ''})`;
                        }
                    }
                    
                    userSummaries.push(`- ${name} (@${username}): ${taps} taps, ${connections} connections, ${activity} activity, Location: ${location}${linkedinInfo}`);
                });
                
                // Create location summary
                let locationSummary = "No location data available";
                if (geographicStats.location_distribution) {
                    const topLocations = Object.entries(geographicStats.location_distribution)
                        .sort(([,a], [,b]) => b - a)
                        .slice(0, 5)
                        .map(([location, count]) => `${location}: ${count} users`)
                        .join(', ');
                    locationSummary = `Top locations: ${topLocations}`;
                }
                
                return `You are an AI assistant analyzing a social network visualization. You have access to detailed network data including geographic information and should provide insightful, helpful responses.

NETWORK OVERVIEW:
- Total Users: ${userCount}
- Total Connections: ${connectionCount}
- Most Active User: ${networkStats.most_active_user || 'Unknown'}
- Most Connected User: ${networkStats.most_connected_user || 'Unknown'}
- This is a social network where users "tap" each other to indicate connections

GEOGRAPHIC DATA:
- Total Locations: ${geographicStats.total_locations || 0}
- Most Popular Location: ${geographicStats.most_popular_location || 'Unknown'}
- Users with Location Data: ${geographicStats.users_with_location || 0}
- ${locationSummary}

USER DATA (with locations):
${userSummaries.length > 0 ? userSummaries.join('\n') : 'No user data available'}

CAPABILITIES:
- Analyze network patterns and relationships
- Find users with specific characteristics or locations
- Identify most connected or active users
- Analyze geographic patterns and venue preferences
- Provide insights about professional networks
- Answer questions about connection strength and frequency
- Find users in specific cities or regions
- Analyze location-based network patterns

RESPONSE GUIDELINES:
- Be conversational and helpful
- Provide specific insights based on the data
- Use the actual numbers and names from the network
- Include location information when relevant
- Suggest ways to explore the network further
- Keep responses concise but informative
- If asked about specific users, use their real names and data
- If asked about locations, provide specific city/region information

Remember: You're helping someone explore and understand their social network data. You have access to geographic information and can provide location-based insights. Be insightful and actionable in your responses.`;
            }
            

            
            // Enriched data is now loaded via the main loadData() function
            
            function prepareNetworkContext() {
                // Extract and format network data for AI context
                const context = {
                    users: {},
                    connections: {},
                    venues: {},
                    network_stats: {},
                    enriched_data: enrichedData
                };
                
                // Location data from user_location_data.csv
                const locationData = {
                    "005901c3-d70f-448b-af3a-89200f439a8b": { latitude: 43.61381100305985, longitude: -110.75725805361886, location: "Wilson, WY, USA", tap_count: 5 },
                    "057ef55d-b331-4d29-ba28-ab0c2e0c1ad6": { latitude: 36.163860832585044, longitude: -86.85530122293824, location: "Nashville, TN, USA", tap_count: 1 },
                    "08b5447f-b067-45de-baed-7ba8d5801d30": { latitude: 32.82029153373651, longitude: -96.80214528345363, location: "Highland Park, TX, USA", tap_count: 1 },
                    "0a956088-273e-4c4d-a7cf-d7740e00e51b": { latitude: 33.003756422953764, longitude: -96.96777262839781, location: "Lewisville, TX, USA", tap_count: 1 },
                    "0c975039-ab0b-429b-b666-a41f3f0f0d7e": { latitude: 36.17166166936852, longitude: -86.67063156363542, location: "Mount Juliet, TN, USA", tap_count: 2 },
                    "0d24c2ee-656c-4da3-a69a-d7e36f7286ff": { latitude: 36.14410681603657, longitude: -86.81859068607262, location: "Nashville, TN, USA", tap_count: 1 },
                    "0f3832b9-ea51-4382-903b-8297ed2d5d6d": { latitude: 36.123527744390444, longitude: -86.7898057011387, location: "Nashville, TN, USA", tap_count: 2 },
                    "0f40737c-e6c3-4f7c-ad63-12b3c2dd150d": { latitude: 37.747494587719494, longitude: -122.41262371615215, location: "San Francisco, CA, USA", tap_count: 9 },
                    "0f71f437-9883-4419-bbb4-13ec022f9b82": { latitude: 32.816193818359665, longitude: -96.78624206107935, location: "Dallas, TX, USA", tap_count: 1 },
                    "1262b5b8-e50f-4820-b25f-4a6f76d60455": { latitude: 39.97410127627642, longitude: -87.35396339359143, location: "Chicago, IL, USA", tap_count: 3 },
                    "1451ff42-aa87-4177-ad8f-2d370e97a022": { latitude: 37.87414957002211, longitude: -122.27278811564372, location: "Berkeley, CA, United States", tap_count: 1 },
                    "173df5d0-8946-4f17-b5fe-15333c6e86a1": { latitude: 36.24387658016277, longitude: -91.30769324927165, location: "Nashville, TN, USA", tap_count: 31 },
                    "19a6e4bd-90ab-4d4d-a6bb-99271e830a91": { latitude: 32.83596052570658, longitude: -96.80139825998853, location: "Highland Park, TX, USA", tap_count: 1 },
                    "1f6c0f64-ee2a-4377-bd58-518c3ea6cbee": { latitude: 36.08315779117366, longitude: -86.7933102226139, location: "Oak Hill, TN, USA", tap_count: 1 },
                    "202887d9-3791-4764-8091-738b04e50687": { latitude: 32.82208416277913, longitude: -96.78601901311306, location: "Dallas, TX, USA", tap_count: 2 },
                    "22762e44-4c15-4a23-adb9-fbca2ef60aa4": { latitude: 37.75827546807477, longitude: -122.42736589869583, location: "San Francisco, CA, USA", tap_count: 1 },
                    "24450c5e-01af-487d-b120-b094f4f69718": { latitude: 38.27605671242922, longitude: -105.5798738738367, location: "Sun Valley, ID, USA", tap_count: 2 },
                    "26a3381d-a045-49fe-a366-e2be256a781c": { latitude: 43.42429153315908, longitude: -110.27229141369695, location: "Moran, WY, USA", tap_count: 16 },
                    "2812c73f-9518-472a-948a-4ce7b93c122f": { latitude: 37.77337215682331, longitude: -122.3915779957805, location: "San Francisco, CA, USA", tap_count: 1 },
                    "2a227da2-b09a-402f-81e8-1976633cf682": { latitude: 34.767329985643805, longitude: -92.73545927806182, location: "Nashville, TN, USA", tap_count: 102 },
                    "2af69190-c453-490b-b967-2a8d1526fdad": { latitude: 32.81616518852288, longitude: -96.78613198548942, location: "Dallas, TX, USA", tap_count: 3 },
                    "2bd4b6e6-dbbe-4569-ad2a-5b15ef62b8a8": { latitude: 32.85039207678701, longitude: -96.79547644530865, location: "University Park, TX, USA", tap_count: 1 },
                    "2e14c255-2df1-4bdb-a2bd-ab9d3f953fa0": { latitude: 36.16694500533066, longitude: -86.79029539347732, location: "Nashville, TN, USA", tap_count: 4 },
                    "32aa8e65-1230-4346-b2bd-193ce2af9a20": { latitude: 37.57806538505652, longitude: -122.34878080398613, location: "Burlingame, CA, USA", tap_count: 1 },
                    "35cb1d40-5eef-4362-a8e8-b1dbff0f9420": { latitude: 40.424709157629316, longitude: -101.63028804342052, location: "Cody, WY, USA", tap_count: 11 },
                    "370265f5-da4e-427e-8c53-bd814b7c24ad": { latitude: 32.80779049780091, longitude: -96.79666832526216, location: "Dallas, TX, USA", tap_count: 2 },
                    "378e5cf5-6c0f-4757-b81b-ade8bc5ef31f": { latitude: 37.874142246967665, longitude: -122.27277356135669, location: "Berkeley, CA, United States", tap_count: 1 },
                    "38e5fd2b-1350-47a0-9c68-fe66adca3f03": { latitude: 36.14176657386851, longitude: -86.83411574113249, location: "Nashville, TN, USA", tap_count: 1 },
                    "3925f0c5-e878-456e-ac21-0a4b3ee4eaf1": { latitude: 36.163819237588925, longitude: -86.85523600039481, location: "Nashville, TN, USA", tap_count: 2 },
                    "39dc61fd-2044-4d77-bb0f-3a8144a56591": { latitude: 36.031066139094904, longitude: -88.24211371145364, location: "Nashville, TN, USA", tap_count: 22 },
                    "3a2cc7a9-d0c0-42e6-9d01-2cd3344d871d": { latitude: 37.76571944337667, longitude: -122.45002231448794, location: "San Francisco, CA, USA", tap_count: 2 },
                    "3f4b4c26-4490-4067-b34e-2c30bced4eea": { latitude: 32.849130485197, longitude: -96.79152868448713, location: "University Park, TX, USA", tap_count: 2 },
                    "489c0f48-df7e-46db-8069-16850fa05675": { latitude: 36.158322985967196, longitude: -86.77790212451657, location: "Nashville, TN, USA", tap_count: 6 },
                    "48d0eb1c-068d-4354-a2c7-b03f8af94913": { latitude: 37.80033010300227, longitude: -122.43333807469133, location: "San Francisco, CA, USA", tap_count: 1 },
                    "49ea4c7b-e11e-4c44-9439-997d5e1cde8c": { latitude: 32.779182197537054, longitude: -96.82842569203932, location: "Dallas, TX, USA", tap_count: 1 },
                    "5090ad7b-ff8b-45f6-b491-057598ec0992": { latitude: 32.8504033374464, longitude: -96.79550201839976, location: "University Park, TX, USA", tap_count: 1 },
                    "56cd8a6f-ad4a-4fdd-bff5-c91e55fba405": { latitude: 43.70560031498506, longitude: -114.3465039389628, location: "Sun Valley, ID, USA", tap_count: 1 },
                    "637d8fe0-6d62-4b12-ac1a-8d27fe0fa997": { latitude: 35.930956079410294, longitude: -86.85863555416073, location: "Franklin, TN, USA", tap_count: 1 },
                    "64615a44-e1f4-4416-bbd2-499725379a13": { latitude: 40.72224047976142, longitude: -73.98821817944142, location: "New York, NY, USA", tap_count: 1 },
                    "65976b67-8e89-4d98-9f40-91e6c549a104": { latitude: 36.150544385219305, longitude: -86.80247236689353, location: "Nashville, TN, USA", tap_count: 2 },
                    "65b43857-be79-48bc-be92-0bee2cf7b9c0": { latitude: 37.578020719975825, longitude: -122.34845002734029, location: "Burlingame, CA, USA", tap_count: 1 },
                    "66693391-e0e0-4cff-92db-4ff52ecc6b0b": { latitude: 32.86010665155925, longitude: -96.76317217628444, location: "Dallas, TX, USA", tap_count: 1 },
                    "6aad2435-39bc-4694-ab63-07400958de68": { latitude: 43.63699978572629, longitude: -110.73388743154847, location: "Moran, WY, USA", tap_count: 3 },
                    "6df79895-d1e0-4d2f-985e-84e7349cd05d": { latitude: 36.154735312560355, longitude: -86.7950593264195, location: "Nashville, TN, USA", tap_count: 3 },
                    "721e8155-462a-476a-908f-74dba9841055": { latitude: 30.340045365547418, longitude: -86.20539722201681, location: "Santa Rosa Beach, FL, USA", tap_count: 1 },
                    "747eaab9-6dcc-476f-bacc-6a7be12236f1": { latitude: 34.03362477136547, longitude: -118.44841620681677, location: "Los Angeles, CA, USA", tap_count: 1 },
                    "782bbea7-3cdf-4214-a14e-8a860c359b3c": { latitude: 32.8009722685141, longitude: -96.80772766641132, location: "Dallas, TX, USA", tap_count: 1 },
                    "83f814ef-9820-4edd-ac9c-5e802a1587a7": { latitude: 32.84484784458248, longitude: -96.79215041790032, location: "University Park, TX, USA", tap_count: 4 },
                    "856d5d58-3e7e-4d56-be60-1245f97cd9fd": { latitude: 37.80630567975904, longitude: -122.43214847968127, location: "San Francisco, CA, USA", tap_count: 2 },
                    "85ed08f1-86d4-4329-a3a2-ea719805671f": { latitude: 30.917694035279858, longitude: -89.07931410559283, location: "Inlet Beach, FL, USA", tap_count: 7 },
                    "86879f8b-1d52-4533-881b-e5712e786e66": { latitude: 36.1441456120628, longitude: -86.81869683271316, location: "Nashville, TN, USA", tap_count: 4 },
                    "87db25c8-a8a4-475b-a8a8-3a369732641a": { latitude: 32.871132716205075, longitude: -96.85746877908537, location: "Dallas, TX, USA", tap_count: 3 },
                    "8c083831-8bb7-4506-9c15-76f4f27ad234": { latitude: 43.611094941123575, longitude: -110.71589797456942, location: "Jackson, WY, USA", tap_count: 3 },
                    "8dd7c60d-f694-4ded-9873-de5bf9f32735": { latitude: 36.619168067922466, longitude: -98.52263780332002, location: "College Grove, TN, USA", tap_count: 3 },
                    "9138cd77-4a3f-4bfe-9633-4ec9febd0df0": { latitude: 38.2260876543964, longitude: -93.38106372175872, location: "Nashville, TN, USA", tap_count: 18 },
                    "92fb1f76-c522-4985-98bb-c30351faa0c6": { latitude: 40.73936829432591, longitude: -74.0056049031946, location: "New York, NY, USA", tap_count: 1 },
                    "938657e3-1c26-4b57-89f2-bf8b4b3695f6": { latitude: 33.101809297408536, longitude: -95.78970715634813, location: "Dallas, TX, USA", tap_count: 9 },
                    "9d969458-d596-4d34-a677-8a9fc84f5bb9": { latitude: 41.884140028575786, longitude: -87.63754764149176, location: "Chicago, IL, USA", tap_count: 1 },
                    "9e7a3f8a-ce87-413c-a549-ea1e7f575314": { latitude: 44.27711803849178, longitude: -109.51470266093051, location: "Cody, WY, USA", tap_count: 1 },
                    "a3651bc8-8be5-4d00-9d29-0c6dc0adb042": { latitude: 34.03358806816425, longitude: -118.44840009496565, location: "Los Angeles, CA, USA", tap_count: 1 },
                    "a6fbbb2e-8f43-4643-8bda-2eeed3160810": { latitude: 35.965747454039935, longitude: -86.81946109902735, location: "Brentwood, TN, USA", tap_count: 3 },
                    "a815e693-e351-406f-a7e0-7ef73039dd4e": { latitude: 33.01237727942804, longitude: -95.48089007135243, location: "Dallas, TX, USA", tap_count: 29 },
                    "a965d513-66e9-40ee-a4a7-0c256258683c": { latitude: 36.14750712066675, longitude: -86.80942534712561, location: "Nashville, TN, USA", tap_count: 3 },
                    "aa19fab9-4254-4b8b-98e0-484f93478e15": { latitude: 32.217210575145074, longitude: -94.13217532742513, location: "Dallas, TX, USA", tap_count: 4 },
                    "ab03d946-2c2f-41ca-ab9d-2ba07a9a7779": { latitude: 36.12006944437514, longitude: -86.92011952174238, location: "Nashville, TN, USA", tap_count: 1 },
                    "abe35f8e-14ec-41e9-b2c5-44536aca3725": { latitude: 37.92312891416532, longitude: -122.50327606248742, location: "Corte Madera, CA, USA", tap_count: 1 },
                    "ad432f6b-46e8-4e6f-89a0-0085bed67fbe": { latitude: 36.15648480486106, longitude: -86.83146757332216, location: "Nashville, TN, USA", tap_count: 2 },
                    "afc82f4e-2958-4040-b50b-d769a5075eed": { latitude: 36.154800251113144, longitude: -86.78933293480931, location: "Nashville, TN, USA", tap_count: 5 },
                    "b1e0411f-99c8-46d7-a884-e0213cfd99cd": { latitude: 30.284341341058603, longitude: -86.02728451948518, location: "Inlet Beach, FL, USA", tap_count: 3 },
                    "b1fb9312-da83-4a2d-97e7-2d4f15c64730": { latitude: 32.84255104423626, longitude: -96.78741680522128, location: "University Park, TX, USA", tap_count: 1 },
                    "b668bf67-dcf4-45f7-9088-0477115244a3": { latitude: 32.83155057263721, longitude: -96.77057276054927, location: "Dallas, TX, USA", tap_count: 1 },
                    "b68de5a1-b4f8-4c68-8bb6-73a754a5e4ca": { latitude: 36.150497593472494, longitude: -86.80274539798295, location: "Nashville, TN, USA", tap_count: 2 },
                    "b880f503-1d5d-48a1-8950-4961233fe76d": { latitude: 36.14466566322875, longitude: -86.79263902907303, location: "Nashville, TN, USA", tap_count: 1 },
                    "ba5d7fd2-c224-4baa-b696-84ebb36ccdd1": { latitude: 36.14591240352853, longitude: -86.81275163232154, location: "Nashville, TN, USA", tap_count: 1 },
                    "bcbb2fc8-8d9f-4e50-bb5a-1738064e3051": { latitude: 30.284345312073622, longitude: -86.02727449274715, location: "Inlet Beach, FL, USA", tap_count: 1 },
                    "bdc83ccd-d213-425a-82cd-edc42738052a": { latitude: 32.82350085407573, longitude: -96.79009812359901, location: "Dallas, TX, USA", tap_count: 2 },
                    "be7c916c-ab56-46c1-8ea9-20f247eca280": { latitude: 32.776502131825296, longitude: -96.807396107062, location: "Dallas, TX, USA", tap_count: 1 },
                    "bf41bdc7-86a3-46f8-a4f3-0cd561b1ace9": { latitude: 36.16526951573829, longitude: -86.79064991572784, location: "Nashville, TN, USA", tap_count: 1 },
                    "bffc2615-bfb7-432f-84ae-a64e8e873a0b": { latitude: 36.14897819834411, longitude: -86.79685450731509, location: "Nashville, TN, USA", tap_count: 5 },
                    "c09cd6c7-415a-4213-9a65-79a4ac685590": { latitude: 32.3271857241399, longitude: -96.62894086083224, location: "Ennis, TX, USA", tap_count: 1 },
                    "c68dd02c-b154-4a35-8442-9124034e5013": { latitude: 36.150311220090806, longitude: -86.80179632647611, location: "Nashville, TN, USA", tap_count: 1 },
                    "cc8177a0-ae9f-44cd-b2a8-7424de63a660": { latitude: 37.79728435023365, longitude: -122.43353752902182, location: "San Francisco, CA, USA", tap_count: 1 },
                    "cde79e0d-3158-46a5-9eb3-58875e351eb0": { latitude: 38.35022769582662, longitude: -103.72613585989924, location: "Dallas, TX, USA", tap_count: 2 },
                    "ceef39e9-0611-44f7-a851-bd8da142bbfd": { latitude: 36.148010228481624, longitude: -86.80788426055418, location: "Nashville, TN, USA", tap_count: 1 },
                    "d0a16b9d-006a-478a-9abf-8adb80e4fa33": { latitude: 32.35744293683801, longitude: -97.02400112796711, location: "Dallas, TX, USA", tap_count: 7 },
                    "d1f027a0-3aa6-43ef-9677-40e3d8537afe": { latitude: 43.87613063490547, longitude: -110.13868588828981, location: "Cody, WY, USA", tap_count: 4 },
                    "d2514e5c-1eca-4a6e-b990-aa451cd4dbc4": { latitude: 32.81151773897802, longitude: -96.78665941168344, location: "Dallas, TX, USA", tap_count: 1 },
                    "d42a24bb-c6ab-4ff6-9098-4f4d4c2d55b6": { latitude: 43.50309171181045, longitude: -110.87019403561362, location: "Wilson, WY, USA", tap_count: 1 },
                    "d4e8ffc8-e3fe-4af9-b917-42531872fbc4": { latitude: 36.15011722573375, longitude: -86.8211529311487, location: "Nashville, TN, USA", tap_count: 1 },
                    "d76a880e-8f71-4d11-bf0e-eff634bf8348": { latitude: 32.073970894802414, longitude: -96.44439662272626, location: "Corsicana, TX, USA", tap_count: 1 },
                    "dc89bceb-4d2f-467f-a58d-e884c32b974f": { latitude: 43.50312365777772, longitude: -110.87021370176015, location: "Wilson, WY, USA", tap_count: 4 },
                    "e17ddec3-8fae-4fbf-8d18-c4b91b18ced6": { latitude: 32.84911385340805, longitude: -96.7915450615807, location: "University Park, TX, USA", tap_count: 2 },
                    "e2ebef06-c46b-467f-a5b6-8e4bc9b545f4": { latitude: 36.16381086184526, longitude: -86.85522945909622, location: "Nashville, TN, USA", tap_count: 1 },
                    "e348fd37-171f-4034-bde6-2beb363404ee": { latitude: 37.79181079922887, longitude: -122.4025529264647, location: "San Francisco, CA, USA", tap_count: 1 },
                    "f0c336dd-60a7-4f47-834f-f1749d3b10c0": { latitude: 30.28430515287834, longitude: -86.0272424953753, location: "Inlet Beach, FL, USA", tap_count: 1 },
                    "f1d8f71b-520b-4f06-a159-9ade69cd9ca3": { latitude: 37.45772933959961, longitude: -121.9051399230957, location: "Milpitas, CA, USA", tap_count: 1 },
                    "f2c81df7-a6cc-4223-a0c1-9a71a8858a33": { latitude: 32.792171860899344, longitude: -96.80327496704611, location: "Dallas, TX, USA", tap_count: 1 },
                    "f7db0c45-fb6f-4ddc-9b72-eb615bc41634": { latitude: 40.563935942896876, longitude: -101.6091006511886, location: "Atlanta, GA, USA", tap_count: 3 },
                    "fa4a2987-3c22-4ca6-bbf7-49488409117f": { latitude: 36.16379349311657, longitude: -86.85522550491646, location: "Nashville, TN, USA", tap_count: 1 }
                };
                
                // Add user data with enriched information
                if (allNodes) {
                    Object.keys(allNodes).forEach(nodeId => {
                        const node = allNodes[nodeId];
                        const userLocation = locationData[nodeId];
                        
                        context.users[nodeId] = {
                            name: node.label || 'Unknown',
                            username: node.username || '',
                            taps: node.taps || 0,
                            connections: node.connections || 0,
                            activity_level: node.activity_level || 'unknown',
                            linkedin_data: node.linkedin_data || {},
                            profile_data: node.profile_data || {},
                            // Include location data from enriched dataset
                            location: userLocation ? userLocation.location : null,
                            latitude: userLocation ? userLocation.latitude : null,
                            longitude: userLocation ? userLocation.longitude : null,
                            location_tap_count: userLocation ? userLocation.tap_count : 0,
                            // Include any other enriched data fields
                            company: node.company || null,
                            job_title: node.job_title || null
                        };
                    });
                }
                
                // Add connection data
                if (allEdges) {
                    Object.keys(allEdges).forEach(edgeId => {
                        const edge = allEdges[edgeId];
                        context.connections[edgeId] = {
                            source: edge.source_name || 'Unknown',
                            target: edge.target_name || 'Unknown',
                            tap_count: edge.tap_count || 1,
                            timestamp: edge.timestamp || null,
                            location: edge.location || null
                        };
                    });
                }
                
                // Add network statistics
                context.network_stats = {
                    total_users: Object.keys(context.users).length,
                    total_connections: Object.keys(context.connections).length,
                    most_active_user: findMostActiveUser(context.users),
                    most_connected_user: findMostConnectedUser(context.users)
                };
                
                // Add geographic analysis
                const locations = Object.values(context.users).filter(user => user.location);
                const locationCounts = {};
                locations.forEach(user => {
                    locationCounts[user.location] = (locationCounts[user.location] || 0) + 1;
                });
                
                context.geographic_stats = {
                    total_locations: Object.keys(locationCounts).length,
                    most_popular_location: Object.keys(locationCounts).reduce((a, b) => locationCounts[a] > locationCounts[b] ? a : b, ''),
                    location_distribution: locationCounts,
                    users_with_location: locations.length
                };
                
                console.log('Network context prepared:', {
                    userCount: Object.keys(context.users).length,
                    connectionCount: Object.keys(context.connections).length,
                    sampleUser: Object.values(context.users)[0],
                    sampleUserKeys: Object.keys(Object.values(context.users)[0] || {}),
                    hasProfileData: Object.values(context.users).some(user => user.profile_data && Object.keys(user.profile_data).length > 0),
                    hasLinkedInData: Object.values(context.users).some(user => user.linkedin_data && Object.keys(user.linkedin_data).length > 0)
                });
                
                return context;
            }
            
            function findMostActiveUser(users) {
                let mostActive = null;
                let maxTaps = 0;
                
                Object.values(users).forEach(user => {
                    if (user.taps > maxTaps) {
                        maxTaps = user.taps;
                        mostActive = user.name;
                    }
                });
                
                return mostActive;
            }
            
            function findMostConnectedUser(users) {
                let mostConnected = null;
                let maxConnections = 0;
                
                Object.values(users).forEach(user => {
                    if (user.connections > maxConnections) {
                        maxConnections = user.connections;
                        mostConnected = user.name;
                    }
                });
                
                return mostConnected;
            }
            
            function updateLoadingState(loading) {
                const sendButton = document.getElementById('sendButton');
                const chatInput = document.getElementById('chatInput');
                
                if (loading) {
                    sendButton.textContent = 'â³';
                    sendButton.disabled = true;
                    chatInput.disabled = true;
                } else {
                    sendButton.textContent = 'â†’';
                    sendButton.disabled = false;
                    chatInput.disabled = false;
                }
            }
            
            
            // Initialize the network
            async function initNetwork() {
                console.log('ðŸš€ initNetwork() called - starting network initialization');
                const container = document.getElementById('mynetwork');
                
                // Load data first
                try {
                    await loadData();
                } catch (error) {
                    console.error('Failed to load data:', error);
                    return;
                }
                
                // Create datasets (data is now loaded)
                // nodes and edges are already created by createNetworkData()
                
                // Store references
                allNodes = nodes.get({ returnType: "Object" });
                allEdges = edges.get({ returnType: "Object" }); // Updated with new data
                
                // Store the total number of edges for consistent reference
                totalEdgesInDataset = edges.length;
                
                // Debug: Check the actual total edges
                
                // Update header and loading stats with dynamic counts
                const totalUsers = searchIndex.length; // Use searchIndex to include ALL users, even those with zero connections
                const totalConnections = totalEdgesInDataset;
                const headerStatsElement = document.getElementById('headerStats');
                const loadingStatsElement = document.getElementById('loadingStats');
                
                if (loadingStatsElement) {
                    loadingStatsElement.textContent = `Initializing ${totalUsers} users and ${totalConnections} connections...`;
                }
                
                // Hide all nodes and edges initially (blank state until user is selected)
                nodes.forEach(node => {
                    nodes.update({id: node.id, hidden: true});
                });
                
                edges.forEach(edge => {
                    edges.update({id: edge.id, hidden: true});
                });
                
                // Network options
                const options = {
                    physics: {
                        enabled: true,
                        solver: 'forceAtlas2Based',
                        forceAtlas2Based: {
                            gravitationalConstant: -100, // Reduced from -150 to decrease rotation
                            centralGravity: 0.005,
                            springLength: 250, // Longer springs = more spacing
                            springConstant: 0.1,
                            damping: 0.9, // Increased damping for smoother movement
                            avoidOverlap: 1.2 // Higher overlap avoidance = more spacing
                        },
                        maxVelocity: 8, // Reduced max velocity for smoother movement
                        minVelocity: 0.05, // Reduced min velocity for smoother movement
                        timestep: 0.3, // Reduced timestep for smoother physics
                        stabilization: {
                            enabled: true,
                            iterations: 200,
                            updateInterval: 25, // Faster updates for smoother animation
                            onlyDynamicEdges: false,
                            fit: false
                        }
                    },
                    nodes: {
                        font: { size: 14.4, face: 'Arial' },
                        color: { background: '#ffffff', border: '#ffffff', highlight: { background: '#ffffff', border: '#ffffff' } },
                        borderWidth: 1,
                        borderWidthSelected: 2,
                        shadow: false
                    },
                    edges: {
                        smooth: { type: 'continuous', forceDirection: 'none' },
                        shadow: false,
                        color: { 
                            inherit: false,
                            highlight: '#03DAEE',
                            hover: '#03DAEE'
                        }
                    },
                    interaction: {
                        hover: true,
                        navigationButtons: false,
                        keyboard: { enabled: true },
                        multiselect: false,
                        selectable: true,
                        selectConnectedEdges: true,
                        tooltipDelay: 200,
                        zoomView: true,
                        dragView: true,
                        zoomSpeed: 0.2          // 2x faster than previous 0.105
                    },
                    layout: {
                        improvedLayout: false,
                        hierarchical: { enabled: false }
                    },
                    manipulation: { enabled: false }
                };
                
                // Create network
                console.log('ðŸŒ Creating vis.Network instance...');
                
                // Debug: Check container dimensions
                const containerRect = container.getBoundingClientRect();
                console.log('ðŸ“ Container dimensions:', containerRect.width, 'x', containerRect.height);
                
                // Check if container has proper dimensions
                if (containerRect.width === 0 || containerRect.height === 0) {
                    console.log('âš ï¸ Container has zero dimensions - waiting for proper sizing...');
                    
                    // Wait for container to get proper dimensions
                    const waitForDimensions = () => {
                        return new Promise((resolve) => {
                            let attempts = 0;
                            const maxAttempts = 20; // 20 attempts * 50ms = 1 second max wait
                            
                            const checkDimensions = () => {
                                const rect = container.getBoundingClientRect();
                                console.log('ðŸ“ Checking dimensions:', rect.width, 'x', rect.height);
                                
                                if (rect.width > 0 && rect.height > 0) {
                                    console.log('âœ… Container now has proper dimensions');
                                    resolve();
                                } else if (attempts >= maxAttempts) {
                                    console.log('âš ï¸ Max attempts reached - proceeding with zero dimensions');
                                    resolve();
                                } else {
                                    attempts++;
                                    // Wait a bit more and try again
                                    setTimeout(checkDimensions, 50);
                                }
                            };
                            checkDimensions();
                        });
                    };
                    
                    await waitForDimensions();
                }
                
                network = new vis.Network(container, { nodes: nodes, edges: edges }, options);
                console.log('âœ… vis.Network created successfully');
                
                // Debug: Check edge visibility after network creation
                console.log('ðŸ” Debug: Checking edge visibility after network creation...');
                const allEdgesData = edges.get();
                const visibleEdges = allEdgesData.filter(edge => !edge.hidden);
                const hiddenEdges = allEdgesData.filter(edge => edge.hidden);
                console.log(`ðŸ” Total edges: ${allEdgesData.length}, Visible: ${visibleEdges.length}, Hidden: ${hiddenEdges.length}`);
                
                // Force network to redraw after a short delay to ensure proper rendering
                setTimeout(() => {
                    if (network) {
                        console.log('ðŸ”„ Forcing network redraw to ensure proper rendering...');
                        network.redraw();
                        
                        // Debug: Check edge visibility after redraw
                        console.log('ðŸ” Debug: Checking edge visibility after redraw...');
                        const allEdgesAfter = edges.get();
                        const visibleEdgesAfter = allEdgesAfter.filter(edge => !edge.hidden);
                        console.log(`ðŸ” After redraw - Total edges: ${allEdgesAfter.length}, Visible: ${visibleEdgesAfter.length}`);
                        
                        // If no edges are visible, force them to be visible
                        if (visibleEdgesAfter.length === 0 && allEdgesAfter.length > 0) {
                            console.log('ðŸ”§ No edges visible - forcing all edges to be visible...');
                            const edgeUpdates = allEdgesAfter.map(edge => ({
                                id: edge.id,
                                hidden: false
                            }));
                            edges.update(edgeUpdates);
                            console.log('ðŸ”§ All edges forced to visible');
                        }
                    }
                }, 100);
                
                
                // Force white text for all nodes after network creation
                setTimeout(() => {
                    // Update all nodes with white font
                    const allNodesData = nodes.get();
                    allNodesData.forEach(node => {
                        nodes.update({
                            id: node.id,
                            font: { size: 14.4, face: 'Arial', color: '#ffffff' }
                        });
                    });
                    
                    // Also try to force it via CSS after a delay
                    setTimeout(() => {
                        const style = document.createElement('style');
                        style.textContent = `
                            .vis-network .vis-node text { fill: #ffffff !important; }
                            .vis-network .vis-node .vis-label { color: #ffffff !important; fill: #ffffff !important; }
                            .vis-network svg text { fill: #ffffff !important; }
                        `;
                        document.head.appendChild(style);
                    }, 1000);
                }, 500);
                
                // Event listeners
                network.on('click', function(params) {
                    // Skip node selection in global mode - allow graph interaction but no user selection
                    if (globalViewEnabled) {
                        return; // Allow graph dragging/zooming but prevent user selection
                    }
                    
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        selectNodeById(nodeId);
                    } else if (params.edges.length > 0) {
                        const edgeId = params.edges[0];
                        // Edge click functionality removed - no popup needed
                    }
                });
                
                network.on('stabilizationProgress', function(params) {
                    const progress = Math.round((params.iterations / params.total) * 100);
                    document.getElementById('loadingContainer').querySelector('p').textContent = 
                        `Stabilizing network... ${progress}%`;
                });
                
                network.once('stabilizationIterationsDone', function() {
                    setTimeout(() => {
                        document.getElementById('loadingContainer').style.display = 'none';
                        
                        // Set a more zoomed-out view for better overview
                        network.fit({
                            animation: {
                                duration: 1000,
                                easingFunction: 'easeInOutQuad'
                            }
                        });
                        
                        // Further zoom out by 30% for better overview
                        setTimeout(() => {
                            const currentScale = network.getScale();
                            network.moveTo({
                                scale: currentScale * 0.7, // Zoom out by 30%
                                animation: {
                                    duration: 800,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        }, 1200);
                        
                        // CRITICAL: Re-apply timeline update after stabilization to ensure edges are visible
                        setTimeout(() => {
                            console.log('ðŸ”§ Stabilization complete - re-applying timeline update to ensure edge visibility...');
                            // Re-trigger the timeline update to ensure edges are visible after stabilization
                            const leftSlider = document.getElementById('timelineSliderLeft');
                            const rightSlider = document.getElementById('timelineSliderRight');
                            if (leftSlider && rightSlider) {
                                const leftValue = parseInt(leftSlider.value);
                                const rightValue = parseInt(rightSlider.value);
                                console.log(`ðŸ”§ Re-applying timeline: ${leftValue}% - ${rightValue}%`);
                                updateDualTimelineDisplay(leftValue, rightValue);
                            }
                        }, 2000); // Wait for all animations to complete
                        
                    }, 500);
                    
                    // Force white text for all node labels
                    setTimeout(() => {
                        const nodeLabels = document.querySelectorAll('.vis-network .vis-node text');
                        nodeLabels.forEach(label => {
                            label.style.fill = '#ffffff';
                            label.style.color = '#ffffff';
                        });
                    }, 1000);
                    
                    // Add edge highlighting functionality
                    setTimeout(() => {
                        addEdgeHighlighting();
                    }, 1500);
                });
            }
            
            // Edge highlighting functionality
            function addEdgeHighlighting() {
                // Add event listeners for edge highlighting
                network.on('hoverNode', function(params) {
                    if (params.node) {
                        // Clear any previous hovered edges first
                        restoreEdgeColors(true);
                        highlightConnectedEdges(params.node, false);
                    }
                });
                
                network.on('blurNode', function(params) {
                    // Always restore hovered edges when mouse leaves
                    restoreEdgeColors(true);
                });
                
                network.on('selectNode', function(params) {
                    if (params.nodes.length > 0) {
                        const nodeId = params.nodes[0];
                        // Clear any hovered edges first, then highlight selected node
                        restoreEdgeColors(true);
                        
                        // Add delay to ensure highlighting happens after timeline updates
                        setTimeout(() => {
                            highlightConnectedEdges(nodeId, true);
                        }, 100);
                    }
                });
                
                network.on('deselectNode', function(params) {
                    // Only restore when explicitly deselecting
                    restoreEdgeColors();
                });
                
                // Handle clicking on empty space to clear selection
                network.on('click', function(params) {
                    if (params.nodes.length === 0 && params.edges.length === 0) {
                        // Clicked on empty space - clear highlighting
                        restoreEdgeColors();
                    }
                });
            }
            
            let originalEdgeColors = new Map();
            let currentlyHighlightedEdges = new Set();
            let selectedNodeEdges = new Set(); // Track edges belonging to selected node
            let hoveredNodeEdges = new Set(); // Track edges belonging to currently hovered node
            let pathHighlightedEdges = new Set(); // Track edges in highlighted path
            let currentPath = []; // Track current path between users
            
            function highlightConnectedEdges(nodeId, isSelection = false) {
                const connectedEdges = edges.get().filter(edge => 
                    edge.from === nodeId || edge.to === nodeId
                );
                
                connectedEdges.forEach(edge => {
                    if (!originalEdgeColors.has(edge.id)) {
                        originalEdgeColors.set(edge.id, edge.color);
                    }
                    
                    if (!currentlyHighlightedEdges.has(edge.id)) {
                        edges.update({
                            id: edge.id,
                            color: '#03DAEE'
                        });
                        currentlyHighlightedEdges.add(edge.id);
                    }
                    
                    // Track which edges belong to selection vs hover
                    if (isSelection) {
                        selectedNodeEdges.add(edge.id);
                    } else {
                        hoveredNodeEdges.add(edge.id);
                    }
                });
            }
            
            // Function to re-apply highlighting after timeline updates
            function reapplyHighlighting() {
                if (selectedNodeEdges.size > 0) {
                    // Re-highlight selected node edges
                    selectedNodeEdges.forEach(edgeId => {
                        edges.update({
                            id: edgeId,
                            color: '#03DAEE'
                        });
                    });
                }
            }
            
            function restoreEdgeColors(onlyHovered = false) {
                if (onlyHovered) {
                    // Only restore hovered edges, keep selected node edges
                    hoveredNodeEdges.forEach(edgeId => {
                        const originalColor = originalEdgeColors.get(edgeId);
                        if (originalColor) {
                            edges.update({
                                id: edgeId,
                                color: originalColor
                            });
                        }
                        currentlyHighlightedEdges.delete(edgeId);
                    });
                    hoveredNodeEdges.clear();
                } else {
                    // Restore all edges
                    currentlyHighlightedEdges.forEach(edgeId => {
                        const originalColor = originalEdgeColors.get(edgeId);
                        if (originalColor) {
                            edges.update({
                                id: edgeId,
                                color: originalColor
                            });
                        }
                    });
                    
                    currentlyHighlightedEdges.clear();
                    originalEdgeColors.clear();
                    selectedNodeEdges.clear();
                    hoveredNodeEdges.clear();
                    pathHighlightedEdges.clear();
                    currentPath = [];
                }
            }
            
            // Find shortest path between two users using BFS
            function findPathBetweenUsers(sourceUserId, targetUserId) {
                if (sourceUserId === targetUserId) {
                    return [sourceUserId];
                }
                
                // Create adjacency map from all edges
                const adjacencyMap = {};
                Object.values(allEdges).forEach(edge => {
                    if (!adjacencyMap[edge.from]) adjacencyMap[edge.from] = new Set();
                    if (!adjacencyMap[edge.to]) adjacencyMap[edge.to] = new Set();
                    adjacencyMap[edge.from].add(edge.to);
                    adjacencyMap[edge.to].add(edge.from);
                });
                
                // BFS to find shortest path
                const queue = [[sourceUserId]];
                const visited = new Set([sourceUserId]);
                
                while (queue.length > 0) {
                    const path = queue.shift();
                    const currentNode = path[path.length - 1];
                    
                    if (currentNode === targetUserId) {
                        return path;
                    }
                    
                    const neighbors = adjacencyMap[currentNode] || new Set();
                    neighbors.forEach(neighbor => {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push([...path, neighbor]);
                        }
                    });
                }
                
                return null; // No path found
            }
            
            // Highlight path between current user and target user
            function highlightPathToUser(targetUserId) {
                // Get current user (the one who is logged in/selected)
                const currentUserId = currentFilterUser || selectedNode;
                
                if (!currentUserId) {
                    console.log('No current user selected for path highlighting');
                    return;
                }
                
                // Clear any existing path highlighting
                clearPathHighlighting();
                
                // Find path between users
                const path = findPathBetweenUsers(currentUserId, targetUserId);
                
                if (!path || path.length < 2) {
                    console.log('No path found between users');
                    return;
                }
                
                currentPath = path;
                console.log('Path found:', path.map(id => allNodes[id]?.label || id));
                
                // Highlight edges in the path
                for (let i = 0; i < path.length - 1; i++) {
                    const fromUserId = path[i];
                    const toUserId = path[i + 1];
                    
                    // Find edge between these users
                    const edge = Object.values(allEdges).find(e => 
                        (e.from === fromUserId && e.to === toUserId) ||
                        (e.from === toUserId && e.to === fromUserId)
                    );
                    
                    if (edge) {
                        // Store original color if not already stored
                        if (!originalEdgeColors.has(edge.id)) {
                            originalEdgeColors.set(edge.id, edge.color);
                        }
                        
                        // Highlight edge in teal/cyan
                        edges.update({
                            id: edge.id,
                            color: '#03DAEE'
                        });
                        
                        pathHighlightedEdges.add(edge.id);
                        currentlyHighlightedEdges.add(edge.id);
                    }
                }
            }
            
            // Clear path highlighting
            function clearPathHighlighting() {
                pathHighlightedEdges.forEach(edgeId => {
                    if (originalEdgeColors.has(edgeId)) {
                        edges.update({
                            id: edgeId,
                            color: originalEdgeColors.get(edgeId)
                        });
                    }
                    currentlyHighlightedEdges.delete(edgeId);
                });
                pathHighlightedEdges.clear();
                currentPath = [];
            }
        
            // Search functionality
            function initSearch() {
                const searchInput = document.getElementById('searchInput');
                const searchResults = document.getElementById('searchResults');
                
                searchInput.addEventListener('input', function() {
                    const query = this.value.toLowerCase();
                    if (query.length < 2) {
                        searchResults.style.display = 'none';
                        return;
                    }
                    
                    const results = searchIndex.filter(item => 
                        item.name.toLowerCase().includes(query) ||
                        (item.username && item.username.toLowerCase().includes(query))
                    ).slice(0, 10);
                    
                    displaySearchResults(results);
                });
                
                searchInput.addEventListener('focus', function() {
                    if (this.value.length >= 2) {
                        searchResults.style.display = 'block';
                    }
                });
                
                // Hide results when clicking outside
                document.addEventListener('click', function(e) {
                    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                        searchResults.style.display = 'none';
                    }
                });
            }
            
            // Expandable Search functionality
            function initExpandableSearch() {
                const expandableSearchInput = document.getElementById('expandableSearchInput');
                const expandableSearchResults = document.getElementById('expandableSearchResults');
                
                expandableSearchInput.addEventListener('input', function() {
                    const query = this.value.toLowerCase();
                    if (query.length < 2) {
                        expandableSearchResults.classList.remove('show');
                        return;
                    }
                    
                    const results = searchIndex.filter(item => 
                        item.name.toLowerCase().includes(query) ||
                        (item.username && item.username.toLowerCase().includes(query))
                    ).slice(0, 10);
                    
                    displayExpandableSearchResults(results);
                });
                
                // Prevent space key from collapsing search
                expandableSearchInput.addEventListener('keydown', function(e) {
                    if (e.code === 'Space') {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    }
                });
                
                expandableSearchInput.addEventListener('keyup', function(e) {
                    if (e.code === 'Space') {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    }
                });
                
                expandableSearchInput.addEventListener('keypress', function(e) {
                    if (e.code === 'Space') {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    }
                });
                
                expandableSearchInput.addEventListener('focus', function() {
                    if (this.value.length >= 2) {
                        expandableSearchResults.classList.add('show');
                    }
                });
                
                // Hide results when clicking outside (but not on keyboard events)
                document.addEventListener('click', function(e) {
                    const searchToggleBtn = document.getElementById('searchToggleBtn');
                    // Only close if it's a mouse click, not keyboard events, and not from space key
                    if (e.type === 'click' && !searchToggleBtn.contains(e.target) && e.detail !== 0) {
                        expandableSearchResults.classList.remove('show');
                        if (searchToggleBtn.classList.contains('expanded')) {
                            searchToggleBtn.classList.remove('expanded');
                            expandableSearchInput.value = '';
                            expandableSearchResults.innerHTML = '';
                        }
                    }
                });
            }
            
            // Toggle search interface
            function toggleSearch() {
                const searchToggleBtn = document.getElementById('searchToggleBtn');
                const searchInput = document.getElementById('expandableSearchInput');
                const searchResults = document.getElementById('expandableSearchResults');
                
                if (searchToggleBtn.classList.contains('expanded')) {
                    // Close search
                    searchToggleBtn.classList.remove('expanded');
                    searchInput.value = '';
                    searchResults.classList.remove('show');
                    searchResults.innerHTML = '';
                } else {
                    // Open search
                    searchToggleBtn.classList.add('expanded');
                    setTimeout(() => {
                        searchInput.focus();
                    }, 300);
                }
            }
            
            // Display expandable search results
            function displayExpandableSearchResults(results) {
                const searchResults = document.getElementById('expandableSearchResults');
                
                if (results.length === 0) {
                    searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    searchResults.innerHTML = results.map(item => {
                        // Calculate path distance for each result
                        const currentUserId = currentFilterUser || selectedNode;
                        let pathInfo = '';
                        
                        if (currentUserId && currentUserId !== item.id) {
                            const path = findPathBetweenUsers(currentUserId, item.id);
                            if (path && path.length > 1) {
                                const distance = path.length - 1;
                                pathInfo = ` â€¢ ${distance} degree${distance > 1 ? 's' : ''} away`;
                            } else {
                                pathInfo = ' â€¢ No path found';
                            }
                        }
                        
                        return `
                            <div class="search-result-item" onclick="selectNodeByIdExpandable('${item.id}')">
                                <span>${item.name}</span>
                                <span>${item.taps} taps${pathInfo}</span>
                            </div>
                        `;
                    }).join('');
                }
                
                searchResults.classList.add('show');
            }
            
            // Select node from expandable search
            function selectNodeByIdExpandable(nodeId) {
                // NEW BEHAVIOR: Highlight path from current user to searched user
                highlightPathToUser(nodeId);
                
                // Focus on the target user
                network.selectNodes([nodeId]);
                network.focus(nodeId, { scale: 0.4, animation: true }); // Zoomed out view
                
                // Close the expandable search
                const searchToggleBtn = document.getElementById('searchToggleBtn');
                const searchInput = document.getElementById('expandableSearchInput');
                const searchResults = document.getElementById('expandableSearchResults');
                
                searchToggleBtn.classList.remove('expanded');
                searchInput.value = '';
                searchResults.classList.remove('show');
                searchResults.innerHTML = '';
                
                // Show popup with user data
                showUserPopup(nodeId);
            }
        
            function displaySearchResults(results) {
                const searchResults = document.getElementById('searchResults');
                
                if (results.length === 0) {
                    searchResults.innerHTML = '<div class="search-result-item">No results found</div>';
                } else {
                    searchResults.innerHTML = results.map(item => `
                        <div class="search-result-item" onclick="selectNodeById('${item.id}')" style="cursor: pointer;">
                            <strong>${item.name}</strong><br>
                            <small>${item.taps} taps â€¢ ${item.connections} connections â€¢ 
                            <span class="activity-${item.activity_level}">${item.activity_level}</span></small>
                        </div>
                    `).join('');
                }
                
                searchResults.style.display = 'block';
            }
        
            function selectNodeById(nodeId) {
                // Filter the network to show only connections from this user's perspective
                filterNetworkByUser(nodeId);
                network.selectNodes([nodeId]);
                network.focus(nodeId, { scale: 0.4, animation: true }); // Zoomed out view
                selectNode(nodeId);
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('searchInput').value = '';
                
                // Show popup with user data
                showUserPopup(nodeId);
            }
            
            function showUserPopup(nodeId) {
                const node = allNodes[nodeId];
                if (!node) return;
                
                // Create popup content
                let popupContent = `
                    <div class="popup-title">${node.label}</div>
                    <div class="popup-info"><strong>Home Location:</strong> ${node.home_location || 'No location specified'}</div>
                    <div class="popup-info"><strong>Bio:</strong> ${node.bio || 'No bio provided'}</div>
                `;
                
                // Add LinkedIn if available
                if (node.linkedin) {
                    popupContent += `<div class="popup-info"><strong>LinkedIn:</strong> <a href="${node.linkedin}" target="_blank" style="color: #03DAEE;">${node.linkedin}</a></div>`;
                }
                
                // Add activity stats
                popupContent += `
                    <div class="popup-info"><strong>Taps:</strong> ${node.taps || 0}</div>
                    <div class="popup-info"><strong>Connections:</strong> ${node.connections || 0}</div>
                `;
                
                // Create and show popup
                const popup = document.createElement('div');
                popup.className = 'custom-popup';
                popup.innerHTML = popupContent;
                popup.style.position = 'fixed';
                popup.style.top = '50%';
                popup.style.left = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                popup.style.zIndex = '10000';
                
                // Add close button
                const closeButton = document.createElement('button');
                closeButton.innerHTML = 'Ã—';
                closeButton.style.position = 'absolute';
                closeButton.style.top = '10px';
                closeButton.style.right = '10px';
                closeButton.style.background = 'none';
                closeButton.style.border = 'none';
                closeButton.style.color = '#ffffff';
                closeButton.style.fontSize = '20px';
                closeButton.style.cursor = 'pointer';
                closeButton.onclick = () => popup.remove();
                
                popup.appendChild(closeButton);
                document.body.appendChild(popup);
                
                // Close popup when clicking outside
                const closePopup = (e) => {
                    if (!popup.contains(e.target)) {
                        popup.remove();
                        document.removeEventListener('click', closePopup);
                    }
                };
                setTimeout(() => document.addEventListener('click', closePopup), 100);
            }
        
            function selectNode(nodeId) {
                selectedNode = nodeId;
                const node = allNodes[nodeId];
                
                if (!node) return;
                
                
                // Show profile section
                const profileSection = document.getElementById('profileSection');
                profileSection.style.display = 'block';
                
                // Show degree filter section for user mode
                const degreeFilterSection = document.getElementById('degreeFilterSection');
                degreeFilterSection.style.display = 'block';
                
                
                // Update profile header
                document.getElementById('profileName').textContent = node.label;
                document.getElementById('profileActivity').textContent = 
                    `Activity Level: ${node.activity_level || 'Unknown'}`;
                
                // Update stats
                document.getElementById('profileTaps').textContent = node.taps || 0;
                document.getElementById('profileConnections').textContent = node.connections || 0;
                
                // Display connections
                displayConnections(nodeId);
            }
        
            function displayConnections(nodeId) {
                
                const node = allNodes[nodeId];
                if (!node || !node.profile_data) {
                    return;
                }
                
                const connectionsList = document.getElementById('connectionsList');
                if (!connectionsList) {
                    return;
                }
                
                // Get only 1st degree connections for the connection details section
                let connections = [];
                if (node.profile_data.degree_1_connections) {
                    connections = connections.concat(node.profile_data.degree_1_connections);
                }
                
                // Create connection objects with tap count between selected user and each connection
                const connectionObjects = connections.map(connId => {
                    const connNode = allNodes[connId];
                    if (!connNode) return null;
                    
                    // Calculate taps between the selected user and this connection
                    const tapsBetweenUsers = timeSequence.filter(event => 
                        (event.user1_id === nodeId && event.user2_id === connId) ||
                        (event.user1_id === connId && event.user2_id === nodeId)
                    ).length;
                    
                    return {
                        id: connId,
                        label: connNode.label,
                        taps: tapsBetweenUsers
                    };
                }).filter(conn => conn !== null);
                
                // Sort connections by tap count (highest to lowest)
                connectionObjects.sort((a, b) => b.taps - a.taps);
                
                // Display sorted connections
                connectionsList.innerHTML = connectionObjects.map(conn => `
                    <div class="connection-item">
                        <span>${conn.label}</span>
                        <span>${conn.taps} taps</span>
                    </div>
                `).join('');
                
                // Update timeline to reflect the current state
                const leftSlider = document.getElementById('timelineSliderLeft');
                const rightSlider = document.getElementById('timelineSliderRight');
                if (leftSlider && rightSlider) {
                    const leftValue = parseInt(leftSlider.value);
                    const rightValue = parseInt(rightSlider.value);
                    updateDualTimelineDisplay(leftValue, rightValue);
                }
                
            }
        
        
            function fitView() {
                network.fit();
            }
        
            // Global variable to track freeze state
            let isFrozen = false;

            function stabilize() {
                if (isFrozen) {
                    // Unfreeze - enable physics
                    network.setOptions({
                        physics: {
                            enabled: true,
                            solver: 'forceAtlas2Based',
                            forceAtlas2Based: {
                                gravitationalConstant: -100,
                                centralGravity: 0.005,
                                springLength: 250,
                                springConstant: 0.1,
                                damping: 0.9,
                                avoidOverlap: 1.2
                            },
                            maxVelocity: 8,
                            minVelocity: 0.05,
                            timestep: 0.3,
                            stabilization: {
                                enabled: true,
                                iterations: 200,
                                updateInterval: 25,
                                onlyDynamicEdges: false,
                                fit: false
                            }
                        }
                    });
                    isFrozen = false;
                    document.querySelector('.control-btn[onclick="stabilize()"]').textContent = 'Freeze';
                } else {
                    // Freeze - disable physics
                    network.setOptions({
                        physics: {
                            enabled: false
                        }
                    });
                    isFrozen = true;
                    document.querySelector('.control-btn[onclick="stabilize()"]').textContent = 'Unfreeze';
                }
            }
        
            function resetView() {
                network.fit();
                if (!isFrozen) {
                    network.stabilize(50);
                }
            }
        
            function showAllConnections() {
                // Show all edges in the graph
                edges.forEach(edge => {
                    edges.update({id: edge.id, hidden: false});
                });
                
                // Also update the sidebar
                currentDegreeFilter = {1: true, 2: true, 3: true};
                document.getElementById('degree1').checked = true;
                document.getElementById('degree2').checked = true;
                document.getElementById('degree3').checked = true;
                if (selectedNode) {
                    displayConnections(selectedNode);
                }
            }
        
            function hideConnections() {
                const button = document.querySelector('button[onclick="hideConnections()"]');
                const isCurrentlyHidden = button.textContent.includes('Show');
                
                console.log('ðŸ” Hide Connections clicked - isCurrentlyHidden:', isCurrentlyHidden);
                
                // Debug: Check edge state before action
                const edgesBefore = edges.get();
                const visibleBefore = edgesBefore.filter(edge => !edge.hidden);
                const hiddenBefore = edgesBefore.filter(edge => edge.hidden);
                console.log(`ðŸ” Before action - Total: ${edgesBefore.length}, Visible: ${visibleBefore.length}, Hidden: ${hiddenBefore.length}`);
                
                if (isCurrentlyHidden) {
                    // Show all connections
                    console.log('ðŸ” Showing all connections...');
                    console.log('ðŸ” About to call edges.update() for each edge...');
                    
                    let updateCount = 0;
                    edges.forEach(edge => {
                        console.log(`ðŸ” Updating edge ${edge.id}: from=${edge.from}, to=${edge.to}, hidden=false`);
                        edges.update({id: edge.id, hidden: false});
                        updateCount++;
                    });
                    
                    console.log(`ðŸ” Called edges.update() ${updateCount} times`);
                    button.textContent = 'Hide Connections';
                    button.className = 'control-btn'; // Keep consistent floating control styling
                    
                    // Debug: Check edge state after action
                    setTimeout(() => {
                        const edgesAfter = edges.get();
                        const visibleAfter = edgesAfter.filter(edge => !edge.hidden);
                        const hiddenAfter = edgesAfter.filter(edge => edge.hidden);
                        console.log(`ðŸ” After action - Total: ${edgesAfter.length}, Visible: ${visibleAfter.length}, Hidden: ${hiddenAfter.length}`);
                        console.log('ðŸ” All connections shown');
                    }, 50);
                } else {
                    // Hide all connections
                    console.log('ðŸ” Hiding all connections...');
                    console.log('ðŸ” About to call edges.update() for each edge...');
                    
                    let updateCount = 0;
                    edges.forEach(edge => {
                        console.log(`ðŸ” Updating edge ${edge.id}: from=${edge.from}, to=${edge.to}, hidden=true`);
                        edges.update({id: edge.id, hidden: true});
                        updateCount++;
                    });
                    
                    console.log(`ðŸ” Called edges.update() ${updateCount} times`);
                    button.textContent = 'Show Connections';
                    button.className = 'control-btn'; // Keep consistent floating control styling
                    
                    // Debug: Check edge state after action
                    setTimeout(() => {
                        const edgesAfter = edges.get();
                        const visibleAfter = edgesAfter.filter(edge => !edge.hidden);
                        const hiddenAfter = edgesAfter.filter(edge => edge.hidden);
                        console.log(`ðŸ” After action - Total: ${edgesAfter.length}, Visible: ${visibleAfter.length}, Hidden: ${hiddenAfter.length}`);
                        console.log('ðŸ” All connections hidden');
                    }, 50);
                }
                
                // Update the user count display
                const visibleNodeCount = nodes.get().filter(node => !node.hidden).length;
                const connectionCountElement = document.getElementById('connectionCount');
                if (connectionCountElement) {
                    connectionCountElement.textContent = `${visibleNodeCount} total users`;
                }
            }
            
            // Activate Global View functionality
            function activateGlobalView() {
                // Toggle global view mode
                globalViewEnabled = !globalViewEnabled;
                const globalViewBtn = document.getElementById('globalViewBtn');
                
                // Update button appearance
                if (globalViewEnabled) {
                    globalViewBtn.classList.add('active');
                    globalViewBtn.textContent = 'Back to User View';
                    // Hide user-specific elements (timeline and button stay visible)
                    document.getElementById('profileSection').style.display = 'none';
                    document.getElementById('degreeFilterSection').style.display = 'none';
                    // Hide connection details section in global mode
                    document.getElementById('connectionDetailsSection').style.display = 'none';
                    // Hide search functionality in global mode
                    document.querySelector('.search-control-floating').style.display = 'none';
                } else {
                    globalViewBtn.classList.remove('active');
                    globalViewBtn.textContent = 'See full Arc Network';
                    // Show user-specific elements
                    document.getElementById('profileSection').style.display = 'block';
                    // Show search functionality in user mode
                    document.querySelector('.search-control-floating').style.display = 'block';
                    // Show connection details section in user mode
                    document.getElementById('connectionDetailsSection').style.display = 'block';
                    // Show degree filters if a user is selected (either currentFilterUser or selectedNode)
                    if (currentFilterUser || selectedNode) {
                        document.getElementById('degreeFilterSection').style.display = 'block';
                    }
                }
                
                // Update network display to show all nodes
                updateNetworkDisplay();
            }
            
            // Update network display based on current mode
            function updateNetworkDisplay() {
                if (globalViewEnabled) {
                    // Show all nodes and edges in global view
                    console.log('ðŸŒ Global view: showing all nodes and edges');
                    console.log('ðŸ“Š All nodes count:', Object.keys(allNodes).length);
                    console.log('ðŸ“Š All edges count:', Object.keys(allEdges).length);
                    
                    // Clear any user filter when entering global view
                    currentFilterUser = null;
                    
                    // Update all nodes to be visible and white, but hide labels in global mode
                    const allNodeData = Object.values(allNodes).map(node => ({
                        id: node.id,
                        hidden: false,
                        color: '#FFFFFF', // White for global view
                        font: { size: 0, face: 'Arial', color: '#ffffff' }, // Hide labels in global mode
                        label: '' // Remove labels completely
                    }));
                    nodes.update(allNodeData);
                    
                    // Update all edges to be visible with initial styling
                    const allEdgeData = Object.values(allEdges).map(edge => {
                        const tapCount = edge.tap_count || 1;
                        
                        // Apply 5-segment styling based on tap count
                        let thickness, color;
                        if (tapCount === 1) {
                            thickness = 0.5;
                            color = "#E0E0E0"; // Light grey
                        } else if (tapCount >= 2 && tapCount <= 3) {
                            thickness = 1.5;
                            color = "#D0D0D0"; // Medium-light grey
                        } else if (tapCount >= 4 && tapCount <= 5) {
                            thickness = 2.5;
                            color = "#C0C0C0"; // Medium grey
                        } else if (tapCount >= 6 && tapCount <= 8) {
                            thickness = 3.5;
                            color = "#F0F0F0"; // Light white
                        } else if (tapCount >= 9) {
                            thickness = 5.0;
                            color = "#FFFFFF"; // White
                        } else {
                            // Fallback for edge cases
                            thickness = 0.5;
                            color = "#E0E0E0";
                        }
                        
                        return {
                        id: edge.id,
                        hidden: false,
                            color: color,
                            width: thickness
                        };
                    });
                    edges.update(allEdgeData);
                    
                    // Refresh the network
                    network.fit();
                    network.stabilize(50);
                    
                    // Ensure timeline works in global mode
                    const leftSlider = document.getElementById('timelineSliderLeft');
                    const rightSlider = document.getElementById('timelineSliderRight');
                    if (leftSlider && rightSlider) {
                        const leftValue = parseInt(leftSlider.value);
                        const rightValue = parseInt(rightSlider.value);
                        updateDualTimelineDisplay(leftValue, rightValue);
                    }
                } else {
                    // Return to user-centric view (restore any existing filters)
                    console.log('ðŸ”„ Returning to user view');
                    console.log('ðŸ“Š Current filter user:', currentFilterUser);
                    console.log('ðŸ“Š Selected node:', selectedNode);
                    
                    // Always restore node labels when returning to user mode
                    const allNodeData = Object.values(allNodes).map(node => ({
                        id: node.id,
                        hidden: false,
                        font: { size: 14.4, face: 'Arial', color: '#ffffff' }, // Restore labels
                        label: node.label // Restore original labels
                    }));
                    nodes.update(allNodeData);
                    
                    if (currentFilterUser) {
                        // Restore user-centric view with proper filtering
                        filterNetworkByUser(currentFilterUser);
                        // Ensure degree filters are enabled for user view
                        setDegreeFiltersEnabled(true);
                    } else if (selectedNode) {
                        // If no currentFilterUser but we have a selectedNode, restore that
                        filterNetworkByUser(selectedNode);
                        // Ensure degree filters are enabled for user view
                        setDegreeFiltersEnabled(true);
                    } else {
                        // Show all nodes if no specific user filter
                        console.log('ðŸ”„ No user selected, showing all nodes');
                        edges.update(Object.values(allEdges));
                        // Disable degree filters when no user is selected
                        setDegreeFiltersEnabled(false);
                    }
                }
            }
        
            // Global variables for filtering
            let filteredNodes = new Set();
            let filteredEdges = new Set();
            let currentFilterUser = null;
            
            function filterNetworkByUser(userId) {
                
                currentFilterUser = userId;
                const user = allNodes[userId];
                if (!user || !user.profile_data) {
                    return;
                }
                
                // Reset degree filters to default (all degrees enabled)
                currentDegreeFilter = {1: true, 2: true, 3: true};
                document.getElementById('degree1').checked = true;
                document.getElementById('degree2').checked = true;
                document.getElementById('degree3').checked = true;
                
                // Apply initial filter (all degrees) FIRST
                applyDegreeFilter();
                
                // Then set timeline to full range (0% - 100%) to show user's connections
                const leftSlider = document.getElementById('timelineSliderLeft');
                const rightSlider = document.getElementById('timelineSliderRight');
                if (leftSlider && rightSlider) {
                    leftSlider.value = 0;
                    rightSlider.value = 100;
                    updateDualTimelineDisplay(0, 100);
                }
                
            }
            
            function applyDegreeFilter() {
                
                if (!currentFilterUser) {
                    return;
                }
                
                const user = allNodes[currentFilterUser];
                if (!user || !user.profile_data) {
                    return;
                }
                
                // Collect all nodes to show based on degree filters
                const nodesToShow = new Set();
                const edgesToShow = new Set();
                
                // Always include the current user
                nodesToShow.add(currentFilterUser);
                
                // Add nodes based on degree filters
                if (currentDegreeFilter[1]) {
                    user.profile_data.degree_1_connections.forEach(connId => {
                        nodesToShow.add(connId);
                    });
                }
                
                if (currentDegreeFilter[2]) {
                    user.profile_data.degree_2_connections.forEach(connId => {
                        nodesToShow.add(connId);
                    });
                }
                
                if (currentDegreeFilter[3]) {
                    user.profile_data.degree_3_connections.forEach(connId => {
                        nodesToShow.add(connId);
                    });
                }
                
                // Batch collect all node updates
                const nodeUpdates = [];
                Object.entries(allNodes).forEach(([nodeId, node]) => {
                    nodeUpdates.push({
                        id: nodeId,
                        hidden: !nodesToShow.has(nodeId)
                    });
                });
                
                // Apply node updates only - let timeline system handle edge visibility
                nodes.update(nodeUpdates);
                
                // Don't update edges here - let the timeline system handle edge visibility
                // The timeline system will properly integrate with degree filters
                
            }
            
            // DEACTIVATED: resetFilter function - no longer needed in user-centric mode
            function resetFilter() {
                // Function deactivated - reset functionality not needed in user-centric mode
                console.log('Reset filter function deactivated');
            }
            
            // Create edge ID mapping from time sequence to graph edges
            function createEdgeIdMapping() {
                const edgeMapping = new Map();
                
                // Use allEdges instead of edges.get() to avoid duplicate IDs
                const graphEdges = Object.values(allEdges);
                
                // Create mapping based on source and target node IDs
                // Only create one entry per edge to prevent duplicates
                graphEdges.forEach(edge => {
                    const key = `${edge.from}-${edge.to}`;
                    // Only add if not already present to prevent duplicates
                    if (!edgeMapping.has(key)) {
                        edgeMapping.set(key, edge.id);
                    }
                });
                
                
                return edgeMapping;
            }
            
            // Degree filter state management functions
            function saveDegreeFilterState() {
                savedDegreeFilterState = {
                    1: document.getElementById('degree1').checked,
                    2: document.getElementById('degree2').checked,
                    3: document.getElementById('degree3').checked
                };
                console.log('Saved degree filter state:', savedDegreeFilterState);
            }
            
            function restoreDegreeFilterState() {
                document.getElementById('degree1').checked = savedDegreeFilterState[1];
                document.getElementById('degree2').checked = savedDegreeFilterState[2];
                document.getElementById('degree3').checked = savedDegreeFilterState[3];
                currentDegreeFilter = {...savedDegreeFilterState};
                console.log('Restored degree filter state:', savedDegreeFilterState);
            }
            
                    function setDegreeFiltersEnabled(enabled) {
            const degree1 = document.getElementById('degree1');
            const degree2 = document.getElementById('degree2');
            const degree3 = document.getElementById('degree3');
            
            degree1.disabled = !enabled;
            degree2.disabled = !enabled;
            degree3.disabled = !enabled;
            
            // Visual feedback - gray out when disabled but preserve checked appearance
            const checkboxes = [degree1, degree2, degree3];
            checkboxes.forEach(checkbox => {
                if (!enabled) {
                    checkbox.style.opacity = '0.5';
                    checkbox.style.cursor = 'not-allowed';
                    // Ensure checked state is visually preserved when disabled
                    if (checkbox.checked) {
                        checkbox.style.accentColor = '#666'; // Gray color for checked disabled state
                    }
                } else {
                    checkbox.style.opacity = '1';
                    checkbox.style.cursor = 'pointer';
                    checkbox.style.accentColor = ''; // Reset to default
                }
            });
            
        }
            
            // Timeline Slider functionality with smooth transitions
            let updateTimeout = null;
            let isUpdating = false;
            
            function initTimelineSlider() {
                const leftSlider = document.getElementById('timelineSliderLeft');
                const rightSlider = document.getElementById('timelineSliderRight');
                if (!leftSlider || !rightSlider) return;
                
                // Set initial state to full range (0-100%) - show all connections initially
                leftSlider.value = 0;
                rightSlider.value = 100;
                updateDualTimelineDisplay(0, 100);
                updateRangeHighlighting(0, 100);
                
                // Add debugging for click events
                leftSlider.addEventListener('mousedown', function(e) {
                    console.log('ðŸ–±ï¸ Left slider mousedown - event target:', e.target.id);
                });
                
                rightSlider.addEventListener('mousedown', function(e) {
                    console.log('ðŸ–±ï¸ Right slider mousedown - event target:', e.target.id);
                });
                
                // Add debugging for input events
                leftSlider.addEventListener('input', function(e) {
                    console.log('ðŸ“Š Left slider input event - value:', e.target.value);
                });
                
                rightSlider.addEventListener('input', function(e) {
                    console.log('ðŸ“Š Right slider input event - value:', e.target.value);
                });
                
                // Add event listeners for both sliders
                [leftSlider, rightSlider].forEach(slider => {
                    slider.addEventListener('input', function() {
                        console.log(`ðŸŽšï¸ Slider moved: ${this.id} = ${this.value}%`);
                        
                    // Clear any pending update
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                    
                    // Debounce the update to reduce choppiness
                    updateTimeout = setTimeout(() => {
                        if (!isUpdating) {
                                const leftValue = parseInt(leftSlider.value);
                                const rightValue = parseInt(rightSlider.value);
                                
                                console.log(`ðŸŽšï¸ Slider values: Left=${leftValue}%, Right=${rightValue}%`);
                                
                                // Calculate minimum gap based on actual date difference
                                const minGap = 1; // Minimum 1% gap
                                const actualDaysDiff = getDateDifferenceInDays(leftValue, rightValue);
                                
                                console.log(`ðŸ“… Date difference: ${actualDaysDiff} days`);
                                
                            // Handle left slider movement
                            if (this === leftSlider) {
                                console.log(`ðŸŽšï¸ Processing LEFT slider movement: ${leftValue}% -> ${rightValue}%`);
                                // Left slider cannot go past right slider minus minimum gap
                                if (leftValue >= rightValue - minGap) {
                                    const newValue = Math.max(0, rightValue - minGap);
                                    leftSlider.value = newValue;
                                    console.log(`ðŸŽšï¸ Left slider constrained from ${leftValue}% to ${newValue}% (min gap: ${minGap}%)`);
                                }
                            }
                            
                            // Handle right slider movement  
                            if (this === rightSlider) {
                                console.log(`ðŸŽšï¸ Processing RIGHT slider movement: ${leftValue}% -> ${rightValue}%`);
                                // Right slider cannot go before left slider plus minimum gap
                                if (rightValue <= leftValue + minGap) {
                                    const newValue = Math.min(100, leftValue + minGap);
                                    rightSlider.value = newValue;
                                    console.log(`ðŸŽšï¸ Right slider constrained from ${rightValue}% to ${newValue}% (min gap: ${minGap}%)`);
                                }
                            }
                                
                                updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                                updateRangeHighlighting(parseInt(leftSlider.value), parseInt(rightSlider.value));
                        }
                    }, 16); // ~60fps update rate
                });
                
                    slider.addEventListener('mousedown', function() {
                    isSliderDragging = true;
                });
                
                    slider.addEventListener('mouseup', function() {
                    isSliderDragging = false;
                    // Force immediate update when dragging ends
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                        updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                });
                
                    slider.addEventListener('touchstart', function() {
                    isSliderDragging = true;
                });
                
                    slider.addEventListener('touchend', function() {
                    isSliderDragging = false;
                    // Force immediate update when touch ends
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                        updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                    });
                });
            }
            
            // Date conversion functions
            function getDateFromPercentage(percentage) {
                if (timeSequence.length === 0) return new Date();
                const index = Math.floor((percentage / 100) * timeSequence.length);
                const event = timeSequence[Math.min(index, timeSequence.length - 1)];
                return new Date(event.time);
            }
            
            function getPercentageFromDate(date) {
                if (timeSequence.length === 0) return 0;
                const targetTime = new Date(date).getTime();
                let closestIndex = 0;
                let minDiff = Math.abs(new Date(timeSequence[0].time).getTime() - targetTime);
                
                for (let i = 1; i < timeSequence.length; i++) {
                    const diff = Math.abs(new Date(timeSequence[i].time).getTime() - targetTime);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }
                
                return Math.round((closestIndex / timeSequence.length) * 100);
            }
            
            function formatDate(date) {
                return date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric',
                    year: 'numeric'
                });
            }
            
            function getDateDifferenceInDays(startPercentage, endPercentage) {
                if (timeSequence.length === 0) return 0;
                
                const startDate = getDateFromPercentage(startPercentage);
                const endDate = getDateFromPercentage(endPercentage);
                
                const timeDiff = endDate.getTime() - startDate.getTime();
                const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24));
                
                return daysDiff;
            }
            
            // Update dual timeline display
            function updateRangeHighlighting(startPercentage, endPercentage) {
                const container = document.querySelector('.dual-slider-container');
                if (container) {
                    const rangeWidth = endPercentage - startPercentage;
                    container.style.setProperty('--range-left', startPercentage + '%');
                    container.style.setProperty('--range-width', rangeWidth + '%');
                    console.log(`ðŸŽ¨ Range highlighting: ${startPercentage}% to ${endPercentage}% (width: ${rangeWidth}%)`);
                }
            }
            
            function updateDualTimelineDisplay(startPercentage, endPercentage) {
                if (timeSequence.length === 0) {
                    console.log('âš ï¸ Timeline: timeSequence is empty');
                    return;
                }
                
                // Prevent multiple simultaneous updates
                if (isUpdating) return;
                isUpdating = true;
                
                console.log(`ðŸ•’ Timeline: Updating display ${startPercentage}% - ${endPercentage}%`);
                
                // Calculate start and end event indices
                const startIndex = Math.floor((startPercentage / 100) * timeSequence.length);
                const endIndex = Math.floor((endPercentage / 100) * timeSequence.length);
                
                console.log(`ðŸ“Š Timeline: Event indices ${startIndex} - ${endIndex} (total: ${timeSequence.length})`);
                
                // Get date range
                const startDate = getDateFromPercentage(startPercentage);
                const endDate = getDateFromPercentage(endPercentage);
                
                // Update date displays
                document.getElementById('startDate').textContent = formatDate(startDate);
                document.getElementById('endDate').textContent = formatDate(endDate);
                
                // Determine if we're in user-centric mode
                let isUserCentric = false;
                let selectedUserId = null;
                
                if (typeof currentFilterUser !== 'undefined' && currentFilterUser !== null) {
                    isUserCentric = true;
                    selectedUserId = currentFilterUser;
                }
                
                // Get degree filter settings
                const degree1Enabled = document.getElementById('degree1').checked;
                const degree2Enabled = document.getElementById('degree2').checked;
                const degree3Enabled = document.getElementById('degree3').checked;
                
                // Filter events within the time range
                const filteredEvents = timeSequence.slice(startIndex, endIndex + 1);
                
                // Update network display based on filtered events
                updateNetworkWithTimeRange(filteredEvents, isUserCentric, selectedUserId, degree1Enabled, degree2Enabled, degree3Enabled, startPercentage, endPercentage);
                
                // Update profile stats if a user is selected
                if (isUserCentric && selectedUserId) {
                    updateProfileStatsForTimeline(selectedUserId, filteredEvents);
                }
                
                // Update connection count and date range
                // Count unique users from filtered events in timeline range
                const uniqueUsers = new Set();
                filteredEvents.forEach(event => {
                    if (event.user1_id) uniqueUsers.add(event.user1_id);
                    if (event.user2_id) uniqueUsers.add(event.user2_id);
                });
                const userCount = uniqueUsers.size;
                const daysDiff = getDateDifferenceInDays(startPercentage, endPercentage);
                
                // Format as stacked lines without parentheses
                let rangeText = `${userCount} users`;
                if (daysDiff > 0) {
                    rangeText += `\n${daysDiff} days`;
                }
                
                document.getElementById('connectionCount').textContent = rangeText;
                
                // Reset update flag
                setTimeout(() => {
                    isUpdating = false;
                    reapplyHighlighting();
                }, 50);
            }
            
            // Update network with filtered time range events
            function updateNetworkWithTimeRange(filteredEvents, isUserCentric, selectedUserId, degree1Enabled, degree2Enabled, degree3Enabled, startPercentage, endPercentage) {
                console.log(`ðŸ”— Network: Updating with ${filteredEvents.length} filtered events`);
                
                if (filteredEvents.length === 0) {
                    console.log('âš ï¸ Network: No events in range - hiding all');
                    // Hide all nodes and edges if no events in range
                    const allNodeUpdates = Object.keys(allNodes).map(nodeId => ({
                        id: nodeId,
                        hidden: true
                    }));
                    const allEdgeUpdates = Object.keys(allEdges).map(edgeId => ({
                        id: edgeId,
                        hidden: true
                    }));
                    nodes.update(allNodeUpdates);
                    edges.update(allEdgeUpdates);
                    return;
                }
                
                // Create a set of all nodes involved in the filtered events
                const nodesInTimeRange = new Set();
                filteredEvents.forEach(event => {
                    if (event.user1_id) nodesInTimeRange.add(event.user1_id);
                    if (event.user2_id) nodesInTimeRange.add(event.user2_id);
                });
                
                if (isUserCentric && selectedUserId) {
                    // User-centric mode with degree filters
                    const userNode = allNodes[selectedUserId];
                    if (!userNode || !userNode.profile_data) {
                        return;
                    }
                    
                    const profileData = userNode.profile_data;
                    const degree1Connections = profileData.degree_1_connections || [];
                    const degree2Connections = profileData.degree_2_connections || [];
                    const degree3Connections = profileData.degree_3_connections || [];
                    
                    // Build set of degree-filtered connections
                    const degreeFilteredConnections = new Set();
                    if (degree1Enabled) {
                        degree1Connections.forEach(conn => degreeFilteredConnections.add(conn));
                    }
                    if (degree2Enabled) {
                        degree2Connections.forEach(conn => degreeFilteredConnections.add(conn));
                    }
                    if (degree3Enabled) {
                        degree3Connections.forEach(conn => degreeFilteredConnections.add(conn));
                    }
                    
                    // Update nodes - show selected user + degree-filtered connections that are in time range
                    const nodeUpdates = [];
                    Object.keys(allNodes).forEach(nodeId => {
                        const shouldShow = nodeId === selectedUserId || 
                                         (degreeFilteredConnections.has(nodeId) && nodesInTimeRange.has(nodeId));
                        nodeUpdates.push({
                            id: nodeId,
                            hidden: !shouldShow
                        });
                    });
                    nodes.update(nodeUpdates);
                    
                    // Update edges - show edges between visible nodes that are in time range
                    // Note: Edge styling will be handled later in the function, so we just set visibility here
                    const edgeUpdates = [];
                    Object.entries(allEdges).forEach(([edgeId, edge]) => {
                        const fromVisible = !allNodes[edge.from].hidden;
                        const toVisible = !allNodes[edge.to].hidden;
                        const inTimeRange = nodesInTimeRange.has(edge.from) && nodesInTimeRange.has(edge.to);
                        
                        edgeUpdates.push({
                            id: edgeId,
                            hidden: !(fromVisible && toVisible && inTimeRange)
                        });
                    });
                    // Don't call edges.update() here - it will be called later with styling
                    
                } else {
                    // Global view mode - show all nodes and edges in time range
                    const nodeUpdates = [];
                    Object.keys(allNodes).forEach(nodeId => {
                        nodeUpdates.push({
                            id: nodeId,
                            hidden: !nodesInTimeRange.has(nodeId)
                        });
                    });
                    nodes.update(nodeUpdates);
                    
                    // Edge updates will be handled later with styling
                    // Don't call edges.update() here to avoid duplication
                }
                
                // Update node properties based on filtered events
                const nodePropsUpdates = [];
                Object.keys(allNodes).forEach(nodeId => {
                    if (!allNodes[nodeId].hidden) {
                        const nodeProps = calculateTimelineNodeProperties(nodeId, filteredEvents);
                        nodePropsUpdates.push({
                            id: nodeId,
                            size: nodeProps.size,
                            color: nodeProps.color,
                            title: `${allNodes[nodeId].label} - ${nodeProps.taps} taps, ${nodeProps.connections} connections`
                        });
                    }
                });
                if (nodePropsUpdates.length > 0) {
                    nodes.update(nodePropsUpdates);
                }
                
                // Apply edge thickness calculation for timeline < 100%
                const timelinePercentage = (endPercentage - startPercentage);
                
                if (timelinePercentage < 100 && isUserCentric && selectedUserId) {
                    
                    // Create edge ID mapping
                    const edgeMapping = createEdgeIdMapping();
                    
                    // Create a set of edges that should be visible based on timeline
                    const visibleEdgeIds = new Set();
                    const eventIndex = Math.floor((endPercentage / 100) * timeSequence.length);
                    for (let i = 0; i < eventIndex; i++) {
                        const event = timeSequence[i];
                        // Map time sequence edge to graph edge using user1/user2
                        const key = `${event.user1_id}-${event.user2_id}`;
                        const reverseKey = `${event.user2_id}-${event.user1_id}`;
                        
                        const graphEdgeId = edgeMapping.get(key) || edgeMapping.get(reverseKey);
                        if (graphEdgeId !== undefined) {
                            visibleEdgeIds.add(graphEdgeId);
                        }
                    }
                    
                    // Get the user's degree-filtered connections
                    const userNode = allNodes[selectedUserId];
                    const profileData = userNode.profile_data;
                    const degree1Connections = profileData.degree_1_connections || [];
                    const degree2Connections = profileData.degree_2_connections || [];
                    const degree3Connections = profileData.degree_3_connections || [];
                    
                    // Collect degree-filtered connections based on actual user selections
                    const degreeFilteredConnections = new Set();
                    degreeFilteredConnections.add(selectedUserId);
                    
                    if (degree1Enabled) {
                        degree1Connections.forEach(connId => degreeFilteredConnections.add(connId));
                    }
                    if (degree2Enabled) {
                        degree2Connections.forEach(connId => degreeFilteredConnections.add(connId));
                    }
                    if (degree3Enabled) {
                        degree3Connections.forEach(connId => degreeFilteredConnections.add(connId));
                    }
                    
                        // Apply edge thickness calculation
                        const userCentricTimelineEdgeUpdates = [];
                    Object.values(allEdges).forEach(edge => {
                        const isInTimeline = visibleEdgeIds.has(edge.id);
                        const isInDegreeFilter = degreeFilteredConnections.has(edge.from) && degreeFilteredConnections.has(edge.to);
                        const shouldShow = isInTimeline && isInDegreeFilter;
                        
                        // Calculate total tap count between these users within the timeline range
                        const user1Id = edge.from;
                        const user2Id = edge.to;
                        const timelineTapCount = filteredEvents.filter(tap => 
                            (tap.user1_id === user1Id && tap.user2_id === user2Id) ||
                            (tap.user1_id === user2Id && tap.user2_id === user1Id)
                        ).length;
                        
                        // Apply 5-segment styling based on timeline tap count
                        let thickness, color;
                        if (timelineTapCount === 1) {
                            thickness = 0.5;
                            color = "#E0E0E0"; // Light grey
                        } else if (timelineTapCount >= 2 && timelineTapCount <= 3) {
                            thickness = 1.5;
                            color = "#D0D0D0"; // Medium-light grey
                        } else if (timelineTapCount >= 4 && timelineTapCount <= 5) {
                            thickness = 2.5;
                            color = "#C0C0C0"; // Medium grey
                        } else if (timelineTapCount >= 6 && timelineTapCount <= 8) {
                            thickness = 3.5;
                            color = "#F0F0F0"; // Light white
                        } else if (timelineTapCount >= 9) {
                            thickness = 5.0;
                            color = "#FFFFFF"; // White
                        } else {
                            // Fallback for no taps or edge cases
                            thickness = 0.5;
                            color = "#E0E0E0";
                        }
                        
                        userCentricTimelineEdgeUpdates.push({
                            id: edge.id, 
                            hidden: !shouldShow,
                            width: thickness,
                            color: color
                        });
                    });
                    
                    // Apply all edge updates in batch
                    edges.update(userCentricTimelineEdgeUpdates);
                } else if (timelinePercentage >= 100 && isUserCentric && selectedUserId) {
                    
                    // At 100% timeline, show all degree-filtered connections
                    // Get the user's degree-filtered connections
                    const userNode = allNodes[selectedUserId];
                    const profileData = userNode.profile_data;
                    const degree1Connections = profileData.degree_1_connections || [];
                    const degree2Connections = profileData.degree_2_connections || [];
                    const degree3Connections = profileData.degree_3_connections || [];
                    
                    // Collect all degree-filtered connections
                    const degreeFilteredConnections = new Set();
                    
                    // At 100% timeline, always use checkbox states
                    // Always include the selected user themselves
                    degreeFilteredConnections.add(selectedUserId);
                    
                    if (degree1Enabled) {
                        degree1Connections.forEach(connId => degreeFilteredConnections.add(connId));
                    }
                    if (degree2Enabled) {
                        degree2Connections.forEach(connId => degreeFilteredConnections.add(connId));
                    }
                    if (degree3Enabled) {
                        degree3Connections.forEach(connId => degreeFilteredConnections.add(connId));
                    }
                
                    // Apply degree filtering to all edges (same logic for all timeline positions)
                    const hundredPercentEdgeUpdates = [];
                    Object.values(allEdges).forEach(edge => {
                        let isInDegreeFilter = false;
                        
                        // Simple node-based degree filtering: show edges between visible nodes
                        isInDegreeFilter = degreeFilteredConnections.has(edge.from) && degreeFilteredConnections.has(edge.to);
                        
                        // Calculate total tap count between these users within the full timeline range
                        const user1Id = edge.from;
                        const user2Id = edge.to;
                        const timelineTapCount = filteredEvents.filter(tap => 
                            (tap.user1_id === user1Id && tap.user2_id === user2Id) ||
                            (tap.user1_id === user2Id && tap.user2_id === user1Id)
                        ).length;
                        
                        // Apply 5-segment styling based on timeline tap count (same as < 100% logic)
                        let thickness, color;
                        if (timelineTapCount === 1) {
                            thickness = 0.5;
                            color = "#E0E0E0"; // Light grey
                        } else if (timelineTapCount >= 2 && timelineTapCount <= 3) {
                            thickness = 1.5;
                            color = "#D0D0D0"; // Medium-light grey
                        } else if (timelineTapCount >= 4 && timelineTapCount <= 5) {
                            thickness = 2.5;
                            color = "#C0C0C0"; // Medium grey
                        } else if (timelineTapCount >= 6 && timelineTapCount <= 8) {
                            thickness = 3.5;
                            color = "#F0F0F0"; // Light white
                        } else if (timelineTapCount >= 9) {
                            thickness = 5.0;
                            color = "#FFFFFF"; // White
                        } else {
                            // Fallback for no taps or edge cases
                            thickness = 0.5;
                            color = "#E0E0E0";
                        }
                        
                        hundredPercentEdgeUpdates.push({
                            id: edge.id, 
                            hidden: !isInDegreeFilter,
                            width: thickness,
                            color: color
                        });
                    });
                    edges.update(hundredPercentEdgeUpdates);
                    
                    // Show nodes that are part of the degree-filtered connections AND have visible edges
                    let visibleNodeCount = 0;
                    const nodesWithVisibleEdges = new Set();
                    
                    // First, collect all nodes that have visible edges
                    edges.get().forEach(edge => {
                        if (!edge.hidden) {
                            nodesWithVisibleEdges.add(edge.from);
                            nodesWithVisibleEdges.add(edge.to);
                        }
                    });
                    
                    const hundredPercentNodeUpdates = [];
                    nodes.forEach(node => {
                        const shouldShow = node.id === selectedUserId || (degreeFilteredConnections.has(node.id) && nodesWithVisibleEdges.has(node.id));
                        hundredPercentNodeUpdates.push({
                            id: node.id, 
                            hidden: !shouldShow
                        });
                        if (shouldShow) visibleNodeCount++;
                    });
                    nodes.update(hundredPercentNodeUpdates);
                }
            }
            
            // Calculate node properties based on filtered events
            function calculateTimelineNodeProperties(nodeId, filteredEvents) {
                const node = allNodes[nodeId];
                if (!node) return { size: 10, color: "#87CEEB" }; // Default values
                
                // Count events involving this node in the filtered time range
                let timelineTaps = 0;
                let timelineConnections = new Set();
                
                // Count events involving this node in the filtered events
                filteredEvents.forEach(event => {
                    if (event.user1_id === nodeId || event.user2_id === nodeId) {
                        // Include ALL events involving this node (no degree filtering for styling)
                        timelineTaps++;
                        timelineConnections.add(event.user1_id);
                        timelineConnections.add(event.user2_id);
                    }
                });
                
                // Remove the node itself from connections count
                timelineConnections.delete(nodeId);
                const connectionCount = timelineConnections.size;
                
                // Calculate size with new formula: 10px base + 0.167px per tap, max 60px
                let size = 10; // Base size
                if (timelineTaps > 0) {
                    // New sizing: 300 taps = 60px max size
                    size = Math.max(10, Math.min(60, 10 + (timelineTaps * 0.167)));
                }
                
                // New 6-step color gradient: Dark grey â†’ White (100 taps max)
                let color = "#808080"; // Default dark grey
                if (timelineTaps >= 100) {
                    color = "#FFFFFF"; // White for very high activity (100+ taps)
                } else if (timelineTaps >= 80) {
                    color = "#F5F5F5"; // Very light grey for high activity (80+ taps)
                } else if (timelineTaps >= 60) {
                    color = "#E0E0E0"; // Light grey for medium-high activity (60+ taps)
                } else if (timelineTaps >= 40) {
                    color = "#C0C0C0"; // Silver for medium activity (40+ taps)
                } else if (timelineTaps >= 20) {
                    color = "#A9A9A9"; // Dark grey for low-medium activity (20+ taps)
                }
                
                return { size, color, taps: timelineTaps, connections: connectionCount };
            }
            
            // Format timestamp to user-friendly date format
            function formatTimestamp(timestamp) {
                try {
                    const date = new Date(timestamp);
                    const options = { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric'
                    };
                    return date.toLocaleDateString('en-US', options);
                } catch (error) {
                    // Fallback to original timestamp if parsing fails
                    return timestamp;
                }
            }
            
            // Update profile stats based on timeline position
            function updateProfileStats(userId, eventIndex) {
                const timelineProps = calculateTimelineNodeProperties(userId, eventIndex);
                
                // Update the profile stats display
                document.getElementById('profileTaps').textContent = timelineProps.taps;
                document.getElementById('profileConnections').textContent = timelineProps.connections;
            }
            
            // Update profile stats for dual timeline system
            function updateProfileStatsForTimeline(userId, filteredEvents) {
                // Calculate stats based on filtered events within the timeline range
                let timelineTaps = 0;
                let timelineConnections = new Set();
                
                // Count taps and connections from filtered events
                filteredEvents.forEach(event => {
                    if (event.user1_id === userId || event.user2_id === userId) {
                        timelineTaps++;
                        timelineConnections.add(event.user1_id);
                        timelineConnections.add(event.user2_id);
                    }
                });
                
                // Remove the user themselves from connections count
                timelineConnections.delete(userId);
                const connectionCount = timelineConnections.size;
                
                // Update the profile stats display
                document.getElementById('profileTaps').textContent = timelineTaps;
                document.getElementById('profileConnections').textContent = connectionCount;
            }
            
            function updateTimelineDisplay(percentage) {
                if (timeSequence.length === 0) return;
                
                // Prevent multiple simultaneous updates
                if (isUpdating) return;
                isUpdating = true;
                
                
                // Calculate how many events to show based on percentage
                const eventIndex = Math.floor((percentage / 100) * timeSequence.length);
                
                // Determine if we're in user-centric mode
                let isUserCentric = false;
                let selectedUserId = null;
                
                // Check if there's a current filter user (set by filterNetworkByUser)
                
                if (typeof currentFilterUser !== 'undefined' && currentFilterUser !== null) {
                    isUserCentric = true;
                    selectedUserId = currentFilterUser;
                    const user = allNodes[currentFilterUser];
                } else {
                }
                
                // Debug: Check degree filter state
                const degree1Enabled = document.getElementById('degree1').checked;
                const degree2Enabled = document.getElementById('degree2').checked;
                const degree3Enabled = document.getElementById('degree3').checked;

                                // NEW TIMELINE RULE: Handle degree filters based on timeline position
                // MODIFIED: Keep degree filters enabled at all times for better user experience
                if (isUserCentric && selectedUserId) {
                    // Always enable degree filters - user can interact with them while sliding timeline
                    setDegreeFiltersEnabled(true);
                    
                    // Always respect the user's degree filter selections
                    // No forced checking or state saving/restoring
                } else {
                    // Global mode: Disable degree filters since they don't apply to global view
                    document.getElementById('degree1').checked = true;
                    document.getElementById('degree2').checked = true;
                    document.getElementById('degree3').checked = true;
                    setDegreeFiltersEnabled(false);
                }

// First, show all nodes and edges (batch update)
                const allNodeUpdates = [];
                nodes.forEach(node => {
                    allNodeUpdates.push({id: node.id, hidden: false});
                });
                
                const allEdgeUpdates = [];
                edges.forEach(edge => {
                    allEdgeUpdates.push({id: edge.id, hidden: false});
                });
                
                nodes.update(allNodeUpdates);
                edges.update(allEdgeUpdates);
                
                // If in user-centric mode, apply user filtering first (batch update)
                if (isUserCentric && selectedUserId) {
                    // Hide all nodes except the selected user
                    const userCentricNodeUpdates = [];
                    nodes.forEach(node => {
                        userCentricNodeUpdates.push({
                            id: node.id, 
                            hidden: node.id !== selectedUserId
                        });
                    });
                    
                    // Hide all edges initially
                    const userCentricEdgeUpdates = [];
                    edges.forEach(edge => {
                        userCentricEdgeUpdates.push({id: edge.id, hidden: true});
                    });
                    
                    nodes.update(userCentricNodeUpdates);
                    edges.update(userCentricEdgeUpdates);
                    
                    // Degree filtering is now handled in the timeline filtering section below
                }
                
                // Apply timeline filtering (or show all connections at 100%)
                const timelinePercentage = (endPercentage - startPercentage) * 100;
                console.log(`ðŸ” DEBUG: Timeline percentage check - startPercentage: ${startPercentage}, endPercentage: ${endPercentage}, calculated timelinePercentage: ${timelinePercentage}, isUserCentric: ${isUserCentric}, selectedUserId: ${selectedUserId}`);
                if (timelinePercentage < 100) {
                    console.log(`ðŸ” DEBUG: Taking percentage < 100 path`);
                    // Create edge ID mapping
                    const edgeMapping = createEdgeIdMapping();
                    
                    // Create a set of edges that should be visible based on timeline
                    const visibleEdgeIds = new Set();
                    for (let i = 0; i < eventIndex; i++) {
                        const event = timeSequence[i];
                        // Map time sequence edge to graph edge using user1/user2
                        const key = `${event.user1_id}-${event.user2_id}`;
                        const reverseKey = `${event.user2_id}-${event.user1_id}`;
                        
                        const graphEdgeId = edgeMapping.get(key) || edgeMapping.get(reverseKey);
                        if (graphEdgeId !== undefined) {
                            visibleEdgeIds.add(graphEdgeId);
                        }
                        

                    }
                    

                    
                                            // If in user-centric mode, only hide edges that are both:
                        // 1. Not in the timeline visible set AND
                        // 2. Not part of the user's degree-filtered connections
                        if (isUserCentric && selectedUserId) {
                            console.log(`ðŸ” DEBUG: Entering nested user-centric mode for edge processing...`);
                            // Get the user's degree-filtered connections
                            const userNode = allNodes[selectedUserId];
                            const profileData = userNode.profile_data;
                            const degree1Connections = profileData.degree_1_connections || [];
                            const degree2Connections = profileData.degree_2_connections || [];
                            const degree3Connections = profileData.degree_3_connections || [];
                            
                            const degree1Enabled = document.getElementById('degree1').checked;
                            const degree2Enabled = document.getElementById('degree2').checked;
                            const degree3Enabled = document.getElementById('degree3').checked;
                            
                            // Collect degree-filtered connections based on actual user selections
                            const degreeFilteredConnections = new Set();
                            
                            // Always include the selected user themselves
                            degreeFilteredConnections.add(selectedUserId);
                            
                            // Add connections based on what degrees are actually enabled
                                if (degree1Enabled) {
                                    degree1Connections.forEach(connId => degreeFilteredConnections.add(connId));
                                }
                                if (degree2Enabled) {
                                    degree2Connections.forEach(connId => degreeFilteredConnections.add(connId));
                                }
                                if (degree3Enabled) {
                                    degree3Connections.forEach(connId => degreeFilteredConnections.add(connId));
                            }
                        
                        
                        // Hide edges that are not in timeline AND not in degree filter
                        let hiddenCount = 0;
                        
                        // NEW TIMELINE RULE: When timeline < 100%, show all degrees automatically
                        // For timeline < 100%, build connected component starting from selected user
                        let connectedComponent = null;
                        if (percentage < 100) {
                            connectedComponent = new Set([selectedUserId]);
                            const queue = [selectedUserId];
                            
                            // BFS to find all nodes reachable from selected user within degree-filtered connections
                            while (queue.length > 0) {
                                const current = queue.shift();
                                Object.values(allEdges).forEach(edge => {
                                    // Only consider edges that are in the timeline
                                    if (!visibleEdgeIds.has(edge.id)) return;
                                    
                                    let neighbor = null;
                                    if (edge.from === current && degreeFilteredConnections.has(edge.to)) {
                                        neighbor = edge.to;
                                    } else if (edge.to === current && degreeFilteredConnections.has(edge.from)) {
                                        neighbor = edge.from;
                                    }
                                    
                                    if (neighbor && !connectedComponent.has(neighbor)) {
                                        connectedComponent.add(neighbor);
                                        queue.push(neighbor);
                                    }
                                });
                            }
                        }
                        
                        let timelineEdgeCount = 0;
                        let degreeFilterEdgeCount = 0;
                        let intersectionCount = 0;
                        
                        // Batch collect all edge updates for user-centric mode
                        console.log(`ðŸ” DEBUG: About to start edge thickness calculation...`);
                        const userCentricTimelineEdgeUpdates = [];
                        Object.values(allEdges).forEach(edge => {
                            const isInTimeline = visibleEdgeIds.has(edge.id);
                            
                            // Check if edge matches degree filter criteria
                            let isInDegreeFilter = false;
                            
                            // Simple node-based degree filtering: show edges between visible nodes
                            isInDegreeFilter = degreeFilteredConnections.has(edge.from) && degreeFilteredConnections.has(edge.to);
                            
                            if (isInTimeline) timelineEdgeCount++;
                            if (isInDegreeFilter) degreeFilterEdgeCount++;
                            if (isInTimeline && isInDegreeFilter) intersectionCount++;
                            
                            // Collect edge update for batch processing
                            const shouldShow = isInTimeline && isInDegreeFilter;
                            
                            // Calculate total tap count between these users within the timeline range
                            const user1Id = edge.from;
                            const user2Id = edge.to;
                            const timelineTapCount = filteredEvents.filter(tap => 
                                (tap.user1_id === user1Id && tap.user2_id === user2Id) ||
                                (tap.user1_id === user2Id && tap.user2_id === user1Id)
                            ).length;
                            
                            // Apply 5-segment styling based on timeline tap count
                            let thickness, color;
                            if (timelineTapCount === 1) {
                                thickness = 0.5;
                                color = "#E0E0E0"; // Light grey
                            } else if (timelineTapCount >= 2 && timelineTapCount <= 3) {
                                thickness = 1.5;
                                color = "#D0D0D0"; // Medium-light grey
                            } else if (timelineTapCount >= 4 && timelineTapCount <= 5) {
                                thickness = 2.5;
                                color = "#C0C0C0"; // Medium grey
                            } else if (timelineTapCount >= 6 && timelineTapCount <= 8) {
                                thickness = 3.5;
                                color = "#F0F0F0"; // Light white
                            } else if (timelineTapCount >= 9) {
                                thickness = 5.0;
                                color = "#FFFFFF"; // White
                            } else {
                                // Fallback for no taps or edge cases
                                thickness = 0.5;
                                color = "#E0E0E0";
                            }
                            
                            userCentricTimelineEdgeUpdates.push({
                                id: edge.id, 
                                hidden: !shouldShow,
                                width: thickness,
                                color: color
                            });
                            
                            if (!shouldShow) hiddenCount++;
                        });
                        
                        // Combine visibility and styling updates
                        const combinedEdgeUpdates = [];
                        Object.entries(allEdges).forEach(([edgeId, edge]) => {
                            const fromVisible = !allNodes[edge.from].hidden;
                            const toVisible = !allNodes[edge.to].hidden;
                            const inTimeRange = nodesInTimeRange.has(edge.from) && nodesInTimeRange.has(edge.to);
                            const shouldShow = fromVisible && toVisible && inTimeRange;
                            
                            // Find the styling update for this edge
                            const stylingUpdate = userCentricTimelineEdgeUpdates.find(update => update.id === edgeId);
                            
                            // Debug: Log styling update
                            if (stylingUpdate) {
                                console.log(`ðŸ” Edge ${edgeId}: Found styling update - width: ${stylingUpdate.width}, color: ${stylingUpdate.color}`);
                            } else {
                                console.log(`ðŸ” Edge ${edgeId}: No styling update found`);
                            }
                            
                            combinedEdgeUpdates.push({
                                id: edgeId,
                                hidden: !shouldShow,
                                width: stylingUpdate ? stylingUpdate.width : 0.5,
                                color: stylingUpdate ? stylingUpdate.color : "#E0E0E0"
                            });
                        });
                        
                        // Debug: Log userCentricTimelineEdgeUpdates
                        console.log(`ðŸ” userCentricTimelineEdgeUpdates length: ${userCentricTimelineEdgeUpdates.length}`);
                        console.log(`ðŸ” Sample userCentricTimelineEdgeUpdates:`, userCentricTimelineEdgeUpdates.slice(0, 3));
                        
                        // Apply all edge updates in batch
                        edges.update(userCentricTimelineEdgeUpdates);
                        
                        // Debug: Check what edges are being counted as degree-filtered
                        
                        // Debug: Log some of the visible edges to see what's being shown
                        const visibleEdges = edges.get().filter(edge => !edge.hidden);
                        console.log('Sample visible edges:', visibleEdges.slice(0, 5).map(edge => ({
                            from: edge.from,
                            to: edge.to,
                            isConnectedToSelected: edge.from === selectedUserId || edge.to === selectedUserId
                        })));
                        
                        // Debug: Check if any visible edges are NOT connected to selected user
                        const edgesNotConnectedToSelected = visibleEdges.filter(edge => 
                            edge.from !== selectedUserId && edge.to !== selectedUserId
                        );
                        console.log('Edges NOT connected to selected user:', edgesNotConnectedToSelected.length);
                        if (edgesNotConnectedToSelected.length > 0) {
                            console.log('Sample edges NOT connected to selected user:', edgesNotConnectedToSelected.slice(0, 3).map(edge => ({
                                from: edge.from,
                                to: edge.to
                            })));
                        }
                        
                        // Debug: Log degree filter details
                        

                        
                    } else {
                        // Global mode - combine visibility and styling updates
                        let hiddenCount = 0;
                        const globalModeEdgeUpdates = [];
                        Object.values(allEdges).forEach(edge => {
                            const shouldHide = !visibleEdgeIds.has(edge.id);
                            const inTimeRange = nodesInTimeRange.has(edge.from) && nodesInTimeRange.has(edge.to);
                            
                            // Calculate styling based on timeline tap count
                            const timelineTapCount = edge.tap_count || 1;
                            let thickness, color;
                            if (timelineTapCount === 1) {
                                thickness = 0.5;
                                color = "#E0E0E0";
                            } else if (timelineTapCount >= 2 && timelineTapCount <= 3) {
                                thickness = 1.5;
                                color = "#D0D0D0";
                            } else if (timelineTapCount >= 4 && timelineTapCount <= 5) {
                                thickness = 2.5;
                                color = "#C0C0C0";
                            } else if (timelineTapCount >= 6 && timelineTapCount <= 8) {
                                thickness = 3.5;
                                color = "#F0F0F0";
                            } else if (timelineTapCount >= 9) {
                                thickness = 5.0;
                                color = "#FFFFFF";
                            } else {
                                thickness = 0.5;
                                color = "#E0E0E0";
                            }
                            
                            globalModeEdgeUpdates.push({
                                id: edge.id, 
                                hidden: shouldHide,
                                width: thickness,
                                color: color
                            });
                            if (shouldHide) hiddenCount++;
                        });
                        edges.update(globalModeEdgeUpdates);
                    }
                    
                    // Hide nodes that don't have any visible connections
                    const visibleNodeIds = new Set();
                    
                    // Only add nodes from visible edges (this ensures nodes without connections are hidden)
                    edges.get().forEach(edge => {
                        if (!edge.hidden) {
                            visibleNodeIds.add(edge.from);
                            visibleNodeIds.add(edge.to);
                        }
                    });
                    
                    
                    // Debug: Check if selected user is in visible nodes
                    if (isUserCentric && selectedUserId) {
                    }
                    
                    // If in user-centric mode and no edges are visible, show the selected user
                    if (isUserCentric && selectedUserId && visibleNodeIds.size === 0) {
                        visibleNodeIds.add(selectedUserId);
                    }
                    
                    // Batch collect all node updates for visibility and properties
                    let hiddenNodeCount = 0;
                    const finalNodeUpdates = [];
                    nodes.forEach(node => {
                        const isVisible = visibleNodeIds.has(node.id);
                        if (!isVisible) hiddenNodeCount++;
                        
                        if (isVisible) {
                            const timelineProps = calculateTimelineNodeProperties(node.id, eventIndex);
                            finalNodeUpdates.push({
                                id: node.id, 
                                hidden: false,
                                size: timelineProps.size,
                                color: timelineProps.color,
                                font: { size: 12, face: 'Arial', color: '#ffffff' },
                                title: `${node.label} - ${timelineProps.taps} taps, ${timelineProps.connections} connections`
                            });
                        } else {
                            finalNodeUpdates.push({
                                id: node.id, 
                                hidden: true
                            });
                        }
                    });
                    
                    // Apply all node updates in batch
                    nodes.update(finalNodeUpdates);
                } else {
                    console.log(`ðŸ” DEBUG: Taking percentage >= 100 path (else block)`);
                    // At 100% timeline, show all degree-filtered connections
                        if (isUserCentric && selectedUserId) {
                            // Get the user's degree-filtered connections
                            const userNode = allNodes[selectedUserId];
                            const profileData = userNode.profile_data;
                            const degree1Connections = profileData.degree_1_connections || [];
                            const degree2Connections = profileData.degree_2_connections || [];
                            const degree3Connections = profileData.degree_3_connections || [];
                            
                            const degree1Enabled = document.getElementById('degree1').checked;
                            const degree2Enabled = document.getElementById('degree2').checked;
                            const degree3Enabled = document.getElementById('degree3').checked;
                            
                            // Collect all degree-filtered connections
                            const degreeFilteredConnections = new Set();
                            
                            // At 100% timeline, always use checkbox states
                            // Always include the selected user themselves
                            degreeFilteredConnections.add(selectedUserId);
                            
                            if (degree1Enabled) {
                                degree1Connections.forEach(connId => degreeFilteredConnections.add(connId));
                            }
                            if (degree2Enabled) {
                                degree2Connections.forEach(connId => degreeFilteredConnections.add(connId));
                            }
                            if (degree3Enabled) {
                                degree3Connections.forEach(connId => degreeFilteredConnections.add(connId));
                            }
                        
                        // Apply degree filtering to all edges (same logic for all timeline positions)
                        const hundredPercentEdgeUpdates = [];
                        Object.values(allEdges).forEach(edge => {
                            let isInDegreeFilter = false;
                            
                            // Simple node-based degree filtering: show edges between visible nodes
                            isInDegreeFilter = degreeFilteredConnections.has(edge.from) && degreeFilteredConnections.has(edge.to);
                            
                            hundredPercentEdgeUpdates.push({
                                id: edge.id, 
                                hidden: !isInDegreeFilter
                            });
                        });
                        edges.update(hundredPercentEdgeUpdates);
                        
                        // Show nodes that are part of the degree-filtered connections AND have visible edges (batch update)
                        let visibleNodeCount = 0;
                        const nodesWithVisibleEdges = new Set();
                        
                        // First, collect all nodes that have visible edges
                        edges.get().forEach(edge => {
                            if (!edge.hidden) {
                                nodesWithVisibleEdges.add(edge.from);
                                nodesWithVisibleEdges.add(edge.to);
                            }
                        });
                        
                        const hundredPercentNodeUpdates = [];
                        nodes.forEach(node => {
                            const shouldShow = node.id === selectedUserId || (degreeFilteredConnections.has(node.id) && nodesWithVisibleEdges.has(node.id));
                            hundredPercentNodeUpdates.push({
                                id: node.id, 
                                hidden: !shouldShow
                            });
                            if (shouldShow) visibleNodeCount++;
                        });
                        nodes.update(hundredPercentNodeUpdates);
                        
                        
                        // Update node properties based on timeline position and degree filters - batch update
                        const hundredPercentNodePropsUpdates = [];
                        nodes.forEach(node => {
                            if (node.id === selectedUserId || (degreeFilteredConnections.has(node.id) && nodesWithVisibleEdges.has(node.id))) {
                                const timelineProps = calculateTimelineNodeProperties(node.id, eventIndex); // Use current timeline position
                                hundredPercentNodePropsUpdates.push({
                                    id: node.id, 
                                    size: timelineProps.size,
                                    color: timelineProps.color,
                                    title: `${node.label} - ${timelineProps.taps} taps, ${timelineProps.connections} connections`
                                });
                            }
                        });
                        nodes.update(hundredPercentNodePropsUpdates);
                    } else {
                        // Global mode at 100% timeline - show all nodes and edges with full timeline properties
                        
                        // Show all edges with timeline-based styling (batch update)
                        const globalModeEdgeUpdates = [];
                        Object.values(allEdges).forEach(edge => {
                            // Calculate total tap count between these users within the timeline range
                            const user1Id = edge.from;
                            const user2Id = edge.to;
                            const timelineTapCount = filteredEvents.filter(tap => 
                                (tap.user1_id === user1Id && tap.user2_id === user2Id) ||
                                (tap.user1_id === user2Id && tap.user2_id === user1Id)
                            ).length;
                            
                            // Apply 5-segment styling based on timeline tap count
                            let thickness, color;
                            if (timelineTapCount === 1) {
                                thickness = 0.5;
                                color = "#E0E0E0"; // Light grey
                            } else if (timelineTapCount >= 2 && timelineTapCount <= 3) {
                                thickness = 1.5;
                                color = "#D0D0D0"; // Medium-light grey
                            } else if (timelineTapCount >= 4 && timelineTapCount <= 5) {
                                thickness = 2.5;
                                color = "#C0C0C0"; // Medium grey
                            } else if (timelineTapCount >= 6 && timelineTapCount <= 8) {
                                thickness = 3.5;
                                color = "#F0F0F0"; // Light white
                            } else if (timelineTapCount >= 9) {
                                thickness = 5.0;
                                color = "#FFFFFF"; // White
                            } else {
                                // Fallback for no taps or edge cases
                                thickness = 0.5;
                                color = "#E0E0E0";
                            }
                            
                            globalModeEdgeUpdates.push({
                                id: edge.id, 
                                hidden: false,
                                width: thickness,
                                color: color
                            });
                        });
                        edges.update(globalModeEdgeUpdates);
                        
                        // Show all nodes and update properties (batch update)
                        const globalModeNodeUpdates = [];
                        nodes.forEach(node => {
                            const timelineProps = calculateTimelineNodeProperties(node.id, timeSequence.length); // Full timeline
                            globalModeNodeUpdates.push({
                                id: node.id, 
                                hidden: false,
                                size: timelineProps.size,
                                color: timelineProps.color,
                                font: { size: 12, face: 'Arial', color: '#ffffff' },
                                title: `${node.label} - ${timelineProps.taps} taps, ${timelineProps.connections} connections`
                            });
                        });
                        nodes.update(globalModeNodeUpdates);
                    }
                }
                
                // Apply edge thickness calculation regardless of timeline percentage
                console.log(`ðŸ” DEBUG: About to start edge thickness calculation...`);
                const edgeThicknessUpdates = [];
                Object.values(allEdges).forEach(edge => {
                    // Calculate total tap count between these users within the timeline range
                    const user1Id = edge.from;
                    const user2Id = edge.to;
                    const timelineTapCount = filteredEvents.filter(tap => 
                        (tap.user1_id === user1Id && tap.user2_id === user2Id) ||
                        (tap.user1_id === user2Id && tap.user2_id === user1Id)
                    ).length;
                    
                    // Apply 5-segment styling based on timeline tap count
                    let thickness, color;
                    if (timelineTapCount === 1) {
                        thickness = 0.5;
                        color = "#E0E0E0"; // Light grey
                    } else if (timelineTapCount >= 2 && timelineTapCount <= 3) {
                        thickness = 1.5;
                        color = "#D0D0D0"; // Medium-light grey
                    } else if (timelineTapCount >= 4 && timelineTapCount <= 5) {
                        thickness = 2.5;
                        color = "#C0C0C0"; // Medium grey
                    } else if (timelineTapCount >= 6 && timelineTapCount <= 8) {
                        thickness = 3.5;
                        color = "#F0F0F0"; // Light white
                    } else if (timelineTapCount >= 9) {
                        thickness = 5.0;
                        color = "#FFFFFF"; // White
                    } else {
                        // Fallback for no taps or edge cases
                        thickness = 0.5;
                        color = "#E0E0E0";
                    }
                    
                    edgeThicknessUpdates.push({
                        id: edge.id,
                        width: thickness,
                        color: color
                    });
                });
                
                // Apply edge thickness updates
                if (edgeThicknessUpdates.length > 0) {
                    edges.update(edgeThicknessUpdates);
                    console.log(`ðŸ” DEBUG: Applied edge thickness updates to ${edgeThicknessUpdates.length} edges`);
                }
                
                // Update display information
                if (eventIndex > 0) {
                    const currentEvent = timeSequence[eventIndex - 1];
                    const formattedDate = formatTimestamp(currentEvent.time);
                    document.getElementById('currentTime').textContent = formattedDate;
                } else {
                    document.getElementById('currentTime').textContent = 'No connections shown';
                }
                
                // Update profile stats if a user is selected
                if (isUserCentric && selectedUserId) {
                    updateProfileStats(selectedUserId, eventIndex);
                }
                
                // Count visible nodes (users)
                const visibleNodeCount = nodes.get().filter(node => !node.hidden).length;
                
                // Debug: Check if elements exist
                const connectionCountElement = document.getElementById('connectionCount');
                
                if (connectionCountElement) {
                    connectionCountElement.textContent = `${visibleNodeCount} total users`;
                } else {
                    console.error('Connection count element not found!');
                }
                
                
                // Reset update flag and allow smooth transitions
                setTimeout(() => {
                    isUpdating = false;
                    // Re-apply edge highlighting after timeline updates
                    reapplyHighlighting();
                }, 50); // Small delay to ensure smooth transitions
            }
            
            function applyDegreeFilterForUser(userId) {
                // Get the user's profile data
                const userNode = allNodes[userId];
                if (!userNode || !userNode.profile_data) return;
                
                const profileData = userNode.profile_data;
                const degree1Connections = profileData.degree_1_connections || [];
                const degree2Connections = profileData.degree_2_connections || [];
                const degree3Connections = profileData.degree_3_connections || [];
                
                // Get current degree filter settings
                const degree1Enabled = document.getElementById('degree1').checked;
                const degree2Enabled = document.getElementById('degree2').checked;
                const degree3Enabled = document.getElementById('degree3').checked;
                

                
                // Show connections based on degree filter
                const connectionsToShow = [];
                
                if (degree1Enabled) {
                    connectionsToShow.push(...degree1Connections);
                }
                if (degree2Enabled) {
                    connectionsToShow.push(...degree2Connections);
                }
                if (degree3Enabled) {
                    connectionsToShow.push(...degree3Connections);
                }
                
                // Show the selected user's connections
                connectionsToShow.forEach(connectionId => {
                    nodes.update({id: connectionId, hidden: false});
                    visibleNodes.add(connectionId);
                });
                
                // Show edges between the selected user and their connections
                edges.forEach(edge => {
                    if ((edge.from === userId && connectionsToShow.includes(edge.to)) ||
                        (edge.to === userId && connectionsToShow.includes(edge.from))) {
                        edges.update({id: edge.id, hidden: false});
                        visibleEdges.add(edge.id);
                    }
                });
            }
            

            
            // Detect iframe context and add class for mobile adjustments
            function detectIframeContext() {
                if (window !== window.top) {
                    document.body.classList.add('iframe-context');
                    console.log('ðŸ”— Iframe context detected - applying mobile control adjustments');
                }
            }
            
            // Initialize everything when the page loads
            document.addEventListener('DOMContentLoaded', async function() {
                detectIframeContext();
                console.log('ðŸ“± DOMContentLoaded event fired - starting initialization');
                // Initialize network (which will load data)
                await initNetwork();
                initSearch();
                initExpandableSearch();
                initTimelineSlider();
                
                // Check for userName parameter and auto-select user
                const urlParams = new URLSearchParams(window.location.search);
                const userName = urlParams.get('userName');
                if (userName) {
                    console.log('ðŸŽ¯ Auto-selecting user from URL:', userName);
                    // Simulate typing in search and selecting the user
                    setTimeout(() => {
                        const searchInput = document.getElementById('searchInput');
                        if (searchInput) {
                            searchInput.value = userName;
                            // Trigger search
                            searchInput.dispatchEvent(new Event('input', { bubbles: true }));
                            // After a brief delay, select the first result (should be the user)
                            setTimeout(() => {
                                const searchResults = document.getElementById('searchResults');
                                const firstResult = searchResults.querySelector('.search-result-item');
                                if (firstResult) {
                                    firstResult.click();
                                }
                            }, 500);
                        }
                    }, 2000); // Wait longer for network to stabilize
                }
                
                // Add degree filter event listeners
                document.getElementById('degree1').addEventListener('change', function() {
                    currentDegreeFilter[1] = this.checked;
                    if (currentFilterUser) {
                        // Use current timeline range instead of single position
                        const leftSlider = document.getElementById('timelineSliderLeft');
                        const rightSlider = document.getElementById('timelineSliderRight');
                        if (leftSlider && rightSlider) {
                            const leftValue = parseInt(leftSlider.value);
                            const rightValue = parseInt(rightSlider.value);
                            updateDualTimelineDisplay(leftValue, rightValue);
                        }
                    } else if (selectedNode) {
                        displayConnections(selectedNode);
                    }
                });
                
                document.getElementById('degree2').addEventListener('change', function() {
                    currentDegreeFilter[2] = this.checked;
                    // Ensure 1st degree is checked if 2nd degree is checked
                    if (this.checked && !currentDegreeFilter[1]) {
                        currentDegreeFilter[1] = true;
                        document.getElementById('degree1').checked = true;
                    }
                    if (currentFilterUser) {
                        // Use current timeline range instead of single position
                        const leftSlider = document.getElementById('timelineSliderLeft');
                        const rightSlider = document.getElementById('timelineSliderRight');
                        if (leftSlider && rightSlider) {
                            const leftValue = parseInt(leftSlider.value);
                            const rightValue = parseInt(rightSlider.value);
                            updateDualTimelineDisplay(leftValue, rightValue);
                        }
                    } else if (selectedNode) {
                        displayConnections(selectedNode);
                    }
                });
                
                document.getElementById('degree3').addEventListener('change', function() {
                    currentDegreeFilter[3] = this.checked;
                    // Ensure 1st and 2nd degree are checked if 3rd degree is checked
                    if (this.checked && (!currentDegreeFilter[1] || !currentDegreeFilter[2])) {
                        currentDegreeFilter[1] = true;
                        currentDegreeFilter[2] = true;
                        document.getElementById('degree1').checked = true;
                        document.getElementById('degree2').checked = true;
                    }
                    if (currentFilterUser) {
                        // Use current timeline range instead of single position
                        const leftSlider = document.getElementById('timelineSliderLeft');
                        const rightSlider = document.getElementById('timelineSliderRight');
                        if (leftSlider && rightSlider) {
                            const leftValue = parseInt(leftSlider.value);
                            const rightValue = parseInt(rightSlider.value);
                            updateDualTimelineDisplay(leftValue, rightValue);
                        }
                    } else if (selectedNode) {
                        displayConnections(selectedNode);
                    }
                });
                
                // Add chat event listeners
                const chatInput = document.getElementById('chatInput');
                
                chatInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        sendMessage();
                    }
                });
                
                // Auto-expand when input is focused
                chatInput.addEventListener('focus', function() {
                    expandChatBar();
                });
                
                // Initialize chat input bar in collapsed state
                const chatInputBar = document.getElementById('chatInputBar');
                chatInputBar.classList.remove('expanded');
                
                // Add drag event listeners only to the input container (top bar)
                const inputContainer = chatInputBar.querySelector('.input-container');
                if (inputContainer) {
                    inputContainer.addEventListener('mousedown', startDrag);
                    inputContainer.style.cursor = 'move';
                }
                document.addEventListener('mousemove', drag);
                document.addEventListener('mouseup', stopDrag);
                
                // Function to prevent wheel events from bubbling to network (allow scrolling, prevent zoom)
                function preventWheelEvent(e) {
                    // Allow scrolling on search results and other scrollable elements
                    const target = e.target;
                    const isScrollableElement = target.closest('.search-results') || 
                                              target.closest('.connections-list') ||
                                              target.closest('.chat-messages') ||
                                              target.closest('[style*="overflow"]') ||
                                              target.closest('.controls-section') ||
                                              target.closest('.profile-section') ||
                                              target.closest('.animation-section') ||
                                              target.closest('.search-section') ||
                                              target.closest('.global-view-section') ||
                                              target.closest('.control-group') ||
                                              target.closest('.degree-filter-section');
                    
                    if (isScrollableElement) {
                        // Allow normal scrolling, just prevent zoom
                        e.stopPropagation();
                        return; // Don't prevent default for scrollable elements
                    }
                    
                    // For other elements, prevent both zoom and scroll
                    e.stopPropagation();
                    e.preventDefault();
                }
                
                // Prevent wheel zoom on sidebar and chatbox
                const sidebar = document.querySelector('.sidebar');
                
                // Add event listeners to prevent zoom on UI elements
                if (sidebar) {
                    sidebar.addEventListener('wheel', preventWheelEvent, { passive: false });
                    // Also prevent on all child elements
                    const sidebarElements = sidebar.querySelectorAll('*');
                    sidebarElements.forEach(element => {
                        element.addEventListener('wheel', preventWheelEvent, { passive: false });
                    });
                }
                
                // Prevent wheel events on chatbox input area and expanded chat messages area
                if (chatInputBar) {
                    chatInputBar.addEventListener('wheel', preventWheelEvent, { passive: false });
                    // Also prevent on all child elements
                    const chatElements = chatInputBar.querySelectorAll('*');
                    chatElements.forEach(element => {
                        element.addEventListener('wheel', preventWheelEvent, { passive: false });
                    });
                }
                
                // Prevent wheel events on other UI elements
                const header = document.querySelector('.header');
                const searchSection = document.querySelector('.search-section');
                const loadingContainer = document.getElementById('loadingContainer');
                
                // Prevent wheel events on header
                if (header) {
                    header.addEventListener('wheel', preventWheelEvent, { passive: false });
                }
                
                // Prevent wheel events on search section
                if (searchSection) {
                    searchSection.addEventListener('wheel', preventWheelEvent, { passive: false });
                }
                
                // Prevent wheel events on loading container
                if (loadingContainer) {
                    loadingContainer.addEventListener('wheel', preventWheelEvent, { passive: false });
                }
                
                // Prevent zoom at document level
                document.addEventListener('wheel', function(e) {
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                    }
                }, { passive: false });

                // COMPUTED STYLE AUDIT FUNCTIONS
                function dumpComputed(el) {
                    if (!el) return { node: 'NOT_FOUND', error: 'Element not found' };
                    const cs = getComputedStyle(el);
                    return {
                        node: el.className || el.id || el.tagName,
                        width: el.clientWidth, 
                        height: el.clientHeight,
                        fontFamily: cs.fontFamily, 
                        fontSize: cs.fontSize, 
                        lineHeight: cs.lineHeight,
                        letterSpacing: cs.letterSpacing, 
                        boxSizing: cs.boxSizing,
                        padding: `${cs.paddingTop} ${cs.paddingRight} ${cs.paddingBottom} ${cs.paddingLeft}`,
                        margin: `${cs.marginTop} ${cs.marginRight} ${cs.marginBottom} ${cs.marginLeft}`,
                        border: `${cs.borderTopWidth} ${cs.borderRightWidth} ${cs.borderBottomWidth} ${cs.borderLeftWidth}`,
                        transform: cs.transform,
                        zoom: cs.zoom,
                        minWidth: cs.minWidth
                    };
                }

                function auditAncestors(el) {
                    const chain = [];
                    while (el) {
                        const cs = getComputedStyle(el);
                        chain.push({
                            node: el.id || el.className || el.tagName,
                            fontSize: cs.fontSize, 
                            lineHeight: cs.lineHeight, 
                            letterSpacing: cs.letterSpacing,
                            boxSizing: cs.boxSizing, 
                            transform: cs.transform, 
                            zoom: cs.zoom,
                            minWidth: cs.minWidth, 
                            width: cs.width,
                            height: cs.height
                        });
                        el = el.parentElement;
                    }
                    return chain;
                }

                function runStyleAudit() {
                    // Style audit function - debugging logs removed for production
                }

                // Run audit after profile section becomes visible
                function runAuditWhenReady() {
                    const profileSection = document.querySelector('.profile-section');
                    const profileName = document.querySelector('#profileName');
                    const statCard = document.querySelector('.stat-card');
                    
                    console.log('ðŸ” 10TH BEDROCK - AUDIT CHECK:', {
                        profileSection: !!profileSection,
                        profileSectionDisplay: profileSection ? profileSection.style.display : 'not found',
                        profileName: !!profileName,
                        profileNameWidth: profileName ? profileName.offsetWidth : 'not found',
                        statCard: !!statCard,
                        statCardWidth: statCard ? statCard.offsetWidth : 'not found'
                    });
                    
                    if (profileSection && profileSection.style.display !== 'none' && 
                        profileName && profileName.offsetWidth > 0 && 
                        statCard && statCard.offsetWidth > 0) {
                        console.log('âœ… 10TH BEDROCK - Running audit now');
                        runStyleAudit();
                    } else {
                        console.log('â³ 10TH BEDROCK - Retrying audit in 500ms');
                        // Retry every 500ms until elements are visible
                        setTimeout(runAuditWhenReady, 500);
                    }
                }

                // Add audit call to selectNode function after function definitions
                const originalSelectNode = selectNode;
                selectNode = function(nodeId) {
                    const result = originalSelectNode.call(this, nodeId);
                    
                    // Run audit after profile section becomes visible
                    setTimeout(() => {
                        console.log('ðŸ” 10TH BEDROCK - Profile section shown, running audit');
                        runStyleAudit();
                    }, 100);
                    
                    return result;
                };

                // Start checking after page loads
                window.addEventListener('load', () => {
                    setTimeout(runAuditWhenReady, 1000);
                    // Fallback: run audit after 5 seconds regardless
                    setTimeout(() => {
                        console.log('ðŸ”„ 10TH BEDROCK - Fallback audit after 5 seconds');
                        runStyleAudit();
                    }, 5000);
                });
                
                // Add comprehensive debugging for minimize button
                const minimizeButton = document.getElementById('minimizeButton');
                if (minimizeButton) {
                    
                    // Test hover detection
                    minimizeButton.addEventListener('mouseenter', function(e) {
                        e.stopPropagation();
                    });
                    
                    minimizeButton.addEventListener('mouseleave', function(e) {
                        e.stopPropagation();
                    });
                    
                    // Test mousedown detection
                    minimizeButton.addEventListener('mousedown', function(e) {
                        console.log('ðŸ–±ï¸ MOUSEDOWN DETECTED on minimize button');
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    });
                    
                    // Test click detection
                    minimizeButton.addEventListener('click', function(e) {
                        console.log('ðŸ–±ï¸ CLICK DETECTED on minimize button');
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        collapseChatBar();
                    });
                    
                    // Test if button is actually visible and positioned correctly
                    setTimeout(() => {
                        const rect = minimizeButton.getBoundingClientRect();
                        const style = window.getComputedStyle(minimizeButton);
                        
                        
                        // Test if we can detect mouse events on the button area
                        document.addEventListener('mousemove', function(e) {
                            const buttonRect = minimizeButton.getBoundingClientRect();
                            if (e.clientX >= buttonRect.left && e.clientX <= buttonRect.right &&
                                e.clientY >= buttonRect.top && e.clientY <= buttonRect.bottom) {
                            }
                        });
                    }, 1000);
                    
                } else {
                }
                
                // Test if collapseChatBar function exists
            });

            // ========================================
            // MOBILE RESPONSIVE FUNCTIONS
            // ========================================
            
            function toggleMobileSidebar() {
                const sidebar = document.querySelector('.sidebar');
                const hamburger = document.getElementById('mobileHamburger');
                
                if (sidebar.classList.contains('show')) {
                    sidebar.classList.remove('show');
                    hamburger.classList.remove('active');
                    // Notify parent that control panel is closed
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'controlPanelState',
                            isOpen: false
                        }, '*');
                    }
                } else {
                    sidebar.classList.add('show');
                    hamburger.classList.add('active');
                    // Notify parent that control panel is open
                    if (window.parent) {
                        window.parent.postMessage({
                            type: 'controlPanelState',
                            isOpen: true
                        }, '*');
                    }
                }
            }
            
            // Mobile resize functionality
            function initResize() {
                // Check screen size immediately and only proceed if mobile
                const isMobile = window.matchMedia('(max-width: 900px)').matches;
                const screenWidth = window.innerWidth;
                
                
                // Don't run mobile resize if iframe is still loading (screenWidth: 0)
                if (screenWidth === 0) {
                    console.log('ðŸ”„ Iframe still loading - skipping mobile resize initialization');
                    return;
                }
                
                if (!isMobile) {
                    return;
                }
                
                console.log('ðŸ“± Mobile detected - initializing resize functionality');
                const sidebar = document.querySelector('.sidebar');
                const resizeHandle = document.getElementById('resizeHandle');
                
                if (!sidebar || !resizeHandle) return;
                
                // Load saved height or use default
                const savedHeight = localStorage.getItem('mobileSidebarHeight');
                if (savedHeight) {
                    sidebar.style.setProperty('height', savedHeight, 'important');
                    sidebar.style.setProperty('bottom', 'auto', 'important');
                } else {
                    // Set initial height to 50% if no saved preference
                    sidebar.style.setProperty('height', '50%', 'important');
                    sidebar.style.setProperty('bottom', 'auto', 'important');
                }
                
                // Position drag bar at bottom of control panel
                const positionDragBar = () => {
                    const sidebarRect = sidebar.getBoundingClientRect();
                    const handleTop = sidebarRect.bottom - 40; // 40px is handle height
                    resizeHandle.style.setProperty('top', handleTop + 'px', 'important');
                    resizeHandle.style.setProperty('bottom', 'auto', 'important');
                };
                
                // Position initially and on resize
                positionDragBar();
                window.addEventListener('resize', positionDragBar);
                
                // Touch events for drag handle
                resizeHandle.addEventListener('touchstart', handleResizeStart, { passive: false });
                resizeHandle.addEventListener('touchmove', handleResizeMove, { passive: false });
                resizeHandle.addEventListener('touchend', handleResizeEnd, { passive: false });
            }
            
            function handleResizeStart(e) {
                // Only work on mobile screens
                if (!window.matchMedia('(max-width: 900px)').matches) return;
                
                isMobileResizing = true;
                mobileStartY = e.touches[0].clientY;
                const sidebar = document.querySelector('.sidebar');
                
                // Get current height from computed style or inline style
                const currentHeight = sidebar.style.height || getComputedStyle(sidebar).height;
                mobileStartHeight = currentHeight ? parseFloat(currentHeight) : 50; // Default to 50% if no height set
                
                // Prevent scrolling and other touch events
                e.preventDefault();
                e.stopPropagation();
            }
            
            function handleResizeMove(e) {
                if (!isMobileResizing) return;
                
                const currentY = e.touches[0].clientY;
                const deltaY = currentY - mobileStartY; // Direct: drag down = expand down
                
                // Scale down sensitivity for 1:1 feel (divide by 10 for smoother control)
                const scaledDelta = deltaY / 10;
                const newHeight = Math.max(5, Math.min(95, mobileStartHeight + scaledDelta));
                
                const sidebar = document.querySelector('.sidebar');
                const resizeHandle = document.getElementById('resizeHandle');
                
                // Override CSS with !important to ensure JavaScript controls height
                sidebar.style.setProperty('height', newHeight + '%', 'important');
                sidebar.style.setProperty('bottom', 'auto', 'important');
                
                // Position drag bar at bottom of control panel
                const sidebarRect = sidebar.getBoundingClientRect();
                const handleTop = sidebarRect.bottom - 40; // 40px is handle height
                resizeHandle.style.setProperty('top', handleTop + 'px', 'important');
                resizeHandle.style.setProperty('bottom', 'auto', 'important');
                
                // Prevent scrolling and other touch events
                e.preventDefault();
                e.stopPropagation();
            }
            
            function handleResizeEnd(e) {
                if (!isMobileResizing) return;
                
                isMobileResizing = false;
                const sidebar = document.querySelector('.sidebar');
                const finalHeight = sidebar.style.height;
                
                // Save the height preference
                localStorage.setItem('mobileSidebarHeight', finalHeight);
                
                // Prevent scrolling and other touch events
                e.preventDefault();
                e.stopPropagation();
            }
            
            
            
            // Initialize resize on DOM load
            document.addEventListener('DOMContentLoaded', initResize);
        </script>
    </body>
    </html>
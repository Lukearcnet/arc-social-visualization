<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ARC Social Network - Geographic Map</title>
    
    <!-- Leaflet.js CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    
    <!-- Leaflet.draw CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" crossorigin=""/>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js" crossorigin=""></script>
    
    <!-- Leaflet-Geoman CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.css" crossorigin=""/>
    <script src="https://unpkg.com/@geoman-io/leaflet-geoman-free@latest/dist/leaflet-geoman.min.js" crossorigin=""></script>
    
    <!-- Bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js" integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf" crossorigin="anonymous"></script>
    
    <style>
        /* CSS Custom Properties - Normalized from bedrock 5 */
        :root {
            --space-1: 8px;
            --space-2: 12px;
            --space-3: 16px;
            --space-4: 20px;
            --radius-1: 6px;
            --radius-2: 8px;
            --radius-3: 10px;
            --fg: #ffffff;
            --fg-muted: #cccccc;
            --bg-1: #000000;
            --bg-2: #141414;
            --bg-3: #1c1c1c;
            --bg-4: #2a2a2a;
            --stroke: rgba(255, 255, 255, 0.1);
            --stroke-muted: rgba(255, 255, 255, 0.2);
            --text-sm: 0.8rem;
            --text-md: 0.9rem;
            --text-lg: 1rem;
            --text-xl: 1.25rem;
            --text-2xl: 1.5rem;
        }
        
        /* Modern CSS Reset and Base Styles */
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 0;
            background: var(--bg-1);
            min-height: 100vh;
            color: var(--fg);
            line-height: 1.6;
        }
        
        /* CSS Grid Layout - Normalized for localhost */
        html, body, .main-container {
            height: 100%;
            margin: 0;
        }
        
        .main-container {
            display: grid;
            /* exact match at common desktop widths, no clipping */
            grid-template-columns: 380px 1fr;
            grid-template-rows: 100%;
            height: 100vh;
            background: #000000;
        }
        
        /* Guardrails - No transforms on layout containers */
        html, body, .main-container, .map-container, #map {
            transform: none !important;
        }
        
        /* Sidebar - Normalized from bedrock 5 */
        .sidebar {
            width: auto;
            box-sizing: border-box;
            overflow: auto;
            padding: 0 16px 16px 16px; /* Remove top padding to eliminate gray gap */
            min-width: 0; /* allow content to wrap */
            background: rgba(20, 20, 20, 0.98);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(64, 64, 64, 0.8);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .map-container {
            position: relative;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }
        
        /* Floating Map Controls - Top Right */
        .map-controls-floating {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .map-controls-floating .control-btn {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--fg);
            padding: 8px 12px;
            border-radius: var(--radius-1);
            font-size: var(--text-sm);
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            min-width: 100px;
        }
        
        .map-controls-floating .control-btn:hover {
            background: rgba(40, 40, 40, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        /* Search Control - Separate Container */
        .search-control-floating {
            position: absolute;
            top: 108px; /* Move up 6px from 114px for better positioning */
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        
        /* Drawing Control - Below Search */
        .drawing-control-floating {
            position: absolute;
            top: 156px; /* Below search button with 8px gap (108px + 40px button height + 8px gap) */
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }
        
        .search-control-floating .search-toggle-btn {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--fg);
            border-radius: var(--radius-1);
            cursor: pointer;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px !important;
            min-width: auto !important;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .search-control-floating .search-toggle-btn:hover {
            background: rgba(40, 40, 40, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        /* Drawing button in its own container */
        .drawing-control-floating .drawing-toggle-btn {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--fg);
            border-radius: var(--radius-1);
            cursor: pointer;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            padding: 8px;
            min-width: auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .drawing-control-floating .drawing-toggle-btn:hover {
            background: rgba(40, 40, 40, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .drawing-toggle-btn.active {
            background: rgba(0, 123, 255, 0.9);
            border-color: rgba(0, 123, 255, 0.6);
        }
        
        /* Mobile drawing mode - disable touch gestures */
        #map.drawing-mode {
            touch-action: none;
        }
        
        /* Portal Dropdown Styles (reused from community page) */
        .portal-root {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .portal-dropdown {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 9px;
            box-shadow: 0 3px 9px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            max-height: 150px;  /* Reduced from 300px to 150px (50%) */
            overflow-y: auto;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            min-width: 100px;  /* Reduced from 200px to 100px (50%) */
            width: 200px;      /* Set fixed width for consistency */
        }

        /* Mobile responsive dropdown */
        @media (max-width: 768px) {
            .portal-dropdown {
                left: var(--space-4) !important;
                right: var(--space-4) !important;
            }
        }

        .degree-user-item {
            padding: 6px 8px;  /* Reduced from var(--space-3) which is 16px */
            border-bottom: 1px solid var(--stroke);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s ease;
            font-size: 0.75rem;  /* Smaller text size */
        }

        .degree-user-item:hover {
            background: var(--bg-tertiary);
        }

        .degree-user-item:last-child {
            border-bottom: none;
        }

        .user-name {
            font-weight: 500;
            color: var(--fg-primary);
            font-size: 0.75rem;  /* Smaller text size */
        }

        .user-meta {
            font-size: 0.65rem;  /* Even smaller for meta text */
            color: var(--fg-muted);
        }
        
        /* Custom styling for Leaflet.draw edit handles */
        /* Center move handle - transparent circle matching original circle size */
        .leaflet-editing-icon.leaflet-edit-move {
            background-color: transparent !important;
            border: 1px dashed rgba(0, 123, 255, 0.1) !important;
            border-radius: 50% !important;
            /* Size will be set dynamically by JavaScript */
            pointer-events: all !important;
        }
        
        /* Resize handle - accent blue circle */
        .leaflet-editing-icon.leaflet-edit-resize {
            background-color: rgba(0, 123, 255, 0.9) !important;
            border: 2px solid rgba(0, 123, 255, 0.6) !important;
            border-radius: 50% !important;
            width: 12px !important;
            height: 12px !important;
            margin-left: -6px !important;
            margin-top: -6px !important;
        }
        
        /* Hover states for better UX */
        .leaflet-editing-icon.leaflet-edit-resize:hover {
            background-color: rgba(0, 123, 255, 1) !important;
            border-color: rgba(0, 123, 255, 0.8) !important;
            transform: scale(1.2);
            cursor: pointer;
        }
        
        .leaflet-editing-icon.leaflet-edit-move:hover {
            border-color: rgba(0, 123, 255, 0.6) !important;
            cursor: move;
        }
        
        /* Custom freehand drawing cursor styles */
        .leaflet-container.drawing-mode {
            cursor: crosshair !important;
        }
        
        .leaflet-container.drawing-mode.drawing-active {
            cursor: crosshair !important;
        }
        
        /* Force hide Geoman toolbar completely */
        .leaflet-pm-toolbar {
            display: none !important;
            visibility: hidden !important;
        }
        
        .leaflet-control-layers {
            display: none !important;
        }
        
        .search-toggle-btn svg {
            width: 16px;
            height: 16px;
            transition: opacity 0.2s ease;
        }
        
        /* Search button expanded state - use width/opacity instead of transform */
        .search-toggle-btn.expanded {
            width: 300px;
            min-width: 300px !important;
            max-width: 300px !important;
            padding: 8px 12px !important;
            justify-content: flex-start;
            z-index: 1001;
            /* Ensure no transforms on expanded state */
            transform: none !important;
        }
        
        /* While the input is visible/focused, guarantee no transforms up the chain */
        .search-toggle-btn.expanded,
        .search-toggle-btn.expanded * {
            transform: none !important;
        }
        
        .search-toggle-btn.expanded svg {
            opacity: 0;
        }
        
        /* Hidden input field that appears when expanded */
        .search-toggle-btn .search-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            padding: 8px 12px;
            border: none;
            background: transparent;
            color: var(--fg);
            font-size: 16px; /* Prevent iOS focus zoom - must be ≥16px */
            outline: none;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .search-toggle-btn.expanded .search-input {
            opacity: 1;
            pointer-events: auto;
        }
        
        .search-toggle-btn .search-input::placeholder {
            color: var(--fg-muted);
        }
        
        /* Search results dropdown */
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 var(--radius-1) var(--radius-1);
            backdrop-filter: blur(10px);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1003;
            display: none;
            border-radius: var(--radius-1); /* Add rounded corners to entire container */
        }
        
        .search-results.show {
            display: block;
        }
        
        .search-result-item {
            padding: var(--space-1) var(--space-2);
            background: rgba(20, 20, 20, 0.95);
            margin-bottom: var(--space-1);
            border-radius: var(--radius-1);
            cursor: pointer;
            font-size: 0.63rem; /* 30% smaller than var(--text-md) */
            color: var(--fg);
            transition: background 0.2s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .search-result-item:hover {
            background: rgba(255, 255, 255, 0.4);
        }
        
        .search-result-item:last-child {
            margin-bottom: 0;
        }
        
        .search-result-name {
            text-align: left;
            line-height: 1.2;
        }
        
        .search-result-info {
            text-align: right;
            white-space: nowrap;
        }
        
        /* Header Styling - Normalized from bedrock 5 */
        .header {
            background: #000000; /* Pure black instead of var(--bg-1) */
            padding: var(--space-4) var(--space-4) calc(var(--space-4) + 5px) var(--space-4);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Very thin grey line */
            text-align: center;
            margin: 0 -16px var(--space-4) -16px; /* Negative margins to extend to edges */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); /* Match 10th bedrock shadow */
        }
        
        .header h3 {
            font-family: 'Euclid', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 3rem; /* Doubled from var(--text-2xl) which is 1.5rem */
            font-weight: 700; /* Match 10th bedrock thickness */
            margin: 5px 0 0 0; /* Move arc text down 5px to match 10th bedrock */
            padding: 0;
            color: var(--fg);
        }
        
        .header small {
            color: var(--fg-muted);
            font-size: var(--text-md);
            display: block;
            margin-top: 5px;
        }
        
        /* Controls Section - Normalized from bedrock 5 */
        .controls-section {
            padding: calc(var(--space-4) / 2 * 0.6) 16px;
            border-bottom: 1px solid rgba(64, 64, 64, 0.3);
        }
        
        .control-group {
            margin-bottom: var(--space-4);
        }
        
        .timeline-control-group {
            margin-bottom: var(--space-4);
        }
        
        .timeline-control-group > label {
            font-size: 15px !important;
            font-weight: 500 !important;
            margin-bottom: 16px !important;
        }
        
        .control-group label {
            display: block;
            margin-bottom: var(--space-1);
            color: var(--fg);
            font-weight: 500;
            font-size: var(--text-md);
        }
        
        /* Profile Section - Replicated from 10th bedrock */
        .profile-section {
            padding: calc(var(--space-4) / 2 * 0.6) var(--space-2);
            margin: 0 calc(-1 * var(--space-4)) 0 calc(-1 * var(--space-4));
            display: none;
            background: transparent;
            overflow-y: auto !important;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
        }
        
        .profile-header {
            background: rgba(255, 255, 255, 0.05);
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 16px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .profile-name,
        .profile-header h4,
        #profileName {
            font-size: 1.95rem !important;
            font-weight: 700 !important;
            margin-bottom: 10px;
            letter-spacing: -0.025em;
        }
        
        .profile-header p,
        #profileActivity {
            font-size: 0.9rem !important;
            font-weight: 500 !important;
            margin: 4px 0 !important;
            color: var(--fg-muted);
        }
        
        .profile-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 10px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.1);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .stat-number,
        .profile-stats .stat-card .stat-number,
        #profileTaps,
        #profileConnections {
            font-size: 1.5rem !important;
            font-weight: 700 !important;
            color: #ffffff;
            margin-bottom: 5px;
        }
        
        .stat-label,
        .profile-stats .stat-card .stat-label {
            font-size: 0.8rem !important;
            font-weight: 500 !important;
            color: var(--fg-muted);
            text-transform: uppercase !important;
            letter-spacing: 0.05em;
        }

        /* Timeline Slider - Normalized from bedrock 5 */
        .timeline-container {
            margin-bottom: var(--space-4);
        }
        
        .timeline-slider {
            position: absolute;
            inset: 0; /* stretch full width of container */
            height: 20px; /* = thumb size; gives us vertical room */
            background: transparent;
            border: 0;
            margin: 0;
            cursor: pointer;
            -webkit-appearance: none;
            appearance: none;
            pointer-events: none; /* track ignores hits; thumbs still catch them */
            top: 50%;
            transform: translateY(-50%); /* center the input (and thus the track) */
        }
        
        /* Left slider positioning - on top of right slider */
        .timeline-slider-left {
            z-index: 3;
        }
        
        /* Right slider positioning - behind left slider */
        .timeline-slider-right {
            z-index: 2;
        }
        
        /* WEBKIT (Chrome/Safari) — define track height and vertically center thumb */
        .timeline-slider::-webkit-slider-runnable-track {
            height: 6px; /* same as container */
            background: transparent; /* you're drawing the bar with the container */
            border-radius: 3px;
        }
        
        .timeline-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px; /* thumb size */
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            pointer-events: auto;
            /* Center the 20px thumb over the 6px track: (track - thumb)/2 = -7px */
            margin-top: calc((6px - 20px) / 2);
        }
        
        /* FIREFOX */
        .timeline-slider::-moz-range-track {
            height: 6px;
            background: transparent;
            border-radius: 3px;
        }
        
        .timeline-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border: none;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            pointer-events: auto;
        }
        
        .timeline-slider:disabled {
            cursor: not-allowed;
        }
        
        .timeline-slider:disabled::-webkit-slider-thumb {
            cursor: not-allowed;
            background: #666666;
        }
        
        .timeline-slider:disabled::-moz-range-thumb {
            cursor: not-allowed;
            background: #666666;
        }
        
        .timeline-info {
            display: flex;
            justify-content: space-between;
            margin-top: var(--space-1);
            font-size: var(--text-sm);
            color: var(--fg-muted);
        }
        
        
        /* Dual Slider Container - Adapted from 10th bedrock */
        .dual-slider-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            touch-action: none;
        }
        
        /* Proximity-based z-index classes */
        .timeline-slider.on-top { z-index: 3; }
        .timeline-slider.below  { z-index: 2; }
        
        /* Range highlighting between handles */
        .dual-slider-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: var(--range-left, 0%);
            width: var(--range-width, 100%);
            height: 6px;
            background: rgba(3, 218, 238, 0.3);
            border-radius: 3px;
            pointer-events: none;
            z-index: 1;
        }
        
        
        /* Timeline info layout for dual slider */
        .timeline-date-left,
        .timeline-date-right {
            flex: 1;
            text-align: center;
        }
        
        .timeline-center {
            flex: 1;
            text-align: center;
            font-weight: 500;
            white-space: pre-line; /* Allow newlines to display */
        }
        
        /* Mode Toggle - Normalized from bedrock 5 */
        .mode-toggle {
            display: flex;
            background: var(--stroke);
            border-radius: var(--radius-2);
            padding: 4px;
            margin-bottom: var(--space-4);
        }
        
        .mode-btn {
            flex: 1;
            padding: var(--space-1) var(--space-2);
            border: none;
            background: transparent;
            color: var(--fg-muted);
            border-radius: var(--radius-1);
            cursor: pointer;
            font-size: var(--text-md);
            transition: all 0.2s ease;
        }
        
        .mode-btn.active {
            background: var(--fg);
            color: var(--bg-1);
        }
        
        /* Search Input - Match button styling */
        .search-input {
            background: var(--stroke) !important;
            border: 1px solid var(--stroke-muted) !important;
            color: var(--fg) !important;
            border-radius: var(--radius-1) !important;
            padding: var(--space-1) var(--space-2) !important;
            font-size: var(--text-md) !important;
            width: 100%;
            box-sizing: border-box;
        }
        
        .search-input::placeholder {
            color: var(--fg-muted);
        }
        
        /* Search Results - Match search bar styling */
        .search-results {
            margin-top: var(--space-2);
            max-height: 150px; /* Reduced to ensure scrolling triggers sooner */
            overflow-y: auto !important;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--stroke-muted) transparent;
            border: 1px solid rgba(255, 255, 255, 0.1); /* Visible border for debugging */
        }
        
        /* Only show height when there are results */
        .search-results:not(:empty) {
            min-height: 40px;
        }
        
        .search-results::-webkit-scrollbar {
            width: 6px;
        }
        
        .search-results::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .search-results::-webkit-scrollbar-thumb {
            background: var(--stroke-muted);
            border-radius: 3px;
        }
        
        .search-result {
            padding: 8px var(--space-2);
            background: var(--stroke);
            margin-bottom: var(--space-1);
            border-radius: var(--radius-1);
            cursor: pointer;
            font-size: var(--text-md);
            color: var(--fg);
            transition: background 0.2s ease;
            min-height: auto; /* Match search bar height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            line-height: 1.2;
        }
        
        .search-result:hover {
            background: var(--stroke-muted);
        }
        
        .search-result .user-name {
            font-weight: 500;
            color: var(--fg);
        }
        
        .search-result .user-location {
            font-size: var(--text-sm);
            color: var(--fg-muted);
            margin-top: 2px;
        }
        
        /* Stats Display - Normalized from bedrock 5 */
        .stats-display {
            background: rgba(255, 255, 255, 0.05);
            border-radius: var(--radius-2);
            padding: 15px;
            margin-bottom: var(--space-4);
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: var(--space-1);
            font-size: var(--text-md);
        }
        
        .stat-item:last-child {
            margin-bottom: 0;
        }
        
        .stat-label {
            color: var(--fg-muted);
        }
        
        .stat-value {
            color: var(--fg);
            font-weight: 500;
        }
        
        /* Map Styling */
        #map {
            width: 100%;
            height: 100%;
            background: #000000;
        }
        
        /* Scale up Leaflet zoom controls */
        .leaflet-control-zoom {
            transform: scale(2.5) !important;
            transform-origin: top left !important;
        }
        
        .leaflet-control-zoom a {
            width: 60px !important;
            height: 60px !important;
            line-height: 60px !important;
            font-size: 30px !important;
        }
        
        /* Prevent zoom events on UI elements */
        .sidebar, .custom-popup {
            pointer-events: auto;
        }
        
        .sidebar *, .custom-popup * {
            pointer-events: auto;
        }
        
        /* Inline Map Controls - Normalized from bedrock 5 */
        .map-controls-inline {
            display: flex;
            flex-direction: column;
            gap: var(--space-1);
        }
        
        .control-btn {
            padding: var(--space-1) var(--space-2);
            background: var(--stroke);
            border: 1px solid var(--stroke-muted);
            border-radius: var(--radius-1);
            color: var(--fg);
            font-size: var(--text-md);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .control-btn:hover {
            background: var(--stroke-muted);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        /* Loading Screen */
        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        .loading-spinner {
            width: 120px; /* 40px * 3 */
            height: 120px; /* 40px * 3 */
            border: 9px solid rgba(255, 255, 255, 0.1); /* 3px * 3 */
            border-top: 9px solid #ffffff; /* 3px * 3 */
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 60px; /* 20px * 3 */
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #ffffff;
            font-size: 3.3em; /* 1.1em * 3 */
            text-align: center;
        }
        
        /* Custom Marker Popup */
        .custom-popup {
            background: rgba(0, 0, 0, 0.95);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 9px;
            color: #ffffff;
            padding: 15px;
            font-size: 13.5px;
            max-width: 300px;
            min-width: 225px;
            line-height: 1.4;
            box-shadow: 0 3px 9px rgba(0, 0, 0, 0.3);
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .popup-title {
            font-weight: 600;
            margin-bottom: 7.5px;
            color: #ffffff;
            font-size: 15px;
            line-height: 1.3;
            white-space: nowrap;
        }
        
        .popup-info {
            color: #cccccc;
            font-size: 12px;
            margin-bottom: 3.75px;
            line-height: 1.3;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        /* Degree Connection Filters */
        .degree-filters {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Reduced from 24px to 8px for tighter spacing */
        }
        
        .degree-checkbox {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: var(--text-md);
            color: var(--fg);
            position: relative;
            padding-left: 30px;
        }
        
        .degree-checkbox input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }
        
        .checkmark {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 16px;
            width: 16px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            transition: all 0.2s ease;
        }
        
        .degree-checkbox:hover .checkmark {
            background-color: rgba(255, 255, 255, 0.2);
        }
        
        .degree-checkbox input:checked ~ .checkmark {
            background-color: #ffffff;
            border-color: #ffffff;
        }
        
        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
            left: 5px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid #000000;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }
        
        .degree-checkbox input:checked ~ .checkmark:after {
            display: block;
        }

        .color-swatch {
            display: inline-block;
            width: 16px; /* Reduced to match text height */
            height: 16px; /* Reduced to match text height */
            border-radius: 50%; /* Makes it a circle */
            margin-left: 12px; /* Reduced spacing */
            vertical-align: middle; /* Align with text */
            border: 1px solid rgba(255, 255, 255, 0.3); /* Reduced border */
        }
        
        /* Leaflet Popup Overrides */
        .leaflet-popup-content-wrapper {
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            padding: 0 !important;
        }
        
        .leaflet-popup-content {
            margin: 0 !important;
            padding: 0 !important;
            background: transparent !important;
        }
        
        .leaflet-popup-tip {
            background: rgba(0, 0, 0, 0.95) !important;
            border: 3px solid rgba(255, 255, 255, 0.3) !important;
        }
        
        /* Hide Leaflet Zoom Controls */
        .leaflet-control-zoom {
            display: none !important;
        }
        
        /* Iframe context adjustments for mobile controls */
        @media (max-width: 900px) {
            body.iframe-context .mobile-hamburger {
                top: 10px !important;
                z-index: 10000 !important;
            }
            
            body.iframe-context .map-controls-floating {
                top: 10px !important;
                z-index: 10000 !important;
            }
            
            body.iframe-context .search-control-floating {
                top: 98px !important; /* Move up 10px to follow control buttons (108px - 10px) */
                z-index: 10000 !important;
            }
            
            body.iframe-context .drawing-control-floating {
                top: 146px !important; /* Below search button with 8px gap (98px + 40px button height + 8px gap) */
                z-index: 10000 !important;
            }
            
        }

        /* ========================================
           iOS FOCUS ZOOM PREVENTION
           ======================================== */
        
        /* Prevent iOS Safari focus zoom by ensuring all form controls are ≥16px */
        input, textarea, select, button {
            font-size: 16px !important;  /* Win every cascade - prevent iOS focus zoom */
            line-height: 1.25;           /* avoid vertical clipping when bumped to 16px */
            -webkit-text-size-adjust: 100%;
        }
        
        /* Restore original font sizes for control buttons (not form inputs) */
        .map-controls-floating .control-btn,
        .control-btn {
            font-size: var(--text-sm) !important; /* 0.8rem - original size */
        }
        
        /* Specifically target search inputs with maximum specificity */
        .search-input { 
            font-size: 16px !important; 
            line-height: 1.25; 
        }
        
        /* iOS can consider placeholder styling - ensure it's also 16px */
        .search-input::placeholder { 
            font-size: 16px !important; 
            opacity: 0.6; 
        }
        
        /* Ensure root won't shrink below 16px effective size on mobile */
        html { 
            -webkit-text-size-adjust: 100%; 
        }
        
        /* ========================================
           MOBILE RESPONSIVE DESIGN
           ======================================== */
        
        /* Hamburger Button */
        .mobile-hamburger {
            position: fixed;
            top: 27px;
            left: 20px;
            z-index: 1000;
            background: rgba(42, 42, 42, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            width: 44px;
            height: 44px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mobile-hamburger:hover {
            background: rgba(42, 42, 42, 1);
            border-color: #007bff;
        }

        .mobile-hamburger .line {
            width: 18px;
            height: 2px;
            background: white;
            border-radius: 1px;
            transition: all 0.3s ease;
        }

        .mobile-hamburger.active .line:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .mobile-hamburger.active .line:nth-child(2) {
            opacity: 0;
        }

        .mobile-hamburger.active .line:nth-child(3) {
            transform: rotate(-45deg) translate(5px, -5px);
        }

        /* Mobile Responsive Styles */
        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                height: 100%;
                z-index: 999;
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                padding: 60px 20px 20px 20px;
                border-bottom-left-radius: 20px;
                border-bottom-right-radius: 20px;
                /* Remove max-height constraint for mobile resize */
                max-height: none;
            }
            
            .sidebar.show {
                transform: translateX(0);
            }
            
            /* Resize Handle - Mobile Only */
            .resize-handle {
                position: fixed;
                left: 0;
                right: 0;
                height: 40px;
                background: rgba(42, 42, 42, 0.9);
                border-top: 2px solid rgba(255, 255, 255, 0.3);
                border-bottom-left-radius: 20px;
                border-bottom-right-radius: 20px;
                cursor: ns-resize;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1001;
                touch-action: none;
                /* Only show when sidebar is open */
                transform: translateX(-100%);
                transition: transform 0.3s ease;
                /* Position will be set dynamically by JavaScript */
            }
            
            /* Show resize handle when sidebar is open */
            .sidebar.show ~ .resize-handle {
                transform: translateX(0);
            }
            
            .resize-handle::before {
                content: '';
                width: 40px;
                height: 4px;
                background: rgba(255, 255, 255, 0.4);
                border-radius: 2px;
            }
            
            /* Hide resize handle when sidebar is hidden */
            .sidebar:not(.show) .resize-handle {
                display: none;
            }
            
            .map-container {
                width: 100%;
                height: 100vh;
            }
            
            .mobile-hamburger {
                display: flex;
            }
            
            /* Align map controls with hamburger button */
            .map-controls-floating {
                top: 27px;
            }
            
            /* Search control positioning on mobile - follow control buttons */
            .search-control-floating {
                top: 98px; /* Move up 10px to follow control buttons (108px - 10px) */
            }
            
            /* Drawing control positioning on mobile - below search button */
            .drawing-control-floating {
                top: 146px; /* Below search button with 8px gap (98px + 40px button height + 8px gap) */
            }
        }

        @media (min-width: 901px) {
            .mobile-hamburger {
                display: none;
            }
            
            /* Hide resize handle completely on desktop */
            .resize-handle {
                display: none !important;
            }
            
            /* Desktop z-index fixes - ensure search appears above drawing */
            .search-control-floating {
                z-index: 10001 !important;
            }
            
            .drawing-control-floating {
                z-index: 10000 !important;
            }
        }
        
        /* Intermediate screen sizes - override CSS Grid layout */
        @media (min-width: 380px) and (max-width: 900px) {
            .main-container {
                display: flex !important;
                flex-direction: row !important;
            }
            
            .sidebar:not(.show) {
                width: clamp(200px, 30vw, 300px) !important;
                min-width: 200px !important;
                overflow: auto !important;
            }
            
            .sidebar.show {
                width: 100% !important;
                min-width: 100% !important;
            }
            
            .map-container {
                flex: 1 !important;
                width: 100% !important;
            }
        }
    </style>
</head>
<body>
    <!-- Mobile Hamburger Button -->
    <button class="mobile-hamburger" id="mobileHamburger" onclick="toggleMobileSidebar()">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
    </button>

    <div class="main-container">
        <!-- Sidebar -->
        <div class="sidebar">
            
            <!-- Controls Section -->
            <div class="controls-section">
                <!-- User Search (hidden in user-centric view) -->
                <div class="control-group" id="userSearchGroup" style="display: none;">
                    <label>Search User</label>
                    <input type="text" id="userSearchInput" class="form-control search-input" placeholder="Type a name...">
                    <div id="searchResults" class="search-results"></div>
                </div>
                
                <!-- Profile Section (User-Centric Mode Only) -->
                <div id="profileSection" class="profile-section">
                    <div class="profile-header">
                        <h4 id="profileName">User Profile</h4>
                        <p id="profileActivity">Activity Level</p>
                    </div>
                    
                    <div class="profile-stats">
                        <div class="stat-card">
                            <div class="stat-number" id="profileTaps">0</div>
                            <div class="stat-label">Taps</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-number" id="profileConnections">0</div>
                            <div class="stat-label">Connections</div>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline Slider -->
                <div class="timeline-control-group">
                    <label>Timeline</label>
                    <div class="timeline-container">
                        <div class="dual-slider-container">
                            <input type="range" class="timeline-slider timeline-slider-left" id="timelineSliderLeft" min="0" max="100" value="0">
                            <input type="range" class="timeline-slider timeline-slider-right" id="timelineSliderRight" min="0" max="100" value="100">
                        </div>
                        <div class="timeline-info">
                            <div class="timeline-date-left">
                                <span id="startDate">Start Date</span>
                            </div>
                            <div class="timeline-center">
                                <span id="connectionCount">246 total users</span>
                            </div>
                            <div class="timeline-date-right">
                                <span id="endDate">End Date</span>
                            </div>
                        </div>
                        <!-- Cumulative section hidden - not needed with dual range slider -->
                        <div class="timeline-options" style="margin-top: 24px; display: none;">
                            <label class="degree-checkbox">
                                <input type="checkbox" id="cumulativeCheck" checked>
                                <span class="checkmark"></span>
                                Cumulative
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Global View Toggle -->
                <div class="control-group">
                    <label>View Options</label>
                    <div class="mode-toggle">
                        <button class="mode-btn" id="globalViewBtn" onclick="activateGlobalView()">See Full Arc Network</button>
                    </div>
                </div>
                
                <!-- Stats Display -->
                <div class="stats-display">
                    <div class="stat-item">
                        <span class="stat-label">Visible Taps:</span>
                        <span class="stat-value" id="visibleTaps">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Total Taps:</span>
                        <span class="stat-value" id="totalTaps">647</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Active Users:</span>
                        <span class="stat-value" id="activeUsers">197</span>
                    </div>
                </div>
                
                <!-- Degree Connection Filters (User-Centric Mode Only) -->
                <div class="control-group" id="degreeFiltersGroup" style="display: none;">
                    <label>Degree Connections</label>
                    <div class="degree-filters">
                        <label class="degree-checkbox">
                            <input type="checkbox" id="degree1Check" checked>
                            <span class="checkmark"></span>
                            1st Degree
                            <span class="color-swatch" style="background-color: #0E76A8;"></span>
                        </label>
                        <label class="degree-checkbox">
                            <input type="checkbox" id="degree2Check">
                            <span class="checkmark"></span>
                            2nd Degree
                            <span class="color-swatch" style="background-color: #3EC1D3;"></span>
                        </label>
                        <label class="degree-checkbox">
                            <input type="checkbox" id="degree3Check">
                            <span class="checkmark"></span>
                            3rd Degree
                            <span class="color-swatch" style="background-color: #9BE3DE;"></span>
                        </label>
                    </div>
                </div>
                
                <!-- Show All Toggle -->
                <div class="control-group">
                    <label>Display Options</label>
                    <div class="mode-toggle">
                        <button class="mode-btn" id="showAllBtn" onclick="toggleShowAll()">Show All</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mobile Resize Handle - Outside sidebar for proper positioning -->
        <div class="resize-handle" id="resizeHandle"></div>
        
        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            
            <!-- Floating Map Controls - Top Right -->
            <div class="map-controls-floating">
                <button class="control-btn" onclick="fitMapToBounds()">Fit to Data</button>
                <button class="control-btn" onclick="resetMapView()">Reset View</button>
            </div>
            
            <!-- Search Button - Separate Container -->
            <div class="search-control-floating">
                <button class="control-btn search-toggle-btn" id="searchToggleBtn" onclick="toggleSearch()" title="Search Users">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                    <input type="text" id="expandableSearchInput" class="search-input" placeholder="Type name or username..." autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off">
                    <div id="expandableSearchResults" class="search-results"></div>
                </button>
            </div>
            
            <!-- Drawing Tool Button - Below Search -->
            <div class="drawing-control-floating">
                <button class="control-btn drawing-toggle-btn" id="drawToggleBtn" title="Draw Circle">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 18l-4 1 1-4L16.5 3.5z"></path>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">
            <p>Loading geographic data...</p>
            <p id="loadingStats">Initializing map</p>
        </div>
    </div>
    
    <script>
        // Global variables
        let map;
        let markers = [];
        let markerGroups = {};
        let currentMode = 'user';
        let selectedUserId = null;
        let timelineData = [];
        let tapLocationData = {};
        let edgesData = [];
        let clusteringEnabled = true;
        let updateTimeout = null;
        let isUpdating = false;
        let isSliderDragging = false;
        let completeLocationData = []; // Make this global
        let allLocationData = []; // Store all unfiltered data for global view
        let showAllEnabled = false; // Track Show All toggle state
        let globalViewEnabled = false; // Track Global View toggle state
        let cumulativeEnabled = true; // Track Cumulative toggle state
        let degreeFilters = {
            degree1: true,
            degree2: false,
            degree3: false
        };
        
        // Drawing tool variables
        let drawnItems = null;
        let drawControl = null;
        let isDrawingMode = false;
        let currentDropdown = null;
        let isCrosshairsMode = false;
        let clickStartPos = null;
        let dragThreshold = 5; // pixels
        let drawUpdateTimeout = null;
        let isDragging = false;
        
        // Custom freehand drawing state
        let isDrawing = false;
        let drawingPoints = [];
        let temporaryPolyline = null;
        let previewNeedsUpdate = false;
        
        // Mobile detection
        function isMobileDevice() {
            return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
        let animationFrameId = null;
        const POINT_SIMPLIFICATION_TOLERANCE = 10; // meters
        const MIN_POINTS_FOR_POLYGON = 3;
        
        // Search state management
        let originalUserId = null;        // The logged-in user
        let originalUserName = null;      // The logged-in user's name  
        let currentlyViewingUserId = null; // Who we're currently viewing (original or searched)
        let isViewingSearchedUser = false; // Are we viewing a searched user or original? // Track degree filter states
        
        // Initialize the application
        async function init() {
            try {
                // Load data
                await loadData();
                
                // Initialize map
                initMap();
                
                // Initialize timeline
                initTimeline();
                
                // Update display
                updateDisplay();
                
                // Hide loading screen
                document.getElementById('loadingScreen').style.display = 'none';
                
            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('loadingStats').textContent = 'Error loading data: ' + error.message;
            }
        }
        
        // Load data from API
        async function loadData() {
            try {
                
                // Load comprehensive data from API
                const comprehensiveResponse = await fetch(`/api/data?t=${Date.now()}`);
                if (!comprehensiveResponse.ok) {
                    throw new Error(`Failed to load comprehensive data: ${comprehensiveResponse.status}`);
                }
                const api = await comprehensiveResponse.json();
                
                // ---- Back-compat + null-safety shim (do not edit) ----
                const taps =
                  Array.isArray(api.taps) ? api.taps :
                  Array.isArray(api.tap_data) ? api.tap_data : [];

                const users =
                  Array.isArray(api.users) ? api.users :
                  Array.isArray(api.user_profiles) ? api.user_profiles : [];

                // normalize both shapes so downstream code can use either
                const data = {
                  ...api,
                  taps,
                  tap_data: taps,
                  users,
                  user_profiles: users,
                };

                // common short names; always safe
                const TAPS  = data.taps;          // []
                const USERS = data.users;         // []
                // -------------------------------------------------------
                
                // Data loaded successfully
                
                const comprehensiveData = data;
                const tapData = TAPS;
                
                
                // Filter out taps without valid lat/lng coordinates
                const cleanTaps = (tapData || []).filter(tap => {
                    if (!tap.latitude || !tap.longitude) return false;
                    const lat = Number(tap.latitude);
                    const lng = Number(tap.longitude);
                    return Number.isFinite(lat) && Number.isFinite(lng);
                });
                
                // Store all unfiltered data for global view
                allLocationData = (data.tap_data || []).map(tap => ({
                    tap_id: tap.tap_id,
                    user1_id: tap.user1_id,
                    user1_name: tap.user1_name,
                    user1_home: tap.user1_home,
                    user2_id: tap.user2_id,
                    user2_name: tap.user2_name,
                    user2_home: tap.user2_home,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time
                }));

                // Transform tap data to match expected format (use all data like Global version)
                completeLocationData = (data.tap_data || []).map(tap => ({
                    tap_id: tap.tap_id,
                    user1_id: tap.user1_id,
                    user1_name: tap.user1_name,
                    user1_home: tap.user1_home,
                    user2_id: tap.user2_id,
                    user2_name: tap.user2_name,
                    user2_home: tap.user2_home,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time
                }));
                
                
                
                // User location data is included in comprehensive data
                
                // Metadata is included in comprehensive data
                const metadata = {
                    last_refresh: comprehensiveData.last_refresh,
                    total_taps: comprehensiveData.taps.length,
                    total_users: comprehensiveData.users.length
                };
                
                // Generate edges data from tap data
                const edgeMap = new Map();
                
                completeLocationData.forEach(tap => {
                    const sourceId = tap.user1_id;
                    const targetId = tap.user2_id;
                    const edgeKey = `${sourceId}-${targetId}`;
                    
                    if (edgeMap.has(edgeKey)) {
                        const existingEdge = edgeMap.get(edgeKey);
                        existingEdge.tap_count += 1;
                        existingEdge.thickness = Math.min(existingEdge.tap_count * 0.5, 5.0);
                    } else {
                        edgeMap.set(edgeKey, {
                            source_id: sourceId,
                            source_name: tap.user1_name,
                            target_id: targetId,
                            target_name: tap.user2_name,
                            tap_count: 1,
                            thickness: 1.0,
                            color: "#E0E0E0"
                        });
                    }
                });
                
                edgesData = Array.from(edgeMap.values());
                
                // Convert to tapLocationData object for quick lookup
                completeLocationData.forEach(tap => {
                    const tapKey = tap.tap_id;
                    tapLocationData[tapKey] = {
                        tap_id: tap.tap_id,
                        user1_id: tap.user1_id,
                        user1_name: tap.user1_name,
                        user2_id: tap.user2_id,
                        user2_name: tap.user2_name,
                        latitude: tap.latitude,
                        longitude: tap.longitude,
                        location: tap.location,
                        time: tap.time,
                        formatted_time: tap.formatted_time
                    };
                });
                
                // Create timeline data from the loaded tap data
                createTimelineData();
                
            } catch (error) {
                console.error('❌ Error loading data:', error);
                throw error;
            }
        }
        
                
                // HARDCODED EDGES DATA COMMENTED OUT - NOW GENERATED DYNAMICALLY
                
                // edgesData is now set dynamically in loadData() function
                
                // LEGACY CODE COMMENTED OUT - NOW USING JSON LOADING
                /*
                // Create timeline data (simplified for now)
                createTimelineData();
                
                console.log('Data loaded:', {
                    taps: completeLocationData.length,
                    edges: edgesData.length,
                    timelineEvents: timelineData.length
                });
                
            } catch (error) {
                console.error('Error loading data:', error);
                throw error;
            }
        }
                */
        
        // Create timeline data from actual tap data
        function createTimelineData(userId = null) {
            timelineData = [];
            let eventIndex = 0;
            
            // Create timeline events from completeLocationData
            completeLocationData.forEach(tap => {
                const tapTime = new Date(tap.time).getTime();
                
                // Create timeline event
                timelineData.push({
                    id: eventIndex++,
                    timestamp: tapTime,
                    tap_id: tap.tap_id,
                    user1_id: tap.user1_id,
                    user1_name: tap.user1_name,
                    user2_id: tap.user2_id,
                    user2_name: tap.user2_name,
                    location: tap.location,
                    latitude: tap.latitude,
                    longitude: tap.longitude
                });
            });
            
            // Sort by timestamp
            timelineData.sort((a, b) => a.timestamp - b.timestamp);
            
        }
        
        // Initialize Leaflet map
        function initMap() {
            // Check map container
            const mapContainer = document.getElementById('map');
            // Map container initialized
            
                    // Create map with dark theme
        map = L.map('map', {
            center: [39.8283, -98.5795], // Center of USA
            zoom: 4, // Zoomed out to show entire continental USA
            zoomControl: true,
            attributionControl: false
        });
            
            // Add dark tile layer with standard configuration
            const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '©OpenStreetMap, ©CartoDB',
                subdomains: 'abcd',
                maxZoom: 19,
                tileSize: 256,  // Standard tile size
                zoomOffset: 0   // No offset
            }).addTo(map);
            
            // Add event listeners to check if tiles are loading
            tileLayer.on('loading', function() {
                console.log('Map tiles loading...');
            });
            
            tileLayer.on('load', function() {
                console.log('Map tiles loaded successfully');
            });
            
            tileLayer.on('tileerror', function(e) {
                console.error('Map tile error:', e);
            });
            
            // Zoom control removed - not needed
            
            console.log('Map initialized');
            
            // Test marker removed - map is working correctly
            
            // Force map to resize and invalidate
            setTimeout(() => {
                map.invalidateSize();
                console.log('Map invalidated and resized');
            }, 100);
            
            // Prevent zoom events on UI elements
            preventZoomOnUIElements();
            
            // Initialize drawing tools
            initDrawingTools();
        }
        
        // Function to prevent zoom events on UI elements
        function preventZoomOnUIElements() {
            // Get UI elements
            const sidebar = document.querySelector('.sidebar');
            
            // Function to prevent wheel events from bubbling to map
            function preventWheelEvent(e) {
                // Allow scrolling on search results and other scrollable elements
                const target = e.target;
                const isScrollableElement = target.closest('.search-results') || 
                                          target.closest('[style*="overflow"]') ||
                                          target.closest('.controls-section');
                
                if (isScrollableElement) {
                    // Allow normal scrolling, just prevent zoom
                    e.stopPropagation();
                    return; // Don't prevent default for scrollable elements
                }
                
                // For other elements, prevent both zoom and scroll
                e.stopPropagation();
                e.preventDefault();
            }
            
            // Function to prevent touch events (pinch-to-zoom)
            function preventTouchEvent(e) {
                if (e.touches.length > 1) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
            
            // Function to prevent keyboard zoom shortcuts
            function preventKeyboardZoom(e) {
                if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.keyCode === 61 || e.keyCode === 173)) {
                    e.stopPropagation();
                    e.preventDefault();
                }
            }
            
            // Function to disable map zoom when hovering over UI elements
            function disableMapZoom() {
                map.scrollWheelZoom.disable();
                map.doubleClickZoom.disable();
                map.touchZoom.disable();
            }
            
            // Function to enable map zoom when leaving UI elements
            function enableMapZoom() {
                map.scrollWheelZoom.enable();
                map.doubleClickZoom.enable();
                map.touchZoom.enable();
            }
            
            // Add event listeners to prevent zoom on UI elements
            if (sidebar) {
                sidebar.addEventListener('wheel', preventWheelEvent, { passive: false });
                sidebar.addEventListener('touchstart', preventTouchEvent, { passive: false });
                sidebar.addEventListener('touchmove', preventTouchEvent, { passive: false });
                sidebar.addEventListener('keydown', preventKeyboardZoom, { passive: false });
                sidebar.addEventListener('mouseenter', disableMapZoom);
                sidebar.addEventListener('mouseleave', enableMapZoom);
                // Also prevent on all child elements
                const sidebarElements = sidebar.querySelectorAll('*');
                sidebarElements.forEach(element => {
                    element.addEventListener('wheel', preventWheelEvent, { passive: false });
                    element.addEventListener('touchstart', preventTouchEvent, { passive: false });
                    element.addEventListener('touchmove', preventTouchEvent, { passive: false });
                    element.addEventListener('keydown', preventKeyboardZoom, { passive: false });
                });
            }
            
            // Map controls are now inline in the sidebar, so no separate handling needed
            
            // Prevent zoom on popups when they appear
            map.on('popupopen', function(e) {
                const popup = e.popup.getElement();
                if (popup) {
                    popup.addEventListener('wheel', preventWheelEvent, { passive: false });
                    popup.addEventListener('touchstart', preventTouchEvent, { passive: false });
                    popup.addEventListener('touchmove', preventTouchEvent, { passive: false });
                    popup.addEventListener('keydown', preventKeyboardZoom, { passive: false });
                    popup.addEventListener('mouseenter', disableMapZoom);
                    popup.addEventListener('mouseleave', enableMapZoom);
                    // Also prevent on all child elements
                    const popupElements = popup.querySelectorAll('*');
                    popupElements.forEach(element => {
                        element.addEventListener('wheel', preventWheelEvent, { passive: false });
                        element.addEventListener('touchstart', preventTouchEvent, { passive: false });
                        element.addEventListener('touchmove', preventTouchEvent, { passive: false });
                        element.addEventListener('keydown', preventKeyboardZoom, { passive: false });
                    });
                }
            });
            
            // Re-enable map zoom when popup closes (regardless of how it closes)
            map.on('popupclose', function(e) {
                enableMapZoom();
            });
            
        }
        
        // Initialize dual timeline slider
        function initTimeline() {
            const leftSlider = document.getElementById('timelineSliderLeft');
            const rightSlider = document.getElementById('timelineSliderRight');
            if (!leftSlider || !rightSlider) return;
            
            // Set initial state to full range (0-100%) - show all connections initially
            leftSlider.value = 0;
            rightSlider.value = 100;
            updateDualTimelineDisplay(0, 100);
            updateRangeHighlighting(0, 100);
            
            // Proximity-based z-index solution for dual sliders
            (function () {
                const container = document.querySelector('.dual-slider-container');
                const left = leftSlider;
                const right = rightSlider;
                const minGap = 1; // in slider units (0–100 here)

                // Initialize z-order
                function setTop(which) {
                    const top = which === 'left' ? left : right;
                    const other = which === 'left' ? right : left;
                    top.classList.add('on-top');  top.classList.remove('below');
                    other.classList.add('below'); other.classList.remove('on-top');
                }
                setTop('right'); // start with right on top; will swap based on pointer

                // Map value to pixel X inside container
                function valueToPx(input) {
                    const rect = container.getBoundingClientRect();
                    const min = Number(input.min), max = Number(input.max), val = Number(input.value);
                    const t = (val - min) / (max - min);
                    return rect.left + t * rect.width;
                }

                function closestHandle(clientX) {
                    const dl = Math.abs(clientX - valueToPx(left));
                    const dr = Math.abs(clientX - valueToPx(right));
                    return dl <= dr ? 'left' : 'right';
                }

                // Before the user presses, make the nearer handle the top one (throttled for performance)
                let proximityTimeout;
                container.addEventListener('pointermove', (e) => {
                    if (container.dataset.lock) return; // don't swap while dragging
                    clearTimeout(proximityTimeout);
                    proximityTimeout = setTimeout(() => {
                        setTop(closestHandle(e.clientX));
                    }, 16); // ~60fps throttling
                });

                // Lock z-index to the active handle during drag
                [left, right].forEach((el) => {
                    el.addEventListener('pointerdown', () => {
                        setTop(el === left ? 'left' : 'right');
                        container.dataset.lock = '1';
                    }, { passive: true });
                });

                // Unlock on release (use capture on window to catch releases outside)
                window.addEventListener('pointerup', () => { container.dataset.lock = ''; }, true);

                // Enforce a minimum gap and keep values sane
                function clampValues() {
                    const lv = Number(left.value), rv = Number(right.value);
                    if (lv > rv - minGap) left.value = rv - minGap;
                    if (rv < lv + minGap) right.value = lv + minGap;
                }

                // Note: Input handling is done by the forEach loop below
                // This proximity solution only handles z-index management

                // Optional: track click to jump the nearer handle to the clicked spot
                container.addEventListener('pointerdown', (e) => {
                    const which = closestHandle(e.clientX);
                    const target = which === 'left' ? left : right;
                    setTop(which);

                    const rect = container.getBoundingClientRect();
                    const min = Number(target.min), max = Number(target.max);
                    const t = Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
                    const next = Math.round(min + t * (max - min));

                    target.value = next;
                    clampValues();
                    target.dispatchEvent(new Event('input', { bubbles: true }));
                });
            })();
            
            // Add event listeners for both sliders - optimized for maximum responsiveness
            [leftSlider, rightSlider].forEach(slider => {
                slider.addEventListener('input', function() {
                    // Immediate processing for maximum responsiveness
                    if (!isUpdating) {
                        const leftValue = parseInt(leftSlider.value);
                        const rightValue = parseInt(rightSlider.value);
                        
                        // Calculate minimum gap
                        const minGap = 1; // Minimum 1% gap
                        
                        // Handle left slider movement
                        if (this === leftSlider) {
                            // Left slider cannot go past right slider minus minimum gap
                            if (leftValue >= rightValue - minGap) {
                                const newValue = Math.max(0, rightValue - minGap);
                                leftSlider.value = newValue;
                            }
                        }
                        
                        // Handle right slider movement  
                        if (this === rightSlider) {
                            // Right slider cannot go before left slider plus minimum gap
                            if (rightValue <= leftValue + minGap) {
                                const newValue = Math.min(100, leftValue + minGap);
                                rightSlider.value = newValue;
                            }
                        }
                        
                        // Immediate timeline and range updates for maximum responsiveness
                        updateDualTimelineDisplay(leftValue, rightValue);
                        updateRangeHighlighting(leftValue, rightValue);
                    }
                });
                
                slider.addEventListener('mousedown', function() {
                    isSliderDragging = true;
                });
                
                slider.addEventListener('mouseup', function() {
                    isSliderDragging = false;
                    // Force immediate update when dragging ends
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                    updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                });
                
                slider.addEventListener('touchstart', function() {
                    isSliderDragging = true;
                });
                
                slider.addEventListener('touchend', function() {
                    isSliderDragging = false;
                    // Force immediate update when touch ends
                    if (updateTimeout) {
                        clearTimeout(updateTimeout);
                    }
                    updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                });
            });
            
            // Add cumulative checkbox event listener (works in both global and user modes)
            const cumulativeCheck = document.getElementById('cumulativeCheck');
            cumulativeCheck.addEventListener('change', function() {
                cumulativeEnabled = this.checked;
                
                // Force update markers to reflect the new cumulative setting
                if (!showAllEnabled) {
                    // Normal timeline mode - updateDualTimelineDisplay will handle marker updates
                    updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                } else {
                    // When Show All is enabled, force update with current timeline values
                    updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
                }
            });
            
            console.log('Dual timeline initialized');
        }
        
        // Update range highlighting for dual slider
        function updateRangeHighlighting(startPercentage, endPercentage) {
            const container = document.querySelector('.dual-slider-container');
            if (container) {
                const rangeWidth = endPercentage - startPercentage;
                container.style.setProperty('--range-left', startPercentage + '%');
                container.style.setProperty('--range-width', rangeWidth + '%');
            }
        }
        
        // Update dual timeline display
        function updateDualTimelineDisplay(startPercentage, endPercentage) {
            if (completeLocationData.length === 0) {
                console.log('⚠️ Timeline: completeLocationData is empty');
                return;
            }
            
            // Prevent multiple simultaneous updates
            if (isUpdating) return;
            isUpdating = true;
            
            // Clear any pending timeline updates to prevent lag
            if (window.timelineUpdateTimeout) {
                clearTimeout(window.timelineUpdateTimeout);
            }
            
            // Minimal debounce for maximum responsiveness
            window.timelineUpdateTimeout = setTimeout(() => {
                performTimelineUpdate(startPercentage, endPercentage);
            }, 16); // 16ms = ~60fps for maximum responsiveness
        }
        
        // Separate function for the actual timeline update logic
        function performTimelineUpdate(startPercentage, endPercentage) {
            
            console.log(`🕒 Timeline: Updating display ${startPercentage}% - ${endPercentage}%`);
            
            // Calculate start and end times based on complete location data
            const timestamps = completeLocationData.map(tap => new Date(tap.time).getTime()).sort((a, b) => a - b);
            const earliestTime = timestamps[0];
            const latestTime = timestamps[timestamps.length - 1];
            const timeRange = latestTime - earliestTime;
            
            const startTime = earliestTime + (startPercentage / 100) * timeRange;
            const endTime = earliestTime + (endPercentage / 100) * timeRange;
            
            // Update date displays
            const startDate = new Date(startTime);
            const endDate = new Date(endTime);
            
            document.getElementById('startDate').textContent = startDate.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            });
            
            document.getElementById('endDate').textContent = endDate.toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric',
                year: 'numeric'
            });
            
            // Update markers with time range
            updateMarkersWithTimeRange(startTime, endTime);
            
            // Update connection count
            const filteredEvents = completeLocationData.filter(event => {
                const eventTime = new Date(event.time).getTime();
                return eventTime >= startTime && eventTime <= endTime;
            });
            
            const uniqueUsers = new Set();
            filteredEvents.forEach(event => {
                if (event.user1_id) uniqueUsers.add(event.user1_id);
                if (event.user2_id) uniqueUsers.add(event.user2_id);
            });
            
            const userCount = uniqueUsers.size;
            const daysDiff = Math.ceil((endTime - startTime) / (1000 * 60 * 60 * 24));
            
            document.getElementById('connectionCount').textContent = `${userCount} users\n${daysDiff} days`;
            
            // Update profile stats if a user is selected
            if (currentMode === 'user' && selectedUserId) {
                updateProfileStatsForTimeline(selectedUserId, startTime, endTime);
            }
            
            // Update view options numbers
            updateViewOptionsNumbers(filteredEvents, startTime, endTime);
            
            // Refresh circle results if drawing is active
            refreshCircleResultsOnFilterChange();
            
            isUpdating = false;
        }
        
        // Update markers with time range instead of single timestamp
        function updateMarkersWithTimeRange(startTime, endTime) {
            // Clear existing markers
            clearMarkers();
            
            let filteredEvents;
            
            if (globalViewEnabled) {
                // Global view mode: display all events within time range
                filteredEvents = completeLocationData.filter(event => {
                    const eventTime = new Date(event.time).getTime();
                    return eventTime >= startTime && eventTime <= endTime;
                }).map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1,
                    timestamp: new Date(tap.time).getTime()
                }));
            } else if (currentMode === 'user' && selectedUserId) {
                // Calculate timeline percentage for degree integration
                // Use the slider values directly to determine if timeline is restricted
                const leftSlider = document.getElementById('timelineSliderLeft');
                const rightSlider = document.getElementById('timelineSliderRight');
                const leftValue = parseInt(leftSlider.value);
                const rightValue = parseInt(rightSlider.value);
                const timelinePercentage = rightValue - leftValue; // This represents how much of the timeline is visible
                
                // Debug: Log the actual values
                // Reduced logging for performance
                // console.log(`🔍 Debug: leftValue=${leftValue}, rightValue=${rightValue}, timelinePercentage=${timelinePercentage}%`);
                // console.log(`🎯 Timeline percentage: ${timelinePercentage.toFixed(1)}%`);
                
                // User-centric mode: First filter by time range, then apply degree filtering
                filteredEvents = completeLocationData.filter(event => {
                    const eventTime = new Date(event.time).getTime();
                    return eventTime >= startTime && eventTime <= endTime;
                }).map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1,
                    timestamp: new Date(tap.time).getTime()
                }));
                
                // Apply degree filtering after time filtering (like develop branch)
                if (currentMode === 'user' && selectedUserId) {
                    // Use cached degree connections for better performance
                    if (!window.cachedDegreeConnections || window.cachedDegreeConnections.userId !== selectedUserId) {
                        window.cachedDegreeConnections = {
                            userId: selectedUserId,
                            connections: calculateDegreeConnections(selectedUserId)
                        };
                    }
                    const degreeConnections = window.cachedDegreeConnections.connections;
                    
                    // Optimized degree filtering for better performance
                    filteredEvents = filteredEvents.filter(event => {
                        const sourceUserId = event.source_id;
                        const targetUserId = event.target_id;
                        
                        // Quick check: if either user is the selected user, it's always 1st degree
                        if (sourceUserId === selectedUserId || targetUserId === selectedUserId) {
                            return degreeFilters.degree1;
                        }
                        
                        // For other connections, check degree levels efficiently
                        const sourceInDegree1 = degreeConnections.degree1.has(sourceUserId);
                        const targetInDegree1 = degreeConnections.degree1.has(targetUserId);
                        const sourceInDegree2 = degreeConnections.degree2.has(sourceUserId);
                        const targetInDegree2 = degreeConnections.degree2.has(targetUserId);
                        
                        // 2nd degree: at least one user is 1st degree connection
                        if (degreeFilters.degree2 && (sourceInDegree1 || targetInDegree1)) {
                            return true;
                        }
                        
                        // 3rd degree: at least one user is 2nd degree connection
                        if (degreeFilters.degree3 && (sourceInDegree2 || targetInDegree2)) {
                            return true;
                        }
                        
                        return false;
                    });
                }
            } else {
                // Normal mode: filter by time range only
                filteredEvents = completeLocationData.filter(event => {
                    const eventTime = new Date(event.time).getTime();
                    return eventTime >= startTime && eventTime <= endTime;
                }).map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1,
                    timestamp: new Date(tap.time).getTime()
                }));
            }
            
            // Apply cumulative filtering if enabled
            if (cumulativeEnabled && !showAllEnabled) {
                filteredEvents = filteredEvents.filter(event => {
                    const eventTime = event.timestamp;
                    return eventTime <= endTime; // Show all events up to end time
                });
            }
            
            // Create markers for filtered events
            // console.log('🎯 Creating markers for', filteredEvents.length, 'filtered events');
            filteredEvents.forEach(event => {
                if (event.latitude && event.longitude) {
                    const location = {
                        latitude: event.latitude,
                        longitude: event.longitude,
                        location: event.location || 'Unknown location'
                    };
                    addTapMarker(location, event);
                } else {
                    console.log('Event missing latitude/longitude:', event);
                }
            });
        }
        
        
        // Update markers based on timeline and mode
        function updateMarkers(currentTime) {
            // Clear existing markers
            clearMarkers();
            
            // Debug logging
            console.log('🔍 updateMarkers called with:', {
                globalViewEnabled,
                currentMode,
                selectedUserId,
                allLocationDataLength: allLocationData.length,
                completeLocationDataLength: completeLocationData.length
            });
            
            let filteredEvents;
            
            if (globalViewEnabled) {
                console.log('🎯 Taking GLOBAL VIEW branch - using completeLocationData (like Global version)');
                // Global view mode: display all events as white nodes regardless of user selection
                // Use completeLocationData like the Global version does
                filteredEvents = completeLocationData.map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1, // Each tap represents one connection
                    timestamp: new Date(tap.time).getTime() // Add timestamp for timeline filtering
                }));
            } else if (currentMode === 'user' && selectedUserId) {
                console.log('🎯 Taking USER MODE branch - using completeLocationData');
                // In user mode, always start with complete location data for degree filtering
                // Transform completeLocationData to match expected structure
                filteredEvents = completeLocationData.map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1, // Each tap represents one connection
                    timestamp: new Date(tap.time).getTime() // Add timestamp for timeline filtering
                }));
            } else if (showAllEnabled) {
                console.log('🎯 Taking SHOW ALL branch - using completeLocationData');
                // Show All mode: display all events regardless of timeline
                // Transform completeLocationData to match expected structure
                filteredEvents = completeLocationData.map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1, // Each tap represents one connection
                    timestamp: new Date(tap.time).getTime() // Add timestamp for timeline filtering
                }));
            } else {
                console.log('🎯 Taking NORMAL TIMELINE branch - using completeLocationData');
                // Normal timeline mode: use complete location data for consistent filtering
                // Transform completeLocationData to match expected structure
                filteredEvents = completeLocationData.map(tap => ({
                    source_id: tap.user1_id,
                    source_name: tap.user1_name,
                    target_id: tap.user2_id,
                    target_name: tap.user2_name,
                    latitude: tap.latitude,
                    longitude: tap.longitude,
                    location: tap.location,
                    formatted_location: tap.formatted_location,
                    venue_context: tap.venue_context,
                    time: tap.time,
                    formatted_time: tap.formatted_time,
                    tap_count: 1, // Each tap represents one connection
                    timestamp: new Date(tap.time).getTime() // Add timestamp for timeline filtering
                }));
            }
            
            // Filter events based on mode and degree connections
            if (currentMode === 'user' && selectedUserId && !globalViewEnabled) {
                // Calculate degree connections for the selected user
                const degreeConnections = calculateDegreeConnections(selectedUserId);
                
                
                // Filter events based on selected degree filters
                filteredEvents = filteredEvents.filter(event => {
                    const sourceUserId = event.source_id;
                    const targetUserId = event.target_id;
                    
                    let shouldShow = false;
                    
                    // For 1st degree: Only show connections that directly involve the selected user
                    if (degreeFilters.degree1) {
                        if (sourceUserId === selectedUserId || targetUserId === selectedUserId) {
                            // This is a direct connection to the selected user
                            shouldShow = true;
                        }
                    }
                    
                    // For 2nd degree: Show connections where at least one user is a 1st degree connection to selected user
                    if (degreeFilters.degree2) {
                        if (sourceUserId !== selectedUserId && targetUserId !== selectedUserId) {
                            // Neither user is the selected user
                            if (degreeConnections.degree1.has(sourceUserId) || degreeConnections.degree1.has(targetUserId)) {
                                // At least one user is a 1st degree connection to selected user
                                shouldShow = true;
                            }
                        }
                    }
                    
                    // For 3rd degree: Show connections between 2nd degree users (not involving selected user or 1st degree users)
                    if (degreeFilters.degree3) {
                        if (sourceUserId !== selectedUserId && targetUserId !== selectedUserId) {
                            // Neither user is the selected user
                            if (!degreeConnections.degree1.has(sourceUserId) && !degreeConnections.degree1.has(targetUserId)) {
                                // Neither user is a 1st degree connection
                                if (degreeConnections.degree2.has(sourceUserId) && degreeConnections.degree2.has(targetUserId)) {
                                    // Both users are 2nd degree connections to selected user
                                    shouldShow = true;
                                }
                            }
                        }
                    }
                    
                    return shouldShow;
                });
                
            }
            
            // Apply timeline filtering if not in Show All mode OR if we're in user mode with degree filters
            if (!showAllEnabled || (currentMode === 'user' && selectedUserId)) {
                const beforeTimeline = filteredEvents.length;
                
                if (cumulativeEnabled) {
                    // Cumulative mode: show all events up to current time
                    filteredEvents = filteredEvents.filter(event => {
                        const eventTime = event.timestamp;
                        const eventDate = new Date(eventTime).toLocaleDateString();
                        const isInRange = eventTime <= currentTime;
                        // Removed verbose event logging to reduce console clutter
                        return isInRange;
                    });
                } else {
                    // Non-cumulative mode: show only events at current time point (within a small window)
                    const timeWindow = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
                    filteredEvents = filteredEvents.filter(event => {
                        const eventTime = event.timestamp;
                        const eventDate = new Date(eventTime).toLocaleDateString();
                        const isAtCurrentTime = Math.abs(eventTime - currentTime) <= timeWindow;
                        return isAtCurrentTime;
                    });
                }
            }
            
            // Create markers for filtered events
            // console.log('🎯 Creating markers for', filteredEvents.length, 'filtered events');
            filteredEvents.forEach(event => {
                // Use location data from the timeline event (which now includes actual tap data)
                if (event.latitude && event.longitude) {
                    const location = {
                        latitude: event.latitude,
                        longitude: event.longitude,
                        location: event.location || 'Unknown location'
                    };
                    addTapMarker(location, event);
                } else {
                    console.log('Event missing latitude/longitude:', event);
                }
            });
            
            // Update stats
            updateStats(filteredEvents);
            
            // Don't auto-fit map on timeline changes - let user control the view
            // Only fit bounds when explicitly requested or when switching modes
        }
        
        // Add tap marker to map
        function addTapMarker(location, event) {
            
            // Default white for global mode
            let markerColor = '#ffffff';
            let fillColor = '#ffffff';
            
            if (currentMode === 'user' && selectedUserId && !globalViewEnabled) {
                const sourceUserId = event.source_id;
                const targetUserId = event.target_id;
                
                // Determine the degree based on the actual filtering logic
                if (sourceUserId === selectedUserId || targetUserId === selectedUserId) {
                    // Direct connection to selected user = 1st degree
                    markerColor = '#0E76A8'; // Deep azure blue for 1st degree (strong & trustworthy)
                    fillColor = '#0E76A8';
                } else {
                    // Check if at least one user is a 1st degree connection to selected user (2nd degree)
                    const degreeConnections = calculateDegreeConnections(selectedUserId);
                    if (degreeConnections.degree1.has(sourceUserId) || degreeConnections.degree1.has(targetUserId)) {
                        markerColor = '#3EC1D3'; // Teal/cyan for 2nd degree (lighter connection)
                        fillColor = '#3EC1D3';
                    } else if (degreeConnections.degree2.has(sourceUserId) || degreeConnections.degree2.has(targetUserId)) {
                        markerColor = '#9BE3DE'; // Pale aqua for 3rd degree (far/distant)
                        fillColor = '#9BE3DE';
                    }
                }
            }
            
            // Determine marker size based on screen size
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            const markerRadius = isMobile ? 8 : 4;
            
            const marker = L.circleMarker([location.latitude, location.longitude], {
                radius: markerRadius,
                fillColor: fillColor,
                color: markerColor,
                weight: 2, /* Further reduced from 3 */
                opacity: 0.8,
                fillOpacity: 0.7
            }).addTo(map);
            
            // Store tap data reference for circle detection
            marker._tapData = event;
            
            
            // Debug: Log event data to see what fields are available
            
            // Create popup content showing the connection
            const venueInfo = event.venue_context || {};
            const venueName = venueInfo.venue_name || 'Unknown Location';
            const venueCategory = venueInfo.venue_category || 'unknown';
            const venueDisplay = venueCategory !== 'unknown' ? `${venueName} (${venueCategory})` : venueName;
            
            // Only create popup content and bind it if not in global view
            if (!globalViewEnabled) {
                const popupContent = `
                    <div class="custom-popup">
                        <div class="popup-title">${event.source_name} ↔ ${event.target_name}</div>
                        <div class="popup-info">Location: ${event.formatted_location || location.location}</div>
                        <div class="popup-info">Venue: ${venueDisplay}</div>
                        <div class="popup-info">Time: ${event.formatted_time || 'Unknown'}</div>
                    </div>
                `;
                
                marker.bindPopup(popupContent);
            }
            markers.push(marker);
        }
        
        // Clear all markers
        function clearMarkers() {
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
        }
        
        // Update statistics display
        function updateStats(events) {
            const uniqueUsers = new Set();
            events.forEach(event => {
                uniqueUsers.add(event.source_id);
                uniqueUsers.add(event.target_id);
            });
            
            // Get the appropriate total tap count based on current mode
            let totalTapCount;
            if (globalViewEnabled) {
                // In global view, use all unfiltered data
                totalTapCount = allLocationData.length;
            } else if (currentMode === 'user' && selectedUserId) {
                // In user mode, count only taps involving the selected user
                totalTapCount = completeLocationData.filter(tap => 
                    tap.user1_id === selectedUserId || tap.user2_id === selectedUserId
                ).length;
            } else {
                // In global mode, use all taps
                totalTapCount = completeLocationData.length;
            }
            
            document.getElementById('visibleTaps').textContent = events.length;
            document.getElementById('totalTaps').textContent = totalTapCount;
            document.getElementById('activeUsers').textContent = uniqueUsers.size;
            
        }
        
        // Set view mode (global or user-centric) - DEACTIVATED: Always user-centric
        function setMode(mode) {
            // Force user-centric mode
            currentMode = 'user';
            
            // Always show user search and degree filters
            const userSearchGroup = document.getElementById('userSearchGroup');
            const degreeFiltersGroup = document.getElementById('degreeFiltersGroup');
            const profileSection = document.getElementById('profileSection');
            
            userSearchGroup.style.display = 'block';
            degreeFiltersGroup.style.display = 'block';
            profileSection.style.display = 'none'; // Hide profile section initially
            initUserSearch();
            
            // Reset Show All toggle when switching modes
            if (showAllEnabled) {
                toggleShowAll(); // This will turn off Show All mode
            }
            
            // Reset timeline sliders to full range (0-100%)
            const leftSlider = document.getElementById('timelineSliderLeft');
            const rightSlider = document.getElementById('timelineSliderRight');
            if (leftSlider && rightSlider) {
                leftSlider.value = 0;
                rightSlider.value = 100;
                updateDualTimelineDisplay(0, 100);
                updateRangeHighlighting(0, 100);
            }
            
            // Don't auto-fit map when switching modes - let user control the view
        }
        
        // Map control functions
        function fitMapToBounds() {
            console.log('fitMapToBounds called, markers.length:', markers.length);
            if (markers.length > 0) {
                const group = new L.featureGroup(markers);
                const bounds = group.getBounds();
                console.log('Map bounds:', bounds);
                
                // Add more padding and limit zoom level for better user experience
                const paddedBounds = bounds.pad(0.2); // More padding
                map.fitBounds(paddedBounds, {
                    maxZoom: 10, // Limit maximum zoom level
                    animate: true
                });
                console.log('Map fitted to bounds with padding and zoom limit');
            } else {
                console.log('No markers to fit bounds to');
            }
        }
        
        function resetMapView() {
            map.setView([39.8283, -98.5795], 4);
        }
        
        function toggleClustering() {
            clusteringEnabled = !clusteringEnabled;
            console.log('Clustering:', clusteringEnabled ? 'enabled' : 'disabled');
            // TODO: Implement clustering logic
        }
        
        // Toggle Show All functionality
        function toggleShowAll() {
            showAllEnabled = !showAllEnabled;
            const showAllBtn = document.getElementById('showAllBtn');
            const leftSlider = document.getElementById('timelineSliderLeft');
            const rightSlider = document.getElementById('timelineSliderRight');
            
            // Update button appearance
            if (showAllEnabled) {
                showAllBtn.classList.add('active');
                showAllBtn.textContent = 'Show Timeline';
                // Disable timeline sliders
                if (leftSlider && rightSlider) {
                    leftSlider.disabled = true;
                    rightSlider.disabled = true;
                    leftSlider.style.opacity = '0.5';
                    rightSlider.style.opacity = '0.5';
                    // Set timeline to full range
                    leftSlider.value = 0;
                    rightSlider.value = 100;
                }
            } else {
                showAllBtn.classList.remove('active');
                showAllBtn.textContent = 'Show All';
                // Enable timeline sliders
                if (leftSlider && rightSlider) {
                    leftSlider.disabled = false;
                    rightSlider.disabled = false;
                    leftSlider.style.opacity = '1';
                    rightSlider.style.opacity = '1';
                }
            }
            
            // Update display
            if (leftSlider && rightSlider) {
                updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
            }
        }
        
        // Activate Global View functionality
        function activateGlobalView() {
            // Toggle global view mode
            globalViewEnabled = !globalViewEnabled;
            const globalViewBtn = document.getElementById('globalViewBtn');
            
            // Update button appearance
            if (globalViewEnabled) {
                globalViewBtn.classList.add('active');
                globalViewBtn.textContent = 'Back to User View';
                // Hide user-specific elements
                document.getElementById('profileSection').style.display = 'none';
                document.getElementById('degreeFiltersGroup').style.display = 'none';
                // Hide search functionality in global mode
                document.querySelector('.search-control-floating').style.display = 'none';
                // Enable showAll mode to skip timeline filtering (like Global version)
                showAllEnabled = true;
                // Set timeline to full range to show all data in global view
                const leftSlider = document.getElementById('timelineSliderLeft');
                const rightSlider = document.getElementById('timelineSliderRight');
                if (leftSlider && rightSlider) {
                    leftSlider.value = 0;
                    rightSlider.value = 100;
                    updateDualTimelineDisplay(0, 100);
                    updateRangeHighlighting(0, 100);
                }
            } else {
                globalViewBtn.classList.remove('active');
                globalViewBtn.textContent = 'See Full Arc Network';
                // Show user-specific elements
                document.getElementById('profileSection').style.display = 'block';
                document.getElementById('degreeFiltersGroup').style.display = 'block';
                // Show search functionality in user mode
                document.querySelector('.search-control-floating').style.display = 'block';
                // Disable showAll mode when returning to user view
                showAllEnabled = false;
            }
            
            // Update display to show all taps as white nodes
            updateDisplay();
        }
        
        // Find user by name in completeLocationData
        function findUserByName(userName) {
            const seenUsers = new Set();
            const matches = [];
            
            // Safety guard for undefined values
            const lower = v => (v ?? '').toString().toLowerCase();
            
            // Search through all users in tap data
            completeLocationData.forEach(tap => {
                // Check user1
                if (lower(tap.user1_name).includes(userName.toLowerCase()) && !seenUsers.has(tap.user1_id)) {
                    matches.push({
                        id: tap.user1_id,
                        name: tap.user1_name,
                        location: tap.user1_home || 'Unknown location'
                    });
                    seenUsers.add(tap.user1_id);
                }
                
                // Check user2
                if (lower(tap.user2_name).includes(userName.toLowerCase()) && !seenUsers.has(tap.user2_id)) {
                    matches.push({
                        id: tap.user2_id,
                        name: tap.user2_name,
                        location: tap.user2_home || 'Unknown location'
                    });
                    seenUsers.add(tap.user2_id);
                }
            });
            
            // Find exact match first
            const exactMatch = matches.find(user => 
                user.name.toLowerCase().trim() === userName.toLowerCase().trim()
            );
            
            if (exactMatch) {
                return exactMatch;
            }
            
            // If no exact match, return the first partial match
            return matches.length > 0 ? matches[0] : null;
        }
        
        // Toggle search functionality for floating search bar
        function toggleSearch() {
            const searchToggleBtn = document.getElementById('searchToggleBtn');
            const searchInput = document.getElementById('expandableSearchInput');
            const searchResults = document.getElementById('expandableSearchResults');
            
            // Don't close if there's recent keyboard activity (prevents space key from closing)
            if (searchToggleBtn.classList.contains('expanded') && !recentKeyboardActivity) {
                // Close search
                searchToggleBtn.classList.remove('expanded');
                searchInput.value = '';
                searchResults.classList.remove('show');
                searchResults.innerHTML = '';
            } else if (!searchToggleBtn.classList.contains('expanded')) {
                // Open search
                searchToggleBtn.classList.add('expanded');
                // Let mobile browser handle focus naturally - no forced focus
            }
        }
        
        // Track recent keyboard activity to prevent space key from closing search
        let recentKeyboardActivity = false;
        
        // Initialize floating search functionality
        function initFloatingSearch() {
            const searchInput = document.getElementById('expandableSearchInput');
            const searchResults = document.getElementById('expandableSearchResults');
            
            searchInput.addEventListener('input', function() {
                // Mark recent keyboard activity
                recentKeyboardActivity = true;
                setTimeout(() => { 
                    recentKeyboardActivity = false; 
                }, 100);
                const query = this.value.toLowerCase().trim();
                
                if (query.length < 2) {
                    searchResults.classList.remove('show');
                    searchResults.innerHTML = '';
                    return;
                }
                
                // Search through degree connections of original user only
                const matches = [];
                const seenUsers = new Set();
                
                // Safety guard for undefined values
                const lower = v => (v ?? '').toString().toLowerCase();
                
                // Only search if we have an original user
                if (originalUserId) {
                    // Get degree connections for the original user
                    const degreeConnections = calculateDegreeConnections(originalUserId);
                    const allDegreeUsers = new Set([
                        ...degreeConnections.degree1,
                        ...degreeConnections.degree2,
                        ...degreeConnections.degree3
                    ]);
                    
                    // Search through degree connections only
                    completeLocationData.forEach(tap => {
                        // Check user1
                        if (lower(tap.user1_name).includes(query) && 
                            !seenUsers.has(tap.user1_id) && 
                            allDegreeUsers.has(tap.user1_id)) {
                            
                            // Determine degree level
                            let degreeLevel = '';
                            if (degreeConnections.degree1.has(tap.user1_id)) degreeLevel = '1st';
                            else if (degreeConnections.degree2.has(tap.user1_id)) degreeLevel = '2nd';
                            else if (degreeConnections.degree3.has(tap.user1_id)) degreeLevel = '3rd';
                            
                            matches.push({
                                id: tap.user1_id,
                                name: tap.user1_name,
                                location: tap.user1_home || 'Unknown location',
                                degree: degreeLevel
                            });
                            seenUsers.add(tap.user1_id);
                        }
                        
                        // Check user2
                        if (lower(tap.user2_name).includes(query) && 
                            !seenUsers.has(tap.user2_id) && 
                            allDegreeUsers.has(tap.user2_id)) {
                            
                            // Determine degree level
                            let degreeLevel = '';
                            if (degreeConnections.degree1.has(tap.user2_id)) degreeLevel = '1st';
                            else if (degreeConnections.degree2.has(tap.user2_id)) degreeLevel = '2nd';
                            else if (degreeConnections.degree3.has(tap.user2_id)) degreeLevel = '3rd';
                            
                            matches.push({
                                id: tap.user2_id,
                                name: tap.user2_name,
                                location: tap.user2_home || 'Unknown location',
                                degree: degreeLevel
                            });
                            seenUsers.add(tap.user2_id);
                        }
                    });
                }
                
                // Display results
                if (matches.length > 0) {
                    searchResults.innerHTML = matches.slice(0, 10).map(user => `
                        <div class="search-result-item" onclick="selectSearchedUser('${user.id}', '${user.name}')">
                            <div class="search-result-name">${user.name}</div>
                            <div class="search-result-info">${user.location} • ${user.degree} degree</div>
                        </div>
                    `).join('');
                    searchResults.classList.add('show');
                } else {
                    searchResults.innerHTML = '<div class="search-result-item" style="color: var(--fg-muted); cursor: default;">No connections found</div>';
                    searchResults.classList.add('show');
                }
            });
            
            // Hide results when clicking outside (but not during keyboard activity)
            document.addEventListener('click', function(e) {
                const searchToggleBtn = document.getElementById('searchToggleBtn');
                
                // Check if click is inside search area
                const isInsideSearchArea = searchToggleBtn.contains(e.target) || 
                                        searchInput.contains(e.target) || 
                                        searchResults.contains(e.target);
                
                // Only close if it's a mouse click, not during recent keyboard activity, and not inside search area
                if (e.type === 'click' && !isInsideSearchArea && !recentKeyboardActivity) {
                    searchResults.classList.remove('show');
                    if (searchToggleBtn.classList.contains('expanded')) {
                        searchToggleBtn.classList.remove('expanded');
                        searchInput.value = '';
                        searchResults.innerHTML = '';
                    }
                }
            });
            
            // Keyboard handling
            searchInput.addEventListener('keydown', function(e) {
                // Mark recent keyboard activity
                recentKeyboardActivity = true;
                setTimeout(() => { 
                    recentKeyboardActivity = false; 
                }, 100);
                
                if (e.code === 'Space') {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
                
                if (e.key === 'Escape') {
                    // Close search on escape
                    const searchToggleBtn = document.getElementById('searchToggleBtn');
                    searchToggleBtn.classList.remove('expanded');
                    this.value = '';
                    searchResults.classList.remove('show');
                    searchResults.innerHTML = '';
                    
                    // Also close drawing results if open
                    closeCircleResults();
                    
                    // Cancel any active drawing
                    if (isDrawing) {
                        cancelFreehandDrawing();
                    }
                }
            });
            
            searchInput.addEventListener('keyup', function(e) {
                // Mark recent keyboard activity
                recentKeyboardActivity = true;
                setTimeout(() => { 
                    recentKeyboardActivity = false; 
                }, 100);
                
                if (e.code === 'Space') {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            });
            
            searchInput.addEventListener('keypress', function(e) {
                // Mark recent keyboard activity
                recentKeyboardActivity = true;
                setTimeout(() => { 
                    recentKeyboardActivity = false; 
                }, 100);
                
                if (e.code === 'Space') {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            });
            
            // Focus handling
            searchInput.addEventListener('focus', function() {
                if (this.value.length >= 2) {
                    searchResults.classList.add('show');
                }
            });
            
            // Let mobile browser handle focus naturally - no forced focus
            // searchInput.addEventListener('touchstart', function() {
            //     this.focus();
            // });
            
            // Prevent clicks inside search input from bubbling up
            searchInput.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // Prevent clicks inside search results from bubbling up
            searchResults.addEventListener('click', function(e) {
                e.stopPropagation();
            });
        }
        
        // Initialize user search functionality
        function initUserSearch() {
            const searchInput = document.getElementById('userSearchInput');
            const searchResults = document.getElementById('searchResults');
            
            searchInput.addEventListener('input', function() {
                const query = this.value.toLowerCase().trim();
                
                if (query.length < 2) {
                    searchResults.innerHTML = '';
                    return;
                }
                
                // Search through all users in edges data
                const matches = [];
                const seenUsers = new Set();
                
                // Safety guard for undefined values
                const lower = v => (v ?? '').toString().toLowerCase();
                
                // Search through all users in tap data (which has home locations)
                completeLocationData.forEach(tap => {
                    // Check user1
                    if (lower(tap.user1_name).includes(query) && !seenUsers.has(tap.user1_id)) {
                        matches.push({
                            id: tap.user1_id,
                            name: tap.user1_name,
                            location: tap.user1_home || 'Unknown location'
                        });
                        seenUsers.add(tap.user1_id);
                    }
                    
                    // Check user2
                    if (lower(tap.user2_name).includes(query) && !seenUsers.has(tap.user2_id)) {
                        matches.push({
                            id: tap.user2_id,
                            name: tap.user2_name,
                            location: tap.user2_home || 'Unknown location'
                        });
                        seenUsers.add(tap.user2_id);
                    }
                });
                
                // Display results
                if (matches.length > 0) {
                    searchResults.innerHTML = matches.slice(0, 10).map(user => `
                        <div class="search-result" onclick="selectUser('${user.id}', '${user.name}')">
                            <div class="user-name">${user.name}</div>
                            <div class="user-location">${user.location}</div>
                        </div>
                    `).join('');
                    
                    // Debug: Log container info
                } else {
                    searchResults.innerHTML = '<div class="search-result" style="color: var(--fg-muted); cursor: default;">No users found</div>';
                }
            });
            
            // Clear search when switching modes
            searchInput.value = '';
            searchResults.innerHTML = '';
        }
        
        // Select a user for user-centric mode
        function selectUser(userId, userName) {
            selectedUserId = userId;
            
            // Set original user variables (for search functionality)
            originalUserId = userId;
            originalUserName = userName;
            currentlyViewingUserId = userId;
            isViewingSearchedUser = false;
            
            // Update search input
            document.getElementById('userSearchInput').value = userName;
            document.getElementById('searchResults').innerHTML = '';
            
            // Show profile section and update profile data
            updateUserProfile(userId, userName);
            
            // Initialize degree filters for the selected user
            initDegreeFilters();
            
            // Regenerate timeline for selected user
            createTimelineData(userId);
            
            // Reset timeline sliders to full range (0-100%)
            const leftSlider = document.getElementById('timelineSliderLeft');
            const rightSlider = document.getElementById('timelineSliderRight');
            if (leftSlider && rightSlider) {
                leftSlider.value = 0;
                rightSlider.value = 100;
                updateDualTimelineDisplay(0, 100);
                updateRangeHighlighting(0, 100);
            }
            
            // Don't auto-fit map when selecting users - let user control the view
            
        }
        
        // Select searched user (shows only their 1st degree connections)
        function selectSearchedUser(userId, userName) {
            console.log('🔍 Selecting searched user:', userName, 'ID:', userId);
            
            // Set state variables
            currentlyViewingUserId = userId;
            isViewingSearchedUser = true;
            
            // Collapse search bar
            const searchToggleBtn = document.getElementById('searchToggleBtn');
            const searchInput = document.getElementById('expandableSearchInput');
            const searchResults = document.getElementById('expandableSearchResults');
            
            searchToggleBtn.classList.remove('expanded');
            searchInput.value = '';
            searchResults.classList.remove('show');
            searchResults.innerHTML = '';
            
            // Show only the searched user's 1st degree connections
            const searchedUserConnections = calculateDegreeConnections(userId);
            const firstDegreeConnections = searchedUserConnections.degree1;
            
            // Filter events to show only the searched user's 1st degree connections
            const filteredEvents = completeLocationData.filter(event => {
                const sourceUserId = event.user1_id;
                const targetUserId = event.user2_id;
                
                // Show events where the searched user is involved AND the other user is their 1st degree connection
                return (sourceUserId === userId && firstDegreeConnections.has(targetUserId)) ||
                       (targetUserId === userId && firstDegreeConnections.has(sourceUserId));
            }).map(tap => ({
                source_id: tap.user1_id,
                target_id: tap.user2_id,
                source_name: tap.user1_name,
                target_name: tap.user2_name,
                latitude: tap.latitude,
                longitude: tap.longitude,
                location: tap.location,
                formatted_location: tap.formatted_location,
                venue_context: tap.venue_context,
                time: tap.time,
                formatted_time: tap.formatted_time,
                timestamp: new Date(tap.time).getTime()
            }));
            
            // Update markers with searched user's connections
            updateMarkersWithSearchedUser(filteredEvents);
            
            console.log('🔍 Showing searched user connections:', filteredEvents.length, 'events');
        }
        
        // Update markers for searched user (1st degree only)
        function updateMarkersWithSearchedUser(filteredEvents) {
            // Clear existing markers
            clearMarkers();
            
            // Create markers for searched user's connections
            filteredEvents.forEach(event => {
                const location = {
                    latitude: event.latitude,
                    longitude: event.longitude,
                    location: event.location,
                    formatted_location: event.formatted_location,
                    venue_context: event.venue_context
                };
                
                // Create marker for this connection
                // Determine marker size based on screen size
                const isMobile = window.matchMedia('(max-width: 900px)').matches;
                const markerRadius = isMobile ? 8 : 4;
                
                const marker = L.circleMarker([location.latitude, location.longitude], {
                    radius: markerRadius,
                    fillColor: '#0E76A8', // Deep azure blue for searched user's connections
                    color: '#0E76A8',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.6
                });
                
                // Add popup
                const popupContent = `
                    <div class="custom-popup">
                        <div class="popup-title">${event.source_name} ↔ ${event.target_name}</div>
                        <div class="popup-info">Location: ${event.formatted_location || location.location}</div>
                        <div class="popup-info">Time: ${event.formatted_time}</div>
                    </div>
                `;
                
                marker.bindPopup(popupContent);
                marker.addTo(map);
                markers.push(marker);
            });
        }
        
        // Revert to original user view
        function revertToOriginalUser() {
            console.log('🔄 Reverting to original user:', originalUserName);
            
            // Reset state variables
            currentlyViewingUserId = originalUserId;
            isViewingSearchedUser = false;
            
            // Clear search bar
            const searchInput = document.getElementById('expandableSearchInput');
            const searchResults = document.getElementById('expandableSearchResults');
            searchInput.value = '';
            searchResults.classList.remove('show');
            searchResults.innerHTML = '';
            
            // Reset to original user's view using existing logic
            if (originalUserId && originalUserName) {
                // Use the existing selectUser function to restore original user's view
                selectUser(originalUserId, originalUserName);
            }
            
            console.log('🔄 Reverted to original user view');
        }
        
        // Setup control panel click listeners for reversion
        function setupControlPanelReversion() {
            // Get all control panel elements
            const controlPanel = document.querySelector('.sidebar');
            const profileSection = document.getElementById('profileSection');
            const degreeFiltersGroup = document.getElementById('degreeFiltersGroup');
            const timelineControlGroup = document.querySelector('.timeline-control-group');
            
            // Add click listeners to control panel elements
            const controlElements = [
                controlPanel,
                profileSection,
                degreeFiltersGroup,
                timelineControlGroup
            ];
            
            controlElements.forEach(element => {
                if (element) {
                    element.addEventListener('click', function(e) {
                        // Only revert if we're currently viewing a searched user
                        if (isViewingSearchedUser) {
                            console.log('🔄 Control panel clicked - reverting to original user');
                            revertToOriginalUser();
                        }
                    });
                }
            });
        }
        
        // Update user profile section
        function updateUserProfile(userId, userName) {
            // Show profile section
            const profileSection = document.getElementById('profileSection');
            profileSection.style.display = 'block';
            
            // Update profile header
            document.getElementById('profileName').textContent = userName;
            
            // Calculate user stats (total lifetime stats for initial display)
            const userTaps = completeLocationData.filter(tap => 
                tap.user1_id === userId || tap.user2_id === userId
            ).length;
            
            // Calculate connections (unique users this user has tapped with)
            const connectedUserIds = new Set();
            completeLocationData.forEach(tap => {
                if (tap.user1_id === userId) {
                    connectedUserIds.add(tap.user2_id);
                } else if (tap.user2_id === userId) {
                    connectedUserIds.add(tap.user1_id);
                }
            });
            const connectionCount = connectedUserIds.size;
            
            // Determine activity level
            let activityLevel = 'low';
            if (userTaps > 50) activityLevel = 'high';
            else if (userTaps > 20) activityLevel = 'medium';
            
            // Update profile data
            document.getElementById('profileActivity').textContent = `Activity Level: ${activityLevel}`;
            document.getElementById('profileTaps').textContent = userTaps;
            document.getElementById('profileConnections').textContent = connectionCount;
        }
        
        // Update profile stats based on timeline position
        function updateProfileStats(userId, currentTime) {
            // Calculate timeline-based stats for the selected user
            let timelineTaps = 0;
            let timelineConnections = new Set();
            
            // Filter events up to the current timeline point
            const filteredEvents = completeLocationData.filter(tap => {
                const tapTime = new Date(tap.time).getTime();
                return tapTime <= currentTime && (tap.user1_id === userId || tap.user2_id === userId);
            });
            
            // Count taps and connections
            filteredEvents.forEach(tap => {
                timelineTaps++;
                timelineConnections.add(tap.user1_id);
                timelineConnections.add(tap.user2_id);
            });
            
            // Remove the user themselves from connections count
            timelineConnections.delete(userId);
            const connectionCount = timelineConnections.size;
            
            // Update the profile stats display
            document.getElementById('profileTaps').textContent = timelineTaps;
            document.getElementById('profileConnections').textContent = connectionCount;
        }
        
        // Update profile stats for dual timeline system
        function updateProfileStatsForTimeline(userId, startTime, endTime) {
            let timelineTaps = 0;
            let timelineConnections = new Set();
            
            // Filter events within the timeline range
            const filteredEvents = completeLocationData.filter(tap => {
                const tapTime = new Date(tap.time).getTime();
                return tapTime >= startTime && tapTime <= endTime && (tap.user1_id === userId || tap.user2_id === userId);
            });
            
            // Count taps and connections
            filteredEvents.forEach(tap => {
                timelineTaps++;
                timelineConnections.add(tap.user1_id);
                timelineConnections.add(tap.user2_id);
            });
            
            // Remove the user themselves from connections count
            timelineConnections.delete(userId);
            const connectionCount = timelineConnections.size;
            
            // Update the profile stats display
            document.getElementById('profileTaps').textContent = timelineTaps;
            document.getElementById('profileConnections').textContent = connectionCount;
        }
        
        // Update view options numbers based on timeline and degree filtering
        function updateViewOptionsNumbers(filteredEvents, startTime, endTime) {
            
            // For user mode with degree filtering, count only degree-filtered connections
            if (currentMode === 'user' && selectedUserId && !globalViewEnabled) {
                // Get degree connections for the selected user
                if (!window.cachedDegreeConnections || window.cachedDegreeConnections.userId !== selectedUserId) {
                    window.cachedDegreeConnections = {
                        userId: selectedUserId,
                        connections: calculateDegreeConnections(selectedUserId)
                    };
                }
                const degreeConnections = window.cachedDegreeConnections.connections;
                
                
                // Filter events by degree connections that are actually visible
                const degreeFilteredEvents = filteredEvents.filter(event => {
                    const sourceUserId = event.user1_id;
                    const targetUserId = event.user2_id;
                    
                    // Quick check: if either user is the selected user, it's always 1st degree
                    if (sourceUserId === selectedUserId || targetUserId === selectedUserId) {
                        return degreeFilters.degree1;
                    }
                    
                    // For other connections, check degree levels efficiently
                    const sourceInDegree1 = degreeConnections.degree1.has(sourceUserId);
                    const targetInDegree1 = degreeConnections.degree1.has(targetUserId);
                    const sourceInDegree2 = degreeConnections.degree2.has(sourceUserId);
                    const targetInDegree2 = degreeConnections.degree2.has(targetUserId);
                    
                    // 2nd degree: at least one user is 1st degree connection
                    if (degreeFilters.degree2 && (sourceInDegree1 || targetInDegree1)) {
                        return true;
                    }
                    
                    // 3rd degree: at least one user is 2nd degree connection
                    if (degreeFilters.degree3 && (sourceInDegree2 || targetInDegree2)) {
                        return true;
                    }
                    
                    return false;
                });
                
                // Count visible taps (degree-filtered events within timeline range)
                const visibleTaps = degreeFilteredEvents.length;
                
                // Count total taps (all degree-filtered events for this user)
                const allDegreeFilteredEvents = completeLocationData.filter(event => {
                    const sourceUserId = event.user1_id;
                    const targetUserId = event.user2_id;
                    
                    // Quick check: if either user is the selected user, it's always 1st degree
                    if (sourceUserId === selectedUserId || targetUserId === selectedUserId) {
                        return degreeFilters.degree1;
                    }
                    
                    // For other connections, check degree levels efficiently
                    const sourceInDegree1 = degreeConnections.degree1.has(sourceUserId);
                    const targetInDegree1 = degreeConnections.degree1.has(targetUserId);
                    const sourceInDegree2 = degreeConnections.degree2.has(sourceUserId);
                    const targetInDegree2 = degreeConnections.degree2.has(targetUserId);
                    
                    // 2nd degree: at least one user is 1st degree connection
                    if (degreeFilters.degree2 && (sourceInDegree1 || targetInDegree1)) {
                        return true;
                    }
                    
                    // 3rd degree: at least one user is 2nd degree connection
                    if (degreeFilters.degree3 && (sourceInDegree2 || targetInDegree2)) {
                        return true;
                    }
                    
                    return false;
                });
                
                const totalTaps = allDegreeFilteredEvents.length;
                
                // Count active users (unique users in degree-filtered events)
                const activeUsers = new Set();
                degreeFilteredEvents.forEach(event => {
                    if (event.user1_id) activeUsers.add(event.user1_id);
                    if (event.user2_id) activeUsers.add(event.user2_id);
                });
                
                
                // Update the display
                document.getElementById('visibleTaps').textContent = visibleTaps;
                document.getElementById('totalTaps').textContent = totalTaps;
                document.getElementById('activeUsers').textContent = activeUsers.size;
                
            } else {
                // For global mode or non-user mode, use original logic
                const visibleTaps = filteredEvents.length;
                
                let totalTaps;
                if (globalViewEnabled) {
                    totalTaps = allLocationData.length;
                } else {
                    totalTaps = completeLocationData.length;
                }
                
                // Count active users (unique users in filtered events)
                const activeUsers = new Set();
                filteredEvents.forEach(event => {
                    if (event.user1_id) activeUsers.add(event.user1_id);
                    if (event.user2_id) activeUsers.add(event.user2_id);
                });
                
                // Update the display
                document.getElementById('visibleTaps').textContent = visibleTaps;
                document.getElementById('totalTaps').textContent = totalTaps;
                document.getElementById('activeUsers').textContent = activeUsers.size;
            }
        }
        
        // Initialize degree filters
        function initDegreeFilters() {
            const degreeFiltersGroup = document.getElementById('degreeFiltersGroup');
            const degree1Check = document.getElementById('degree1Check');
            const degree2Check = document.getElementById('degree2Check');
            const degree3Check = document.getElementById('degree3Check');
            
            // Show degree filters in user mode
            degreeFiltersGroup.style.display = 'block';
            
            // Set default state (1st degree checked)
            degree1Check.checked = true;
            degree2Check.checked = false;
            degree3Check.checked = false;
            degreeFilters.degree1 = true;
            degreeFilters.degree2 = false;
            degreeFilters.degree3 = false;
            
            // Add event listeners
            degree1Check.addEventListener('change', updateDegreeFilters);
            degree2Check.addEventListener('change', updateDegreeFilters);
            degree3Check.addEventListener('change', updateDegreeFilters);
        }
        
        // Update degree filters
        function updateDegreeFilters() {
            console.log('updateDegreeFilters called!');
            const degree1Check = document.getElementById('degree1Check');
            const degree2Check = document.getElementById('degree2Check');
            const degree3Check = document.getElementById('degree3Check');
            
            degreeFilters.degree1 = degree1Check.checked;
            degreeFilters.degree2 = degree2Check.checked;
            degreeFilters.degree3 = degree3Check.checked;
            
            console.log('Degree filters updated:', degreeFilters);
            
            // Clear degree connection cache since filtering logic changed
            if (window.cachedDegreeConnections) {
                window.cachedDegreeConnections = null;
            }
            
            // Immediate update for degree filters (no debouncing)
            const leftSlider = document.getElementById('timelineSliderLeft');
            const rightSlider = document.getElementById('timelineSliderRight');
            if (leftSlider && rightSlider) {
                // Clear any pending timeline updates to prevent conflicts
                if (window.timelineUpdateTimeout) {
                    clearTimeout(window.timelineUpdateTimeout);
                }
                
                // Immediate update for responsive degree filtering
                performTimelineUpdate(parseInt(leftSlider.value), parseInt(rightSlider.value));
            }
        }
        
        // Calculate degree connections for a user based on complete network
        function calculateDegreeConnections(userId) {
            const connections = {
                degree1: new Set(),
                degree2: new Set(),
                degree3: new Set()
            };
            
            // Optimized: Single pass through data for better performance
            const userConnections = new Map(); // userId -> Set of connected users
            
            // Build connection map in one pass
            completeLocationData.forEach(tap => {
                const user1 = tap.user1_id;
                const user2 = tap.user2_id;
                
                if (!userConnections.has(user1)) {
                    userConnections.set(user1, new Set());
                }
                if (!userConnections.has(user2)) {
                    userConnections.set(user2, new Set());
                }
                
                userConnections.get(user1).add(user2);
                userConnections.get(user2).add(user1);
            });
            
            // Find 1st degree connections (direct connections to the user)
            if (userConnections.has(userId)) {
                userConnections.get(userId).forEach(connectedUser => {
                    connections.degree1.add(connectedUser);
                });
            }
            
            // Find 2nd degree connections (connections of 1st degree users)
            connections.degree1.forEach(firstDegreeUser => {
                if (userConnections.has(firstDegreeUser)) {
                    userConnections.get(firstDegreeUser).forEach(connectedUser => {
                        if (connectedUser !== userId) {
                            connections.degree2.add(connectedUser);
                        }
                    });
                }
            });
            
            // Find 3rd degree connections (connections of 2nd degree users)
            connections.degree2.forEach(secondDegreeUser => {
                if (userConnections.has(secondDegreeUser)) {
                    userConnections.get(secondDegreeUser).forEach(connectedUser => {
                        if (connectedUser !== userId && !connections.degree1.has(connectedUser)) {
                            connections.degree3.add(connectedUser);
                        }
                    });
                }
            });
            
            return connections;
        }
        
        // Check if a tap involves users of the specified degree
        function isTapInDegree(tap, userId, degreeConnections, degree) {
            const otherUserId = tap.user1_id === userId ? tap.user2_id : tap.user1_id;
            
            switch(degree) {
                case 1:
                    return degreeConnections.degree1.has(otherUserId);
                case 2:
                    return degreeConnections.degree2.has(otherUserId);
                case 3:
                    return degreeConnections.degree3.has(otherUserId);
                default:
                    return false;
            }
        }
        
        // Update display
        function updateDisplay() {
            // Update header stats
            // Count unique users from tap data
            const dataToUse = globalViewEnabled ? allLocationData : completeLocationData;
            const uniqueUsers = new Set();
            dataToUse.forEach(tap => {
                uniqueUsers.add(tap.user1_id);
                uniqueUsers.add(tap.user2_id);
            });
            const totalUsers = uniqueUsers.size;
            const totalTaps = dataToUse.length; // Use actual tap count instead of edges
            
            // Update loading stats
            document.getElementById('loadingStats').textContent = 
                `Loaded ${totalUsers} users with location data`;
            
            // Update timeline display to show initial markers
            const leftSlider = document.getElementById('timelineSliderLeft');
            const rightSlider = document.getElementById('timelineSliderRight');
            if (leftSlider && rightSlider) {
                updateDualTimelineDisplay(parseInt(leftSlider.value), parseInt(rightSlider.value));
            }
        }
        
        // Reset browser zoom and viewport
        function resetBrowserView() {
            // Multiple approaches to force browser zoom reset
            
            // Method 1: CSS zoom reset
            document.body.style.zoom = '1';
            document.body.style.transform = 'scale(1)';
            document.body.style.transformOrigin = 'top left';
            
            // Method 2: Force viewport reset
            let viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            } else {
                viewport = document.createElement('meta');
                viewport.name = 'viewport';
                viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                document.head.appendChild(viewport);
            }
            
            // Method 3: Force document zoom reset
            document.documentElement.style.zoom = '1';
            document.documentElement.style.transform = 'scale(1)';
            
            // Method 4: Force window resize to trigger browser zoom reset
            window.dispatchEvent(new Event('resize'));
            
            // Method 5: Force a reflow and repaint
            document.body.offsetHeight;
            document.body.style.display = 'none';
            document.body.offsetHeight;
            document.body.style.display = '';
            
        }
        
        // COMPUTED STYLE AUDIT FUNCTIONS
        function dumpComputed(el) {
            if (!el) return { node: 'NOT_FOUND', error: 'Element not found' };
            const cs = getComputedStyle(el);
            return {
                node: el.className || el.id || el.tagName,
                width: el.clientWidth, 
                height: el.clientHeight,
                fontFamily: cs.fontFamily, 
                fontSize: cs.fontSize, 
                lineHeight: cs.lineHeight,
                letterSpacing: cs.letterSpacing, 
                boxSizing: cs.boxSizing,
                padding: `${cs.paddingTop} ${cs.paddingRight} ${cs.paddingBottom} ${cs.paddingLeft}`,
                margin: `${cs.marginTop} ${cs.marginRight} ${cs.marginBottom} ${cs.marginLeft}`,
                border: `${cs.borderTopWidth} ${cs.borderRightWidth} ${cs.borderBottomWidth} ${cs.borderLeftWidth}`,
                transform: cs.transform,
                zoom: cs.zoom,
                minWidth: cs.minWidth
            };
        }

        function auditAncestors(el) {
            const chain = [];
            while (el) {
                const cs = getComputedStyle(el);
                chain.push({
                    node: el.id || el.className || el.tagName,
                    fontSize: cs.fontSize, 
                    lineHeight: cs.lineHeight, 
                    letterSpacing: cs.letterSpacing,
                    boxSizing: cs.boxSizing, 
                    transform: cs.transform, 
                    zoom: cs.zoom,
                    minWidth: cs.minWidth, 
                    width: cs.width,
                    height: cs.height
                });
                el = el.parentElement;
            }
            return chain;
        }

        function runStyleAudit() {
            // Style audit function - debugging logs removed for production
        }

        // Run audit after profile section becomes visible
        function runAuditWhenReady() {
            const profileSection = document.querySelector('.profile-section');
            const profileName = document.querySelector('#profileName');
            const statCard = document.querySelector('.stat-card');
            
            if (profileSection && profileSection.style.display !== 'none' && 
                profileName && profileName.offsetWidth > 0 && 
                statCard && statCard.offsetWidth > 0) {
                runStyleAudit();
            } else {
                // Retry every 500ms until elements are visible
                setTimeout(runAuditWhenReady, 500);
            }
        }

        // Start checking after page loads
        window.addEventListener('load', () => {
            setTimeout(runAuditWhenReady, 1000);
        });

        // Global zoom prevention
        function preventGlobalZoom() {
            // Reset browser view first
            resetBrowserView();
            
            // Prevent zoom on the entire document
            document.addEventListener('wheel', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent touch zoom
            document.addEventListener('touchstart', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', function(e) {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Prevent keyboard zoom
            document.addEventListener('keydown', function(e) {
                if ((e.ctrlKey || e.metaKey) && (e.key === '+' || e.key === '-' || e.key === '=' || e.keyCode === 61 || e.keyCode === 173)) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            console.log('🛡️ Global zoom prevention enabled');
        }
        
        // Manual reset function - call this from console if needed
        window.resetView = function() {
            resetBrowserView();
        };
        
        // Nuclear option - force complete browser zoom reset
        window.forceZoomReset = function() {
            console.log('🚀 Starting nuclear zoom reset...');
            
            // Step 1: Reset all zoom-related styles
            document.body.style.zoom = '1';
            document.body.style.transform = 'scale(1)';
            document.documentElement.style.zoom = '1';
            document.documentElement.style.transform = 'scale(1)';
            
            // Step 2: Force viewport meta tag update
            let viewport = document.querySelector('meta[name="viewport"]');
            if (viewport) {
                viewport.remove();
            }
            viewport = document.createElement('meta');
            viewport.name = 'viewport';
            viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            document.head.appendChild(viewport);
            
            // Step 3: Force multiple resize events
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    window.dispatchEvent(new Event('resize'));
                }, i * 100);
            }
            
            // Step 4: Force complete page reflow
            setTimeout(() => {
                document.body.style.display = 'none';
                setTimeout(() => {
                    document.body.style.display = '';
                    console.log('💥 Nuclear zoom reset completed - sidebar should now be visible');
                }, 100);
            }, 500);
        };
        
        // Debug and fix sidebar visibility
        window.fixSidebar = function() {
            const sidebar = document.querySelector('.sidebar');
            const mainContainer = document.querySelector('.main-container');
            
            if (sidebar) {
                
                // Force sidebar to be visible with aggressive styling
                sidebar.style.display = 'block';
                sidebar.style.visibility = 'visible';
                sidebar.style.position = 'fixed';
                sidebar.style.top = '0';
                sidebar.style.left = '0';
                sidebar.style.zIndex = '9999';
                sidebar.style.backgroundColor = 'rgba(255, 0, 0, 0.9)'; // Bright red background for visibility
                sidebar.style.border = '5px solid yellow'; // Yellow border for visibility
                sidebar.style.width = '1140px';
                sidebar.style.height = '100vh';
                
            } else {
                console.log('❌ Sidebar not found');
            }
            
            if (mainContainer) {
            }
        };
        
        // Restore original sidebar styling
        window.restoreSidebar = function() {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                // Remove the aggressive styling
                sidebar.style.position = '';
                sidebar.style.top = '';
                sidebar.style.left = '';
                sidebar.style.backgroundColor = '';
                sidebar.style.border = '';
                sidebar.style.width = '';
                sidebar.style.height = '';
                sidebar.style.zIndex = '1000';
                
            }
        };
        
        // Create a completely new visible sidebar for testing
        window.createTestSidebar = function() {
            // Remove existing test sidebar if it exists
            const existingTest = document.getElementById('test-sidebar');
            if (existingTest) {
                existingTest.remove();
            }
            
            // Create a new test sidebar
            const testSidebar = document.createElement('div');
            testSidebar.id = 'test-sidebar';
            testSidebar.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 300px;
                    height: 100vh;
                    background: linear-gradient(45deg, #ff0000, #ffff00);
                    border: 10px solid #00ff00;
                    z-index: 99999;
                    padding: 20px;
                    font-size: 24px;
                    color: #000000;
                    font-weight: bold;
                ">
                    <h1>TEST SIDEBAR</h1>
                    <p>If you can see this, the sidebar system works!</p>
                    <button onclick="document.getElementById('test-sidebar').remove()" style="
                        background: #000000;
                        color: #ffffff;
                        padding: 10px 20px;
                        border: none;
                        cursor: pointer;
                        font-size: 16px;
                    ">Remove Test Sidebar</button>
                </div>
            `;
            
            document.body.appendChild(testSidebar);
            console.log('🧪 Test sidebar created - you should see a bright red/yellow sidebar');
        };
        
        // Emergency full-screen overlay to test if ANY elements can be rendered
        window.emergencyOverlay = function() {
            // Remove any existing emergency overlay
            const existing = document.getElementById('emergency-overlay');
            if (existing) {
                existing.remove();
            }
            
            // Create a full-screen overlay that covers everything
            const overlay = document.createElement('div');
            overlay.id = 'emergency-overlay';
            overlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: linear-gradient(45deg, #ff0000, #00ff00, #0000ff, #ffff00) !important;
                z-index: 999999 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                font-size: 48px !important;
                font-weight: bold !important;
                color: #ffffff !important;
                text-shadow: 2px 2px 4px #000000 !important;
                border: 10px solid #ffffff !important;
            `;
            
            overlay.innerHTML = `
                <div style="text-align: center;">
                    <h1>EMERGENCY OVERLAY</h1>
                    <p>If you can see this, the browser can render elements!</p>
                    <button onclick="document.getElementById('emergency-overlay').remove()" style="
                        background: #000000;
                        color: #ffffff;
                        padding: 20px 40px;
                        border: 3px solid #ffffff;
                        cursor: pointer;
                        font-size: 24px;
                        margin-top: 20px;
                    ">REMOVE OVERLAY</button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            console.log('🚨 EMERGENCY OVERLAY CREATED - This should cover the entire screen!');
        };
        
        // Check for any CSS that might be hiding elements
        window.debugCSS = function() {
            const sidebar = document.querySelector('.sidebar');
            if (sidebar) {
                const computedStyle = window.getComputedStyle(sidebar);
                console.log('  display:', computedStyle.display);
                console.log('  visibility:', computedStyle.visibility);
                console.log('  opacity:', computedStyle.opacity);
                console.log('  position:', computedStyle.position);
                console.log('  top:', computedStyle.top);
                console.log('  left:', computedStyle.left);
                console.log('  width:', computedStyle.width);
                console.log('  height:', computedStyle.height);
                console.log('  z-index:', computedStyle.zIndex);
                console.log('  transform:', computedStyle.transform);
                console.log('  clip-path:', computedStyle.clipPath);
                console.log('  overflow:', computedStyle.overflow);
                console.log('  clip:', computedStyle.clip);
                
                // Check if parent elements are hiding it
                let parent = sidebar.parentElement;
                let level = 0;
                while (parent && level < 5) {
                    const parentStyle = window.getComputedStyle(parent);
                    console.log(`🔍 PARENT ${level} (${parent.tagName}):`, {
                        display: parentStyle.display,
                        visibility: parentStyle.visibility,
                        opacity: parentStyle.opacity,
                        overflow: parentStyle.overflow,
                        clip: parentStyle.clip
                    });
                    parent = parent.parentElement;
                    level++;
                }
            }
        };
        
        // Add keyboard shortcut for manual reset (Ctrl/Cmd + Shift + R)
        document.addEventListener('keydown', function(e) {
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'R') {
                e.preventDefault();
                resetBrowserView();
            }
        });
        
        // Detect iframe context and add class for mobile adjustments
        function detectIframeContext() {
            if (window !== window.top) {
                document.body.classList.add('iframe-context');
                console.log('🔗 Iframe context detected - applying mobile control adjustments');
            }
        }

        // iOS viewport locking to prevent zoom
        (function () {
            const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            if (!isiOS) return;
            let m = document.querySelector('meta[name="viewport"]');
            if (!m) {
                m = document.createElement('meta');
                m.name = 'viewport';
                document.head.appendChild(m);
            }
            m.setAttribute('content','width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover');
        })();

        // ========================================
        // DRAWING TOOL FUNCTIONS
        // ========================================
        
        // Initialize drawing tools with Geoman
        function initDrawingTools() {
            // Create feature group for drawn items
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);
            
            // Initialize Geoman on the map
            map.pm.addControls({
                position: 'topleft',
                drawCircle: false,
                drawMarker: false,
                drawCircleMarker: false,
                drawPolyline: false,
                drawRectangle: false,
                drawPolygon: false,
                editMode: true,
                dragMode: true,
                cutPolygon: false,
                removalMode: true
            });
            
            // Hide Geoman toolbar completely (we use custom pencil button)
            // Use setTimeout to ensure toolbar is rendered first
            setTimeout(() => {
                const geomanToolbar = document.querySelector('.leaflet-pm-toolbar');
                if (geomanToolbar) {
                    geomanToolbar.style.display = 'none';
                    geomanToolbar.style.visibility = 'hidden';
                    geomanToolbar.remove(); // Completely remove from DOM
                    console.log('Geoman toolbar hidden and removed');
                } else {
                    console.log('Geoman toolbar not found');
                }
                
                // Also hide any other PM controls that might appear
                const pmControls = document.querySelectorAll('.leaflet-pm-toolbar, .leaflet-control-layers');
                pmControls.forEach(control => {
                    if (control && control.classList.contains('leaflet-pm-toolbar')) {
                        control.style.display = 'none';
                        control.remove();
                    }
                });
            }, 100);
            
            // Configure Geoman global options
            map.pm.setGlobalOptions({
                pmIgnore: false,
                allowSelfIntersection: false,
                allowSelfIntersectionEdit: false
            });
            
            // Add Geoman event listeners (for editing only, not creation)
            // Note: pm:create is removed since we create polygons manually with custom drawing
            
            // Handle edits to keep results in sync
            map.on('pm:edit', function(e) {
                console.log('Geoman edit event:', e);
                const layer = e.layer;
                const tapsInShape = getVisibleTapsInShape(layer);
                showCircleResults(tapsInShape, layer);
            });
            
            // Handle shape removal
            map.on('pm:remove', function(e) {
                console.log('Geoman remove event:', e);
                closeCircleResults();
            });
            
            // Listen for drag events during repositioning
            map.on('pm:dragstart', function(e) {
                isDragging = true;
            });
            
            map.on('pm:drag', function(e) {
                debouncedUpdateResults();
            });
            
            map.on('pm:dragend', function(e) {
                isDragging = false;
                const layer = e.layer;
                const tapsInShape = getVisibleTapsInShape(layer);
                showCircleResults(tapsInShape, layer);
            });
            
            // Add custom map event handlers for click/drag detection
            addCustomMapEventHandlers();
            
            // Initialize drawing button
            initDrawingButton();
        }
        
        // Initialize drawing button
        function initDrawingButton() {
            const drawToggleBtn = document.getElementById('drawToggleBtn');
            
            drawToggleBtn.addEventListener('click', function() {
                toggleDrawingMode();
            });
        }
        
        // Check if device is mobile/touch
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0);
        }
        
        // Toggle drawing mode
        function toggleDrawingMode() {
            const drawToggleBtn = document.getElementById('drawToggleBtn');
            const mapContainer = document.getElementById('map');
            console.log('Toggle drawing mode, current state:', isCrosshairsMode);
            
            if (isCrosshairsMode) {
                // Disable drawing mode
                console.log('Disabling draw mode');
                isCrosshairsMode = false;
                drawToggleBtn.classList.remove('active');
                mapContainer.classList.remove('drawing-mode');
                mapContainer.classList.remove('drawing-active');
                
                // Cancel any in-progress drawing
                isDrawing = false;
                drawingPoints = [];
                previewNeedsUpdate = false;
                cleanupTemporaryPath();
                
                // Clear all drawn shapes and close results
                if (drawnItems) {
                    drawnItems.clearLayers();
                    console.log('Cleared all drawn shapes');
                }
                closeCircleResults();
                
                // Re-enable map dragging (zoom was never disabled)
                console.log('Re-enabling map dragging...');
                map.dragging.enable();
                
                // Ensure touch-action CSS is removed by forcing a style update
                mapContainer.style.touchAction = '';
                console.log('Map dragging re-enabled, touch-action cleared');
                
                // Remove custom event listeners (both mobile and desktop)
                map.off('pointerdown', startFreehandDrawing);
                map.off('pointermove', continueFreehandDrawing);
                map.off('pointerup', finishFreehandDrawing);
                map.off('pointercancel', cancelFreehandDrawing);
                
                // Remove mobile-specific DOM event listeners
                const mapContainerElement = map.getContainer();
                mapContainerElement.removeEventListener('pointerdown', startMobileDrawing);
                mapContainerElement.removeEventListener('pointermove', continueMobileDrawing);
                mapContainerElement.removeEventListener('pointerup', finishMobileDrawing);
                mapContainerElement.removeEventListener('pointercancel', cancelMobileDrawing);
                
                // Remove fallback event listeners
                map.off('mousedown', startFreehandDrawing);
                map.off('mousemove', continueFreehandDrawing);
                map.off('mouseup', finishFreehandDrawing);
                map.off('touchstart', startFreehandDrawing);
                map.off('touchmove', continueFreehandDrawing);
                map.off('touchend', finishFreehandDrawing);
                
                // Disable Geoman draw mode (in case it was active)
                map.pm.disableDraw();
                closeCircleResults();
                
                // Re-enable tap marker interactions
                markers.forEach(marker => {
                    if (marker._tapData) {
                        marker.options.interactive = true;
                    }
                });
                
                // Force a complete state reset to ensure clean exit
                console.log('Draw mode completely disabled - map restored to initial state');
            } else {
                // Enable freehand drawing mode
                console.log('Enabling custom freehand draw mode');
                isCrosshairsMode = true;
                drawToggleBtn.classList.add('active');
                mapContainer.classList.add('drawing-mode');
                
                // Disable map dragging during drawing mode (keep zoom functionality)
                map.dragging.disable();
                
                // Disable tap marker interactions during drawing
                markers.forEach(marker => {
                    if (marker._tapData) {
                        marker.options.interactive = false;
                    }
                });
                
                // Add custom event listeners for freehand drawing
                if (isMobileDevice()) {
                    // Mobile: Use DOM-level pointer events with setPointerCapture
                    console.log('Enabling mobile drawing mode with DOM-level pointer capture');
                    const mapContainer = map.getContainer();
                    mapContainer.addEventListener('pointerdown', startMobileDrawing, { passive: false });
                    mapContainer.addEventListener('pointermove', continueMobileDrawing, { passive: false });
                    mapContainer.addEventListener('pointerup', finishMobileDrawing, { passive: false });
                    mapContainer.addEventListener('pointercancel', cancelMobileDrawing, { passive: false });
                } else {
                    // Desktop: Use standard pointer events and fallbacks
                    console.log('Enabling desktop drawing mode');
                    map.on('pointerdown', startFreehandDrawing);
                    map.on('pointermove', continueFreehandDrawing);
                    map.on('pointerup', finishFreehandDrawing);
                    map.on('pointercancel', cancelFreehandDrawing);
                    
                    // Fallback to mouse/touch events if pointer events don't work
                    map.on('mousedown', startFreehandDrawing);
                    map.on('mousemove', continueFreehandDrawing);
                    map.on('mouseup', finishFreehandDrawing);
                    map.on('touchstart', startFreehandDrawing);
                    map.on('touchmove', continueFreehandDrawing);
                    map.on('touchend', finishFreehandDrawing);
                }
                
                console.log('Custom freehand drawing enabled with pointer events');
            }
        }
        
        // Custom freehand drawing functions
        /**
         * Start freehand drawing on pointer down
         * Uses Pointer Events API for unified desktop/mobile/stylus support
         */
        function startFreehandDrawing(e) {
            console.log('startFreehandDrawing called:', { isCrosshairsMode, latlng: e.latlng, event: e });
            
            if (!isCrosshairsMode || !e.latlng) {
                console.log('Drawing not started - conditions not met');
                return;
            }
            
            // Prevent default browser behavior (especially mobile scrolling)
            if (e.originalEvent && e.originalEvent.preventDefault) {
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
            }
            
            isDrawing = true;
            drawingPoints = [e.latlng];
            previewNeedsUpdate = true;
            
            // Map interactions are already disabled when entering drawing mode
            // Add drawing-active class for cursor feedback
            document.getElementById('map').classList.add('drawing-active');
            
            // Update ARIA live region for accessibility
            updateAriaLiveRegion('Freehand drawing started');
            
            console.log('Started drawing at:', e.latlng);
        }

        /**
         * Continue drawing as pointer moves
         */
        function continueFreehandDrawing(e) {
            if (!isDrawing || !e.latlng) return;
            
            // Prevent default browser behavior (especially mobile scrolling)
            if (e.originalEvent && e.originalEvent.preventDefault) {
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
            }
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            
            // Adaptive point collection based on zoom and device
            if (shouldAddPoint(e.latlng, lastPoint)) {
                drawingPoints.push(e.latlng);
                previewNeedsUpdate = true; // Set flag for rAF render
                console.log('Added point, total points:', drawingPoints.length);
            }
        }

        /**
         * Finish drawing on pointer up
         */
        function finishFreehandDrawing(e) {
            if (!isDrawing) return;
            
            // Prevent default browser behavior (especially mobile scrolling)
            if (e.originalEvent && e.originalEvent.preventDefault) {
                e.originalEvent.preventDefault();
                e.originalEvent.stopPropagation();
            }
            
            isDrawing = false;
            previewNeedsUpdate = false;
            
            // Map interactions stay disabled in drawing mode (user can draw again)
            // Remove drawing-active class
            document.getElementById('map').classList.remove('drawing-active');
            
            // Clean up temporary preview
            cleanupTemporaryPath();
            
            // Create polygon from points if valid
            if (drawingPoints.length >= MIN_POINTS_FOR_POLYGON) {
                createPolygonFromPoints(drawingPoints);
                updateAriaLiveRegion(`Polygon created with ${drawingPoints.length} points`);
            } else {
                updateAriaLiveRegion('Drawing cancelled - not enough points');
            }
            
            drawingPoints = [];
            console.log('Finished drawing');
        }

        /**
         * Cancel drawing (ESC key or pointer cancel event)
         */
        function cancelFreehandDrawing() {
            if (!isDrawing) return;
            
            isDrawing = false;
            previewNeedsUpdate = false;
            drawingPoints = [];
            
            // Map interactions stay disabled in drawing mode (user can draw again)
            // Remove drawing-active class
            document.getElementById('map').classList.remove('drawing-active');
            
            // Clean up temporary preview
            cleanupTemporaryPath();
            
            updateAriaLiveRegion('Drawing cancelled');
            console.log('Drawing cancelled');
        }
        
        // Mobile-specific DOM-level pointer event handlers with setPointerCapture
        function startMobileDrawing(e) {
            if (!isCrosshairsMode) {
                console.log('Mobile drawing not started - conditions not met');
                return;
            }
            
            // Don't start drawing if this is a multi-touch gesture
            if (e.pointerType === 'touch' && e.isPrimary === false) {
                console.log('Ignoring secondary pointer for multi-touch gesture');
                return;
            }
            
            // Convert DOM event coordinates to lat/lng manually
            const mapContainer = map.getContainer();
            const rect = mapContainer.getBoundingClientRect();
            const containerPoint = [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
            const latlng = map.containerPointToLatLng(containerPoint);
            
            isDrawing = true;
            drawingPoints = [latlng];
            previewNeedsUpdate = true;
            
            // Use setPointerCapture to ensure we get pointerup/pointercancel
            if (e.pointerId && mapContainer.setPointerCapture) {
                try {
                    mapContainer.setPointerCapture(e.pointerId);
                    console.log('Mobile pointer capture set for pointerId:', e.pointerId);
                } catch (err) {
                    console.log('Mobile setPointerCapture failed:', err);
                }
            }
            
            // Add drawing-active class for cursor feedback
            document.getElementById('map').classList.add('drawing-active');
            
            // Update ARIA live region for accessibility
            updateAriaLiveRegion('Mobile freehand drawing started');
            
            console.log('Started mobile drawing at:', latlng);
        }
        
        function continueMobileDrawing(e) {
            if (!isDrawing) return;
            
            // Cancel drawing if this is a secondary pointer (multi-touch detected)
            if (e.pointerType === 'touch' && e.isPrimary === false) {
                console.log('Multi-touch detected during drawing - cancelling');
                cancelMobileDrawing(e);
                return;
            }
            
            // Convert DOM event coordinates to lat/lng manually
            const mapContainer = map.getContainer();
            const rect = mapContainer.getBoundingClientRect();
            const containerPoint = [
                e.clientX - rect.left,
                e.clientY - rect.top
            ];
            const latlng = map.containerPointToLatLng(containerPoint);
            
            const lastPoint = drawingPoints[drawingPoints.length - 1];
            
            // Adaptive point collection based on zoom and device
            if (shouldAddPoint(latlng, lastPoint)) {
                drawingPoints.push(latlng);
                previewNeedsUpdate = true; // Set flag for rAF render
                console.log('Added mobile point, total points:', drawingPoints.length);
            }
        }
        
        function finishMobileDrawing(e) {
            if (!isDrawing) return;
            
            isDrawing = false;
            previewNeedsUpdate = false;
            
            // Release pointer capture
            if (e && e.pointerId && map.getContainer().releasePointerCapture) {
                try {
                    map.getContainer().releasePointerCapture(e.pointerId);
                    console.log('Mobile pointer capture released for pointerId:', e.pointerId);
                } catch (err) {
                    console.log('Mobile releasePointerCapture failed:', err);
                }
            }
            
            // Remove drawing-active class
            document.getElementById('map').classList.remove('drawing-active');
            
            // Clean up temporary preview
            cleanupTemporaryPath();
            
            // Create polygon from points if valid
            if (drawingPoints.length >= MIN_POINTS_FOR_POLYGON) {
                createPolygonFromPoints(drawingPoints);
                updateAriaLiveRegion(`Mobile polygon created with ${drawingPoints.length} points`);
            } else {
                updateAriaLiveRegion('Mobile drawing cancelled - not enough points');
            }
            
            drawingPoints = [];
            console.log('Finished mobile drawing');
        }
        
        function cancelMobileDrawing(e) {
            if (!isDrawing) return;
            
            isDrawing = false;
            previewNeedsUpdate = false;
            drawingPoints = [];
            
            // Release pointer capture
            if (e && e.pointerId && map.getContainer().releasePointerCapture) {
                try {
                    map.getContainer().releasePointerCapture(e.pointerId);
                    console.log('Mobile pointer capture released on cancel for pointerId:', e.pointerId);
                } catch (err) {
                    console.log('Mobile releasePointerCapture failed on cancel:', err);
                }
            }
            
            // Remove drawing-active class
            document.getElementById('map').classList.remove('drawing-active');
            
            // Clean up temporary preview
            cleanupTemporaryPath();
            
            updateAriaLiveRegion('Mobile drawing cancelled');
            console.log('Mobile drawing cancelled');
        }

        /**
         * Show real-time preview of drawing path using requestAnimationFrame
         */
        function updateTemporaryPath() {
            if (!previewNeedsUpdate || drawingPoints.length < 2) return;
            
            // Cancel previous animation frame
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            animationFrameId = requestAnimationFrame(() => {
                // Remove existing preview
                if (temporaryPolyline) {
                    map.removeLayer(temporaryPolyline);
                }
                
                // Create new preview polyline
                temporaryPolyline = L.polyline(drawingPoints, {
                    color: '#007bff',
                    weight: 2,
                    opacity: 0.7,
                    interactive: false
                }).addTo(map);
                
                previewNeedsUpdate = false;
            });
        }

        /**
         * Clean up temporary preview path
         */
        function cleanupTemporaryPath() {
            if (temporaryPolyline) {
                map.removeLayer(temporaryPolyline);
                temporaryPolyline = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        /**
         * Simplify points using distance-based algorithm with adaptive tolerance
         */
        function simplifyPoints(points, tolerance = null) {
            if (points.length <= MIN_POINTS_FOR_POLYGON) return points;
            
            // Adaptive tolerance based on zoom level (2-3 pixels converted to meters)
            if (!tolerance) {
                const zoom = map.getZoom();
                const pixelToMeterRatio = 40075016.686 / (256 * Math.pow(2, zoom)); // meters per pixel
                tolerance = Math.max(2 * pixelToMeterRatio, POINT_SIMPLIFICATION_TOLERANCE);
            }
            
            const simplified = [points[0]]; // Always keep first point
            
            for (let i = 1; i < points.length - 1; i++) {
                const prevPoint = simplified[simplified.length - 1];
                const distance = map.distance(prevPoint, points[i]);
                
                if (distance > tolerance) {
                    simplified.push(points[i]);
                }
            }
            
            // Always keep last point
            simplified.push(points[points.length - 1]);
            
            console.log(`Simplified ${points.length} points to ${simplified.length} points`);
            return simplified;
        }

        /**
         * Create polygon from drawn points and enable editing
         */
        function createPolygonFromPoints(points) {
            try {
                // Simplify points for smoother shape
                const simplified = simplifyPoints(points);
                
                if (simplified.length < MIN_POINTS_FOR_POLYGON) {
                    console.warn('Not enough points for polygon:', simplified.length);
                    return;
                }
                
                // Ensure polygon is properly closed
                const closedPoints = [...simplified];
                if (closedPoints.length > 2) {
                    // Check if already closed (first and last points are the same)
                    const first = closedPoints[0];
                    const last = closedPoints[closedPoints.length - 1];
                    const distance = map.distance(first, last);
                    if (distance > 1) { // More than 1 meter apart
                        closedPoints.push(closedPoints[0]); // Close the polygon
                    }
                }
                
                // Clear any existing shapes
                drawnItems.clearLayers();
                closeCircleResults();
                
                // Create polygon with styling
                const polygon = L.polygon(closedPoints, {
                    color: '#007bff',
                    fillColor: '#007bff',
                    fillOpacity: 0.1,
                    weight: 2
                });
                
                // Add to map
                drawnItems.addLayer(polygon);
                
                // Don't enable Geoman editing - polygon is view-only
                // Users can delete by clicking outside to draw a new shape
                // No vertex dots, no dragging - clean appearance
                
                // Get taps in shape and show results
                const tapsInShape = getVisibleTapsInShape(polygon);
                showCircleResults(tapsInShape, polygon);
                
                console.log('Created polygon with', closedPoints.length, 'points');
                
            } catch (error) {
                console.error('Error creating polygon:', error);
                // Clean up on error
                cleanupTemporaryPath();
            }
        }

        /**
         * Determine if a new point should be added based on distance and device
         */
        function shouldAddPoint(newPoint, lastPoint) {
            if (!lastPoint) return true;
            
            // Adaptive distance based on device and zoom
            const zoom = map.getZoom();
            const baseDistance = isMobileDevice() ? 15 : 5; // meters
            const zoomFactor = Math.max(0.5, 1 / Math.pow(2, zoom - 10)); // Scale with zoom
            const minDistance = baseDistance * zoomFactor;
            
            const distance = map.distance(lastPoint, newPoint);
            return distance > minDistance;
        }

        /**
         * Update ARIA live region for accessibility
         */
        function updateAriaLiveRegion(message) {
            let liveRegion = document.getElementById('drawing-live-region');
            if (!liveRegion) {
                liveRegion = document.createElement('div');
                liveRegion.id = 'drawing-live-region';
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.style.position = 'absolute';
                liveRegion.style.left = '-10000px';
                liveRegion.style.width = '1px';
                liveRegion.style.height = '1px';
                liveRegion.style.overflow = 'hidden';
                document.body.appendChild(liveRegion);
            }
            liveRegion.textContent = message;
        }
        
        // Get visible taps within a shape (polygon or circle)
        function getVisibleTapsInShape(shape) {
            console.log('getVisibleTapsInShape called with:', shape);
            console.log('Total markers available:', markers.length);
            
            if (shape instanceof L.Circle) {
                console.log('Processing circle');
                // Handle circles (for backward compatibility)
                const center = shape.getLatLng();
                const radius = shape.getRadius();
                
                // Pre-filter by bounds for performance
                const bounds = shape.getBounds();
                
                const result = markers.filter(marker => {
                    const markerPos = marker.getLatLng();
                    
                    // Quick bounds check first
                    if (!bounds.contains(markerPos)) {
                        return false;
                    }
                    
                    // Then distance check
                    const distance = center.distanceTo(markerPos);
                    return distance <= radius;
                }).map(marker => marker._tapData);
                
                console.log('Circle result:', result.length, 'taps found');
                return result;
            } else if (shape instanceof L.Polygon) {
                console.log('Processing polygon');
                // Handle polygons using point-in-polygon detection
                const result = markers.filter(marker => {
                    if (!marker._tapData) return false;
                    
                    const markerPos = marker.getLatLng();
                    
                    // First do a quick bounds check
                    if (!shape.getBounds().contains(markerPos)) {
                        return false;
                    }
                    
                    // Then do precise point-in-polygon check
                    const inside = isPointInPolygon(markerPos, shape);
                    if (inside) {
                        console.log('Marker inside polygon:', marker._tapData);
                    }
                    return inside;
                }).map(marker => marker._tapData);
                
                console.log('Polygon result:', result.length, 'taps found');
                return result;
            }
            
            console.log('Unknown shape type, returning empty array');
            return [];
        }
        
        // Point-in-polygon detection using ray casting algorithm
        function isPointInPolygon(point, polygon) {
            const lat = point.lat;
            const lng = point.lng;
            const latlngs = polygon.getLatLngs()[0]; // Get outer ring
            
            let inside = false;
            for (let i = 0, j = latlngs.length - 1; i < latlngs.length; j = i++) {
                const xi = latlngs[i].lng;
                const yi = latlngs[i].lat;
                const xj = latlngs[j].lng;
                const yj = latlngs[j].lat;
                
                if (((yi > lat) !== (yj > lat)) && (lng < (xj - xi) * (lat - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            
            return inside;
        }
        
        // Show circle results in dropdown
        function showCircleResults(tapsInCircle, circle) {
            console.log('showCircleResults called:', { tapsInCircle: tapsInCircle.length, circle: circle });
            
            // Clear any existing dropdown first
            closeCircleResults();
            
            if (tapsInCircle.length === 0) {
                console.log('No taps found, showing empty results');
                showEmptyResults();
                return;
            }
            
            console.log('Creating dropdown with', tapsInCircle.length, 'taps');
            
            // Sort taps by timestamp (most recent first)
            const sortedTaps = [...tapsInCircle].sort((a, b) => {
                const timeA = a.timestamp || new Date(a.time).getTime();
                const timeB = b.timestamp || new Date(b.time).getTime();
                return timeB - timeA; // Descending order (newest first)
            });
            
            // Create portal dropdown using the working approach from develop branch
            const portalRoot = getPortalRoot();
            const dropdown = document.createElement('div');
            dropdown.className = 'portal-dropdown';
            
            // Build content from tap data using proper CSS classes
            dropdown.innerHTML = sortedTaps.map(tap => {
                // Extract city name (first part before comma)
            const cityName = tap.formatted_location 
                ? tap.formatted_location.split(',').slice(0, 2).join(',').trim() 
                : 'N/A';
                
                // Format date as M/D/YYYY
                let formattedDate = 'N/A';
                if (tap.timestamp || tap.time) {
                    const tapDate = new Date(tap.timestamp || tap.time);
                    formattedDate = `${tapDate.getMonth() + 1}/${tapDate.getDate()}/${tapDate.getFullYear()}`;
                }
                
                return `
                    <div class="degree-user-item" style="display: flex; flex-direction: column; align-items: stretch;">
                        <div class="user-name">${tap.source_name || 'Unknown'} ↔ ${tap.target_name || 'Unknown'}</div>
                        <div class="user-meta" style="display: flex; justify-content: space-between; width: 100%;">
                            <span>${formattedDate}</span>
                            <span>${cityName}</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            console.log('Dropdown HTML created, appending to portal-root');
            portalRoot.appendChild(dropdown);
            currentDropdown = dropdown;
            
            console.log('Dropdown appended, calling positionDropdownNearCircle');
            // Position dropdown relative to circle
            positionDropdownNearCircle(circle);
            
            // Add close on outside click with delay to prevent drawing-finish click from triggering it
            setTimeout(() => {
                document.addEventListener('click', closeOnOutsideClick);
            }, 100); // Wait 100ms before enabling outside-click-to-close
            
            // Verify dropdown is in DOM
            console.log('Dropdown verification:', {
                inDOM: document.body.contains(currentDropdown),
                parentElement: currentDropdown.parentElement,
                offsetParent: currentDropdown.offsetParent,
                computedStyle: window.getComputedStyle(currentDropdown).display
            });
            
            // Additional debugging for visibility
            const computedStyle = window.getComputedStyle(currentDropdown);
            console.log('Dropdown computed styles:', {
                display: computedStyle.display,
                visibility: computedStyle.visibility,
                opacity: computedStyle.opacity,
                position: computedStyle.position,
                left: computedStyle.left,
                top: computedStyle.top,
                width: computedStyle.width,
                height: computedStyle.height,
                zIndex: computedStyle.zIndex,
                backgroundColor: computedStyle.backgroundColor,
                border: computedStyle.border
            });
            
            // Check if dropdown is actually visible
            const rect = currentDropdown.getBoundingClientRect();
            console.log('Dropdown bounding rect:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                bottom: rect.bottom,
                right: rect.right,
                visible: rect.width > 0 && rect.height > 0
            });
            
            console.log('showCircleResults completed');
        }
        
        // Show empty results state
        function showEmptyResults() {
            console.log('showEmptyResults called');
            
            // Clear any existing dropdown first
            closeCircleResults();
            
            const dropdown = document.createElement('div');
            dropdown.className = 'portal-dropdown';
            dropdown.innerHTML = `
                <div class="degree-user-item">
                    <div class="user-name">No visible taps in this area</div>
                    <div class="user-meta">(filters applied)</div>
                </div>
            `;
            
            console.log('Empty results dropdown created, appending to portal-root');
            // Use portal-root approach like the working develop branch
            const portalRoot = getPortalRoot();
            portalRoot.appendChild(dropdown);
            currentDropdown = dropdown;
            
            // Position the empty results dropdown in the center of the screen
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const dropdownWidth = 200;
            const dropdownHeight = 150;
            
            const left = Math.max(10, (viewportWidth - dropdownWidth) / 2);
            const top = Math.max(10, (viewportHeight - dropdownHeight) / 2);
            
            currentDropdown.style.position = 'fixed';
            currentDropdown.style.left = `${left}px`;
            currentDropdown.style.top = `${top}px`;
            currentDropdown.style.width = `${dropdownWidth}px`;
            currentDropdown.style.zIndex = '10000';
            currentDropdown.style.display = 'block';
            currentDropdown.style.visibility = 'visible';
            
            console.log('Empty results positioned at center:', { left, top });
        }
        
        // Position dropdown near shape (circle or polygon) - using working approach from develop
        function positionDropdownNearCircle(shape) {
            if (!currentDropdown) return;
            
            // Get shape center - handle both circles and polygons
            let center;
            if (shape instanceof L.Circle) {
                center = shape.getLatLng();
            } else if (shape instanceof L.Polygon) {
                const bounds = shape.getBounds();
                center = bounds.getCenter();
            } else {
                return;
            }
            
            const point = map.latLngToContainerPoint(center);
            const containerRect = map.getContainer().getBoundingClientRect();
            
            const isMobile = window.innerWidth <= 768;
            
            if (isMobile) {
                // Mobile: full width with padding
                const padding = 16;
                currentDropdown.style.left = `${padding}px`;
                currentDropdown.style.right = `${padding}px`;
                currentDropdown.style.top = `${point.y + containerRect.top + 20}px`;
            } else {
                // Desktop: positioned near circle center
                let left = point.x + containerRect.left;
                let top = point.y + containerRect.top + 20;
                
                // Adjust to keep in viewport
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                const dropdownWidth = 200; // min-width from CSS
                const dropdownHeight = Math.min(currentDropdown.scrollHeight, 300);
                
                if (left + dropdownWidth > viewportWidth - 10) {
                    left = viewportWidth - dropdownWidth - 10;
                }
                if (left < 10) {
                    left = 10;
                }
                
                if (top + dropdownHeight > viewportHeight - 10) {
                    top = viewportHeight - dropdownHeight - 10;
                }
                if (top < 10) {
                    top = 10;
                }
                
                currentDropdown.style.left = `${left}px`;
                currentDropdown.style.top = `${top}px`;
            }
        }
        
        // Get or create portal root
        function getPortalRoot() {
            let portalRoot = document.querySelector('.portal-root');
            if (!portalRoot) {
                portalRoot = document.createElement('div');
                portalRoot.className = 'portal-root';
                document.body.appendChild(portalRoot);
            }
            return portalRoot;
        }
        
        // Close circle results
        function closeCircleResults() {
            if (currentDropdown) {
                currentDropdown.remove();
                currentDropdown = null;
            }
            document.removeEventListener('click', closeOnOutsideClick);
        }
        
        // Close on outside click
        function closeOnOutsideClick(e) {
            const inDropdown = e.target.closest('.portal-dropdown');
            const inDrawButton = e.target.closest('#drawToggleBtn');
            
            if (!inDropdown && !inDrawButton) {
                closeCircleResults();
            }
        }
        
        // Handle filter changes - refresh results if circle exists
        function refreshCircleResultsOnFilterChange() {
            if (drawnItems && drawnItems.getLayers().length > 0) {
                const circle = drawnItems.getLayers()[0];
                if (circle instanceof L.Circle) {
                    const tapsInCircle = getVisibleTapsInCircle(circle);
                    showCircleResults(tapsInCircle, circle);
                }
            }
        }
        
        // Hide the Leaflet.draw control panel
        function hideControlPanel() {
            const controlPanel = document.querySelector('.leaflet-draw-toolbar');
            if (controlPanel) {
                controlPanel.style.display = 'none';
            }
        }
        
        // Programmatically trigger circle drawing tool
        function triggerCircleDrawing() {
            // Find and click the circle drawing button
            const circleButton = document.querySelector('.leaflet-draw-toolbar a[title*="circle" i], .leaflet-draw-toolbar a[title*="Circle"]');
            if (circleButton) {
                circleButton.click();
            }
        }
        
        // Add custom map event handlers for click/drag detection
        function addCustomMapEventHandlers() {
            // Mouse events
            map.on('mousedown', function(e) {
                if (isCrosshairsMode) {
                    clickStartPos = e.containerPoint;
                }
            });
            
            map.on('mousemove', function(e) {
                if (isCrosshairsMode && clickStartPos) {
                    const distance = clickStartPos.distanceTo(e.containerPoint);
                    if (distance > dragThreshold) {
                        // This is a drag, not a click
                        clickStartPos = null;
                    }
                }
            });
            
            map.on('mouseup', function(e) {
                if (isCrosshairsMode && clickStartPos) {
                    const distance = clickStartPos.distanceTo(e.containerPoint);
                    if (distance <= dragThreshold) {
                        // This is a click, not a drag
                        // Check if we clicked on a shape or empty space
                        if (!isClickOnShape(e.latlng)) {
                            // Clicked on empty space - clear existing shape and stay in draw mode
                            clearExistingShapeAndResetDrawMode();
                        }
                    }
                    clickStartPos = null;
                }
            });
            
            // Note: Touch events are now handled by unified pointer events in toggleDrawingMode()
            // This provides better cross-platform support for desktop/mobile/stylus
        }
        
        // Note: createShapeAtLocation function removed - now using unified pointer events
        // for both desktop and mobile freehand drawing
        
        // Update center handle size to match circle
        function updateCenterHandleSize(circle) {
            if (!circle || !map) return;
            
            try {
                // Get circle center and radius
                const center = circle.getLatLng();
                const radius = circle.getRadius();
                
                // Convert radius to pixels by calculating two points
                const centerPoint = map.latLngToLayerPoint(center);
                const edgePoint = map.latLngToLayerPoint(center.destinationPoint(0, radius));
                
                // Calculate diameter in pixels
                const diameterPx = Math.abs(edgePoint.x - centerPoint.x) * 2;
                
                // Find the center handle element
                const centerHandle = document.querySelector('.leaflet-editing-icon.leaflet-edit-move');
                if (centerHandle) {
                    // Set dynamic size
                    centerHandle.style.width = diameterPx + 'px';
                    centerHandle.style.height = diameterPx + 'px';
                    centerHandle.style.marginLeft = -(diameterPx / 2) + 'px';
                    centerHandle.style.marginTop = -(diameterPx / 2) + 'px';
                }
            } catch (error) {
                console.warn('Could not update center handle size:', error);
            }
        }
        
        // Enable edit mode on a circle (shows resize/move handles on hover)
        function enableCircleEditMode(layer) {
            // Make the circle editable by enabling Leaflet.draw edit handlers
            layer.editing.enable();
            
            // Update center handle size to match circle
            updateCenterHandleSize(layer);
            
            // Add event listeners for debounced updates during drag/resize
            if (layer._mRadius) {
                // Listen to the drag events on the circle itself
                layer.on('drag', function() {
                    debouncedUpdateResults();
                });
            }
        }
        
        // Check if click is on an existing circle
        function isClickOnShape(latlng) {
            if (!drawnItems || drawnItems.getLayers().length === 0) {
                return false;
            }
            
            let clickedOnShape = false;
            
            drawnItems.eachLayer(layer => {
                if (layer instanceof L.Polygon) {
                    // Use point-in-polygon detection for polygons
                    if (isPointInPolygon(latlng, layer)) {
                        clickedOnShape = true;
                    }
                } else if (layer instanceof L.Circle) {
                    // Handle circles (for backward compatibility)
                    const center = layer.getLatLng();
                    const radius = layer.getRadius();
                    const distance = center.distanceTo(latlng);
                    if (distance <= radius) {
                        clickedOnShape = true;
                    }
                }
            });
            
            return clickedOnShape;
        }
        
        // Clear existing shape and re-enable draw mode
        function clearExistingShapeAndResetDrawMode() {
            if (drawnItems && drawnItems.getLayers().length > 0) {
                drawnItems.clearLayers();
                closeCircleResults();
                // Custom drawing mode is already active - no need to re-enable Geoman
                // The custom pointer event listeners are already attached in toggleDrawingMode()
                console.log('Cleared shape, ready to draw again');
            }
        }
        
        // Debounced update results to prevent spazzy updates during drag
        function debouncedUpdateResults() {
            // Clear any existing timeout
            if (drawUpdateTimeout) {
                clearTimeout(drawUpdateTimeout);
            }
            
            // Set a new timeout to update after drag stops
            drawUpdateTimeout = setTimeout(() => {
                if (drawnItems && drawnItems.getLayers().length > 0) {
                    const circle = drawnItems.getLayers()[0];
                    if (circle instanceof L.Circle) {
                        const tapsInCircle = getVisibleTapsInCircle(circle);
                        showCircleResults(tapsInCircle, circle);
                    }
                }
            }, 150); // 150ms delay to wait for drag to settle
        }
        
        // Clear existing circle but stay in crosshairs mode (deprecated - kept for compatibility)
        function clearExistingCircle() {
            if (drawnItems && drawnItems.getLayers().length > 0) {
                drawnItems.clearLayers();
                closeCircleResults();
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            detectIframeContext();
            preventGlobalZoom();
            init();
            
            // Initialize user search immediately (user-centric mode)
            initUserSearch();
            
            // Initialize floating search
            initFloatingSearch();
            
            // Setup control panel reversion listeners
            setupControlPanelReversion();
            
            // Check for userName parameter and auto-select user
            const urlParams = new URLSearchParams(window.location.search);
            const userName = urlParams.get('userName');
            if (userName) {
                // Direct user selection without going through search UI
                setTimeout(() => {
                    // Find user in completeLocationData
                    const user = findUserByName(userName);
                    if (user) {
                        selectUser(user.id, user.name);
                    }
                }, 1000);
            }
            
            // Sidebar is now working properly with browser zoom fixed
            // No need for aggressive styling fixes
        });

        // ========================================
        // MOBILE RESPONSIVE FUNCTIONS
        // ========================================
        
        // Mobile resize variables
        let isMobileResizing = false;
        let mobileStartY = 0;
        let mobileStartHeight = 0;
        let mobileCurrentHeight = 0;
        
        function toggleMobileSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const hamburger = document.getElementById('mobileHamburger');
            
            if (sidebar.classList.contains('show')) {
                sidebar.classList.remove('show');
                hamburger.classList.remove('active');
                // Notify parent that control panel is closed
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'controlPanelState',
                        isOpen: false
                    }, '*');
                }
            } else {
                sidebar.classList.add('show');
                hamburger.classList.add('active');
                
                // Reset search to original user when opening control panel (mobile equivalent of desktop behavior)
                if (isViewingSearchedUser) {
                    revertToOriginalUser();
                }
                
                // Notify parent that control panel is open
                if (window.parent) {
                    window.parent.postMessage({
                        type: 'controlPanelState',
                        isOpen: true
                    }, '*');
                }
            }
        }
        
        // ========================================
        // MOBILE RESIZE FUNCTIONS
        // ========================================
        
        // Mobile resize functionality
        function initResize() {
            // Check screen size immediately and only proceed if mobile
            const isMobile = window.matchMedia('(max-width: 900px)').matches;
            const screenWidth = window.innerWidth;
            
            
            // Don't run mobile resize if iframe is still loading (screenWidth: 0)
            if (screenWidth === 0) {
                console.log('🔄 Iframe still loading - skipping mobile resize initialization');
                return;
            }
            
            // Only proceed if mobile
            if (!isMobile) {
                return;
            }
            
            console.log('📱 Mobile detected - initializing resize functionality');
            const sidebar = document.querySelector('.sidebar');
            const resizeHandle = document.getElementById('resizeHandle');
            
            if (!sidebar || !resizeHandle) return;
            
            // Load saved height or use default
            const savedHeight = localStorage.getItem('mobileSidebarHeight');
            if (savedHeight) {
                sidebar.style.setProperty('height', savedHeight, 'important');
                sidebar.style.setProperty('bottom', 'auto', 'important');
            } else {
                // Set initial height to 50% if no saved preference
                sidebar.style.setProperty('height', '50%', 'important');
                sidebar.style.setProperty('bottom', 'auto', 'important');
            }
            
            // Position drag bar at bottom of control panel
            const positionDragBar = () => {
                const sidebarRect = sidebar.getBoundingClientRect();
                const handleTop = sidebarRect.bottom - 40; // 40px is handle height
                resizeHandle.style.setProperty('top', handleTop + 'px', 'important');
                resizeHandle.style.setProperty('bottom', 'auto', 'important');
            };
            
            // Position initially and on resize
            positionDragBar();
            window.addEventListener('resize', positionDragBar);
            
            // Touch events for drag handle
            resizeHandle.addEventListener('touchstart', handleResizeStart, { passive: false });
            resizeHandle.addEventListener('touchmove', handleResizeMove, { passive: false });
            resizeHandle.addEventListener('touchend', handleResizeEnd, { passive: false });
        }
        
        function handleResizeStart(e) {
            // Only work on mobile screens
            if (!window.matchMedia('(max-width: 900px)').matches) return;
            
            isMobileResizing = true;
            mobileStartY = e.touches[0].clientY;
            const sidebar = document.querySelector('.sidebar');
            
            // Get current height from computed style or inline style
            const currentHeight = sidebar.style.height || getComputedStyle(sidebar).height;
            mobileStartHeight = currentHeight ? parseFloat(currentHeight) : 50; // Default to 50% if no height set                                                                                                 
            
            // Prevent scrolling and other touch events
            e.preventDefault();
            e.stopPropagation();
        }
        
        function handleResizeMove(e) {
            if (!isMobileResizing) return;
            
            const currentY = e.touches[0].clientY;
            const deltaY = currentY - mobileStartY; // Direct drag (not inverted)
            
            // Scale down sensitivity for 1:1 feel (divide by 10 for smoother control)
            const scaledDelta = deltaY / 10;
            const newHeight = Math.max(5, Math.min(95, mobileStartHeight + scaledDelta));
            
            const sidebar = document.querySelector('.sidebar');
            const resizeHandle = document.getElementById('resizeHandle');
            
            // Override CSS with !important to ensure JavaScript controls height
            sidebar.style.setProperty('height', newHeight + '%', 'important');
            sidebar.style.setProperty('bottom', 'auto', 'important');
            
            // Position drag bar at bottom of control panel
            const sidebarRect = sidebar.getBoundingClientRect();
            const handleTop = sidebarRect.bottom - 40; // 40px is handle height
            resizeHandle.style.setProperty('top', handleTop + 'px', 'important');
            resizeHandle.style.setProperty('bottom', 'auto', 'important');
            
            // Prevent scrolling and other touch events
            e.preventDefault();
            e.stopPropagation();
        }
        
        function handleResizeEnd(e) {
            if (!isMobileResizing) return;
            
            isMobileResizing = false;
            const sidebar = document.querySelector('.sidebar');
            const finalHeight = sidebar.style.height;
            
            // Save the height preference
            localStorage.setItem('mobileSidebarHeight', finalHeight);
            
            // Prevent scrolling and other touch events
            e.preventDefault();
            e.stopPropagation();
        }
        
        // Initialize resize on DOM load
        document.addEventListener('DOMContentLoaded', initResize);
    </script>
    
    <!-- Load last, after all app scripts -->
    <script src="/js/console-mute.js"></script>
</body>
</html>
<!-- Deployment trigger -->
